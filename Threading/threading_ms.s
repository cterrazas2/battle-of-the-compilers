; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27508.1 

	TITLE	C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	_ceilf
PUBLIC	_fabsl
PUBLIC	_frexpl
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsprintf_s_l
PUBLIC	_sprintf_s
PUBLIC	?_Fnv1a_append_bytes@std@@YAIIQBEI@Z		; std::_Fnv1a_append_bytes
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAPADQADID@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Orphan_all@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Orphan_all
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data
PUBLIC	?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8std@@YA_NABVerror_condition@0@0@Z		; std::operator==
PUBLIC	??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z ; std::_Conditionally_enabled_hash<int,1>::operator()
PUBLIC	?_Do_hash@?$hash@H@std@@SAIABH@Z		; std::hash<int>::_Do_hash
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??1_System_error@std@@UAE@XZ			; std::_System_error::~_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??0_Facet_base@std@@QAE@XZ			; std::_Facet_base::_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
PUBLIC	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ	; std::_Locinfo::_Getlconv
PUBLIC	?_Getfalse@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Getfalse
PUBLIC	?_Gettrue@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Gettrue
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
PUBLIC	??0?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::_Yarn<wchar_t>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	?_Tidy@?$_Yarn@_W@std@@AAEXXZ			; std::_Yarn<wchar_t>::_Tidy
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?c_str@locale@std@@QBEPBDXZ			; std::locale::c_str
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z	; std::_Adl_verify_range<char const *,char const *>
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z		; std::ctype<char>::widen
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	?precision@ios_base@std@@QBE_JXZ		; std::ios_base::precision
PUBLIC	?width@ios_base@std@@QBE_JXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QAE_J_J@Z			; std::ios_base::width
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	??0random_device@std@@QAE@XZ			; std::random_device::random_device
PUBLIC	??Rrandom_device@std@@QAEIXZ			; std::random_device::operator()
PUBLIC	?_Floor_of_log_2@std@@YAKI@Z			; std::_Floor_of_log_2
PUBLIC	?_Ceiling_of_log_2@std@@YAKI@Z			; std::_Ceiling_of_log_2
PUBLIC	?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ; std::chrono::system_clock::now
PUBLIC	?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
PUBLIC	??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
PUBLIC	??1thread@std@@QAE@XZ				; std::thread::~thread
PUBLIC	?joinable@thread@std@@QBE_NXZ			; std::thread::joinable
PUBLIC	?join@thread@std@@QAEXXZ			; std::thread::join
PUBLIC	_main
PUBLIC	??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@U?$hash@H@1@U?$equal_to@H@1@@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >
PUBLIC	??R?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()
PUBLIC	??R?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBE_NABH0@Z ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()
PUBLIC	?_Gethash@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABU?$hash@H@2@XZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Gethash
PUBLIC	?_Getkeyeq@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABU?$equal_to@H@2@XZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Getkeyeq
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
PUBLIC	??R?$equal_to@H@std@@QBE_NABH0@Z		; std::equal_to<int>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAEAAMXZ ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABMXZ ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_second
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@XZ ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@XZ ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_second
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	?deallocate@?$allocator@H@std@@QAEXQAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
PUBLIC	??0?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ; std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0>::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0>
PUBLIC	?_Kfn@?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@SAABHABH@Z ; std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0>::_Kfn
PUBLIC	?deallocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEXQAU?$_List_node@HPAX@2@I@Z ; std::allocator<std::_List_node<int,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEPAU?$_List_node@HPAX@2@I@Z ; std::allocator<std::_List_node<int,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@2@QAU?$_List_node@HPAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@HPAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@HPAX@std@@@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::select_on_container_copy_construction
PUBLIC	??0?$list@HV?$allocator@H@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
PUBLIC	??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
PUBLIC	?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
PUBLIC	?begin@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::begin
PUBLIC	?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
PUBLIC	?end@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::end
PUBLIC	?_Unchecked_begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Unchecked_begin
PUBLIC	?_Unchecked_begin@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<int,std::allocator<int> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Unchecked_end
PUBLIC	?_Unchecked_end@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<int,std::allocator<int> >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ; std::list<int,std::allocator<int> >::_Make_iter
PUBLIC	?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::list<int,std::allocator<int> >::_Make_iter
PUBLIC	?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@PAU?$_List_node@HPAX@2@@Z ; std::list<int,std::allocator<int> >::_Make_iter
PUBLIC	?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ	; std::list<int,std::allocator<int> >::size
PUBLIC	?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ; std::list<int,std::allocator<int> >::max_size
PUBLIC	?front@?$list@HV?$allocator@H@std@@@std@@QAEAAHXZ ; std::list<int,std::allocator<int> >::front
PUBLIC	?push_front@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::list<int,std::allocator<int> >::push_front
PUBLIC	?_Unlinknode@?$list@HV?$allocator@H@std@@@std@@AAEPAU?$_List_node@HPAX@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::list<int,std::allocator<int> >::_Unlinknode
PUBLIC	?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ; std::list<int,std::allocator<int> >::erase
PUBLIC	?_Tidy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ	; std::list<int,std::allocator<int> >::_Tidy
PUBLIC	?_Unchecked_splice@?$list@HV?$allocator@H@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00@Z ; std::list<int,std::allocator<int> >::_Unchecked_splice
PUBLIC	?_Orphan_ptr2@?$list@HV?$allocator@H@std@@@std@@AAEXPAU?$_List_node@HPAX@2@@Z ; std::list<int,std::allocator<int> >::_Orphan_ptr2
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ ; std::list<int,std::allocator<int> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Getal
PUBLIC	?_Getal@?$list@HV?$allocator@H@std@@@std@@ABEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Getal
PUBLIC	?_Get_data@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Get_data
PUBLIC	?_Get_data@?$list@HV?$allocator@H@std@@@std@@ABEABV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ ; std::list<int,std::allocator<int> >::_Get_data
PUBLIC	?_Myhead@?$list@HV?$allocator@H@std@@@std@@AAEAAPAU?$_List_node@HPAX@2@XZ ; std::list<int,std::allocator<int> >::_Myhead
PUBLIC	?_Myhead@?$list@HV?$allocator@H@std@@@std@@ABEABQAU?$_List_node@HPAX@2@XZ ; std::list<int,std::allocator<int> >::_Myhead
PUBLIC	?_Mysize@?$list@HV?$allocator@H@std@@@std@@AAEAAIXZ ; std::list<int,std::allocator<int> >::_Mysize
PUBLIC	?_Mysize@?$list@HV?$allocator@H@std@@@std@@ABEABIXZ ; std::list<int,std::allocator<int> >::_Mysize
PUBLIC	??0?$_List_val@U?$_List_simple_types@H@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<int> >::_List_val<std::_List_simple_types<int> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_second
PUBLIC	??0?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@H@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >
PUBLIC	?begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::begin
PUBLIC	?end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::end
PUBLIC	?end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::end
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_end
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_end
PUBLIC	?_Make_iter@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Make_iter
PUBLIC	?_Make_iter@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V32@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Make_iter
PUBLIC	?size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::size
PUBLIC	?bucket_count@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::bucket_count
PUBLIC	?load_factor@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEMXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::load_factor
PUBLIC	?max_load_factor@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEMXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::max_load_factor
PUBLIC	?erase@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V32@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::erase
PUBLIC	?find@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@ABH@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::find
PUBLIC	?lower_bound@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@ABH@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::lower_bound
PUBLIC	?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Destroy_if_node
PUBLIC	?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXU_Not_a_node_tag@2@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Destroy_if_node
PUBLIC	?_Vec_lo@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Vec_lo
PUBLIC	?_Vec_hi@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Vec_hi
PUBLIC	?_Begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Begin
PUBLIC	?_End@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_End
PUBLIC	?_Erase_bucket@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@I@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Erase_bucket
PUBLIC	?_Hashval@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIABH@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hashval
PUBLIC	?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Min_load_factor_buckets
PUBLIC	?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Desired_grow_bucket_count
PUBLIC	?_Check_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Check_size
PUBLIC	?_Forced_rehash@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXI@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Forced_rehash
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAMXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Max_bucket_size
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABMXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Max_bucket_size
PUBLIC	?_Getal@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Getal
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::max_size
PUBLIC	??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@IABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
PUBLIC	??1?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::~vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
PUBLIC	?assign@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::assign
PUBLIC	?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Reallocate_exactly
PUBLIC	?_Clear_and_reserve_geometric@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Clear_and_reserve_geometric
PUBLIC	?reserve@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::reserve
PUBLIC	?size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::size
PUBLIC	?max_size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::max_size
PUBLIC	?capacity@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::capacity
PUBLIC	??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@I@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::operator[]
PUBLIC	?_Ufill@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@PAV32@IABV32@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Ufill
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@0@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEII@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Buy_nonzero
PUBLIC	?_Change_array@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@II@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Change_array
PUBLIC	?_Tidy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Xlength
PUBLIC	?_Orphan_all@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Orphan_all
PUBLIC	?_Getal@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Getal
PUBLIC	?_Getal@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Getal
PUBLIC	?_Get_data@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Get_data
PUBLIC	?_Get_data@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Get_data
PUBLIC	?_Myfirst@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myfirst
PUBLIC	?_Myfirst@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myfirst
PUBLIC	?_Mylast@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Mylast
PUBLIC	?_Mylast@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Mylast
PUBLIC	?_Myend@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myend
PUBLIC	?_Myend@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_second
PUBLIC	??1?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::~_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >
PUBLIC	??0?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@XZ ; std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >
PUBLIC	??0?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@ABV01@@Z ; std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >
PUBLIC	??1?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@XZ ; std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >::~unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::pop_back
PUBLIC	?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ ; std::vector<int,std::allocator<int> >::empty
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?_Has_unused_capacity@?$vector@HV?$allocator@H@std@@@std@@ABE_NXZ ; std::vector<int,std::allocator<int> >::_Has_unused_capacity
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	?_Umove@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ; std::vector<int,std::allocator<int> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range
PUBLIC	?_Orphan_all@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Orphan_all
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Get_data@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::_Get_data
PUBLIC	?_Get_data@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::_Get_data
PUBLIC	?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ; std::vector<int,std::allocator<int> >::_Myfirst
PUBLIC	?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ; std::vector<int,std::allocator<int> >::_Myfirst
PUBLIC	?_Mylast@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ; std::vector<int,std::allocator<int> >::_Mylast
PUBLIC	?_Mylast@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ; std::vector<int,std::allocator<int> >::_Mylast
PUBLIC	?_Myend@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ; std::vector<int,std::allocator<int> >::_Myend
PUBLIC	?_Myend@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ; std::vector<int,std::allocator<int> >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	??$ref@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YA?AV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@@Z ; std::ref<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >
PUBLIC	??B?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@QBEAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@XZ ; std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >::operator std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &
PUBLIC	??$ref@H@std@@YA?AV?$reference_wrapper@H@0@AAH@Z ; std::ref<int>
PUBLIC	??B?$reference_wrapper@H@std@@QBEAAHXZ		; std::reference_wrapper<int>::operator int &
PUBLIC	??$generateRandom@H@@YAXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z ; generateRandom<int>
PUBLIC	??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@X@thread@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z ; std::thread::thread<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,void>
PUBLIC	??$ref@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA?AV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::ref<std::vector<int,std::allocator<int> > >
PUBLIC	??B?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEAAV?$vector@HV?$allocator@H@std@@@1@XZ ; std::reference_wrapper<std::vector<int,std::allocator<int> > >::operator std::vector<int,std::allocator<int> > &
PUBLIC	??$insert@H@@YAXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@Z ; insert<int>
PUBLIC	??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@X@thread@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::thread::thread<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,void>
PUBLIC	??$InsertionSort@H@@YAXAAV?$vector@HV?$allocator@H@std@@@std@@@Z ; InsertionSort<int>
PUBLIC	??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@X@thread@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::thread::thread<void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,void>
PUBLIC	??$erase@H@@YAXAAV?$vector@HV?$allocator@H@std@@@std@@@Z ; erase<int>
PUBLIC	??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> >,std::chrono::duration<__int64,std::ratio<1,10000000> > >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,10000000>,void>
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?decimal_point@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::decimal_point
PUBLIC	?thousands_sep@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::thousands_sep
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z	; std::numpunct<char>::numpunct<char>
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z	; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBEABHXZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator!=
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Free_non_head<std::allocator<std::_List_node<int,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Freenode0<std::allocator<std::_List_node<int,void *> > >
PUBLIC	??$?0H@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> ><int>
PUBLIC	??$?0AAU?$hash@H@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@H@1@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@H@1@$$QAU21@AAU?$equal_to@H@1@$$QAM@Z ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1><std::hash<int> &,std::_One_then_variadic_args_t,std::equal_to<int> &,float>
PUBLIC	??$_Hash_representation@H@std@@YAIABH@Z		; std::_Hash_representation<int>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
PUBLIC	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
PUBLIC	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Destroy_range@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
PUBLIC	??$?0ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1><std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > const &>
PUBLIC	??$_Construct_n_copies_of_ty@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Construct_n_copies_of_ty<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1><std::allocator<int> const &>
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<int> > >
PUBLIC	??$addressof@PAU?$_List_node@HPAX@std@@@std@@YAPAPAU?$_List_node@HPAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<int,void *> *>
PUBLIC	??$construct@PAU?$_List_node@HPAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@AAPAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<std::_List_node<int,void *> *,std::_List_node<int,void *> * &>
PUBLIC	??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Get_size_of_n@$0M@@std@@YAII@Z		; std::_Get_size_of_n<12>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter
PUBLIC	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
PUBLIC	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??$move@AAH@std@@YA$$QAHAAH@Z			; std::move<int &>
PUBLIC	??$?0AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@$0A@@?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@QAE@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@@Z ; std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > ><std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,0>
PUBLIC	??$?0AAH$0A@@?$reference_wrapper@H@std@@QAE@AAH@Z ; std::reference_wrapper<int>::reference_wrapper<int><int &,0>
PUBLIC	??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
PUBLIC	?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
PUBLIC	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
PUBLIC	?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
PUBLIC	?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
PUBLIC	??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
PUBLIC	?min@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::min
PUBLIC	?max@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::max
PUBLIC	??0?$uniform_int@H@std@@QAE@HH@Z		; std::uniform_int<int>::uniform_int<int>
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAII@Z		; std::uniform_int<int>::_Adjust
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ; std::uniform_int<int>::_Adjust
PUBLIC	??0param_type@?$uniform_int@H@std@@QAE@HH@Z	; std::uniform_int<int>::param_type::param_type
PUBLIC	?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z	; std::uniform_int<int>::param_type::_Init
PUBLIC	??0?$uniform_int_distribution@H@std@@QAE@HH@Z	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
PUBLIC	??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@QBEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ; std::uniform_int<int>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEABHXZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE?AV01@H@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
PUBLIC	?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::_Unwrapped
PUBLIC	??$insert@$0A@$0A@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::insert<0,0>
PUBLIC	??$forward@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YAA6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZA6AX0HH@Z@Z ; std::forward<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>
PUBLIC	??$forward@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV10@@Z ; std::forward<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > >
PUBLIC	??$forward@V?$reference_wrapper@H@std@@@std@@YA$$QAV?$reference_wrapper@H@0@AAV10@@Z ; std::forward<std::reference_wrapper<int> >
PUBLIC	??$make_unique@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@2@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V52@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@0@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@H@0@3@Z ; std::make_unique<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>
PUBLIC	??R?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@QBEXPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z ; std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >::operator()
PUBLIC	?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@XZ ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::get_deleter
PUBLIC	?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::_Myptr
PUBLIC	?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEABQAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAEAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QBEABQAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Get_second
PUBLIC	??1?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::~unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >
PUBLIC	??D?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEAAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::operator*
PUBLIC	?get@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::get
PUBLIC	?release@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::release
PUBLIC	??$_Invoke@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@$0A@$00$01$02@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,0,1,2,3>
PUBLIC	??$?0AAV?$vector@HV?$allocator@H@std@@@std@@$0A@@?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@AAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::reference_wrapper<std::vector<int,std::allocator<int> > >::reference_wrapper<std::vector<int,std::allocator<int> > ><std::vector<int,std::allocator<int> > &,0>
PUBLIC	??$forward@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YAA6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZA6AX01@Z@Z ; std::forward<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>
PUBLIC	??$forward@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV10@@Z ; std::forward<std::reference_wrapper<std::vector<int,std::allocator<int> > > >
PUBLIC	??$make_unique@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@2@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@0@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::make_unique<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
PUBLIC	??R?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QBEXPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ; std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >::operator()
PUBLIC	?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get_deleter
PUBLIC	?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr
PUBLIC	?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEABQAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QBEABQAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second
PUBLIC	??1?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::~unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >
PUBLIC	??D?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEAAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::operator*
PUBLIC	?get@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get
PUBLIC	?release@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::release
PUBLIC	??$_Invoke@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00$01@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,0,1,2>
PUBLIC	??$forward@A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YAA6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZA6AX0@Z@Z ; std::forward<void (__cdecl&)(std::vector<int,std::allocator<int> > &)>
PUBLIC	??$make_unique@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A6AXAAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@0@A6AXAAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::make_unique<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
PUBLIC	??R?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QBEXPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ; std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >::operator()
PUBLIC	?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get_deleter
PUBLIC	?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr
PUBLIC	?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEABQAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QBEABQAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second
PUBLIC	??1?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::~unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >
PUBLIC	??D?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEAAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::operator*
PUBLIC	?get@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get
PUBLIC	?release@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::release
PUBLIC	??$_Invoke@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,0,1>
PUBLIC	??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ; std::_List_node<int,void *>::_Freenode<std::allocator<std::_List_node<int,void *> > >
PUBLIC	??$destroy@PAU?$_List_node@HPAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::destroy<std::_List_node<int,void *> *>
PUBLIC	??$forward@AAU?$hash@H@std@@@std@@YAAAU?$hash@H@0@AAU10@@Z ; std::forward<std::hash<int> &>
PUBLIC	??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_One_then_variadic_args_t>
PUBLIC	??$forward@AAU?$equal_to@H@std@@@std@@YAAAU?$equal_to@H@0@AAU10@@Z ; std::forward<std::equal_to<int> &>
PUBLIC	??$forward@M@std@@YA$$QAMAAM@Z			; std::forward<float>
PUBLIC	??$?0AAU?$equal_to@H@std@@M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@H@1@$$QAM@Z ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Compressed_pair<std::equal_to<int>,float,1><std::equal_to<int> &,float>
PUBLIC	??$_Fnv1a_append_value@H@std@@YAIIABH@Z		; std::_Fnv1a_append_value<int>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@YAABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > const &>
PUBLIC	??1?$_Tidy_guard@V?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > > >::~_Tidy_guard<std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > > >
PUBLIC	??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
PUBLIC	??$?0H@?$allocator@U?$_List_node@HPAX@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_List_node<int,void *> >::allocator<std::_List_node<int,void *> ><int>
PUBLIC	??$forward@AAPAU?$_List_node@HPAX@std@@@std@@YAAAPAU?$_List_node@HPAX@0@AAPAU10@@Z ; std::forward<std::_List_node<int,void *> * &>
PUBLIC	??$_Unfancy@H@std@@YAPAHPAH@Z			; std::_Unfancy<int>
PUBLIC	??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>
PUBLIC	??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEAAHABH@Z ; std::vector<int,std::allocator<int> >::emplace_back<int const &>
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEAAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>
PUBLIC	??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
PUBLIC	??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
PUBLIC	??$_Uninitialized_fill_n@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@IV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@IABV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,unsigned int,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_iterator<std::_List_val<std::_List_simple_types<int> > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@H@std@@@0@ABV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<int> > const >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@H@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<int> > >
PUBLIC	??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ; std::numpunct<char>::_Getvals<char>
PUBLIC	??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>
PUBLIC	??$forward@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YAAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV10@@Z ; std::forward<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &>
PUBLIC	??$addressof@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YAPAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV10@@Z ; std::addressof<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
PUBLIC	??$addressof@H@std@@YAPAHAAH@Z			; std::addressof<int>
PUBLIC	??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@ABEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@HH@Z ; std::uniform_int<int>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??$_Insert@ABHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHU_Not_a_node_tag@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert<int const &,std::_Not_a_node_tag>
PUBLIC	??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@$0A@@?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> ><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>
PUBLIC	??$?0U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > ><std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,0>
PUBLIC	??$get@$0A@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z ; std::get<0,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
PUBLIC	??$move@AAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YA$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAP6AX0HH@Z@Z ; std::move<void (__cdecl*&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>
PUBLIC	??$get@$00P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z ; std::get<1,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
PUBLIC	??$move@AAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV10@@Z ; std::move<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > &>
PUBLIC	??$get@$01P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@H@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z ; std::get<2,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
PUBLIC	??$move@AAV?$reference_wrapper@H@std@@@std@@YA$$QAV?$reference_wrapper@H@0@AAV10@@Z ; std::move<std::reference_wrapper<int> &>
PUBLIC	??$get@$02P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@H@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z ; std::get<3,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
PUBLIC	??$forward@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YA$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAP6AX0HH@Z@Z ; std::forward<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>
PUBLIC	??$_Call@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@_Invoker_functor@std@@SAX$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z ; std::_Invoker_functor::_Call<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
PUBLIC	??$invoke@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAX$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@H@0@3@Z ; std::invoke<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
PUBLIC	??$forward@AAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z ; std::forward<std::vector<int,std::allocator<int> > &>
PUBLIC	??$addressof@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z ; std::addressof<std::vector<int,std::allocator<int> > >
PUBLIC	??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > ><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
PUBLIC	??$?0U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,0>
PUBLIC	??$get@$0A@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z ; std::get<0,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >
PUBLIC	??$move@AAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YA$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX01@Z@Z ; std::move<void (__cdecl*&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>
PUBLIC	??$get@$00P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z ; std::get<1,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >
PUBLIC	??$get@$01P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z ; std::get<2,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >
PUBLIC	??$move@AAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV10@@Z ; std::move<std::reference_wrapper<std::vector<int,std::allocator<int> > > &>
PUBLIC	??$forward@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YA$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX01@Z@Z ; std::forward<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>
PUBLIC	??$_Call@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@_Invoker_functor@std@@SAX$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Invoker_functor::_Call<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >
PUBLIC	??$invoke@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAX$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::invoke<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >
PUBLIC	??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > ><void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
PUBLIC	??$?0U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,0>
PUBLIC	??$get@$0A@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z ; std::get<0,void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >
PUBLIC	??$move@AAP6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YA$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX0@Z@Z ; std::move<void (__cdecl*&)(std::vector<int,std::allocator<int> > &)>
PUBLIC	??$get@$00P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z ; std::get<1,void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >
PUBLIC	??$forward@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YA$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX0@Z@Z ; std::forward<void (__cdecl*)(std::vector<int,std::allocator<int> > &)>
PUBLIC	??$_Call@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@_Invoker_functor@std@@SAX$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Invoker_functor::_Call<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >
PUBLIC	??$invoke@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAX$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::invoke<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >
PUBLIC	??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAH@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::destroy<int>
PUBLIC	??$_Fill_memset_is_safe@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV20@@Z ; std::_Fill_memset_is_safe<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Unfancy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z ; std::_Unfancy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@IV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@IABV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,unsigned int,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
PUBLIC	??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
PUBLIC	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??0?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAE@AAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??R?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEII@Z ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::operator()
PUBLIC	?_Get_all_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_all_bits
PUBLIC	?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
PUBLIC	??$move@ABH@std@@YA$$QBHABH@Z			; std::move<int const &>
PUBLIC	??$move@AAU_Not_a_node_tag@std@@@std@@YA$$QAU_Not_a_node_tag@0@AAU10@@Z ; std::move<std::_Not_a_node_tag &>
PUBLIC	??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int const ,std::_Not_a_node_tag>
PUBLIC	??$?0U_Exact_args_t@std@@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V41@$0A@@?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@QAE@U_Exact_args_t@1@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@4@Z ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> ><std::_Exact_args_t,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>
PUBLIC	??$?0PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > ><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *>
PUBLIC	??$?0U_Exact_args_t@std@@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
PUBLIC	??$?0PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *>
PUBLIC	??$?0U_Exact_args_t@std@@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
PUBLIC	??$?0PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *>
PUBLIC	??0?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
PUBLIC	??1?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::~_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Release
PUBLIC	??$_Emplace_back@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Emplace_back<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> const &>
PUBLIC	??$_Get_unwrapped@H@std@@YAPAHQAH@Z		; std::_Get_unwrapped<int>
PUBLIC	??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z	; std::_Idl_distance<int *,int *>
PUBLIC	??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z	; std::_Get_unwrapped_n<int,int,0>
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z		; std::_Seek_wrapped<int>
PUBLIC	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,bool><std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,bool,0>
PUBLIC	??$forward@$$CBH@std@@YA$$QBHABH@Z		; std::forward<int const >
PUBLIC	??$_Buy_if_not_node@$$CBH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QBHU_Not_a_node_tag@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Buy_if_not_node<int const >
PUBLIC	??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@$0A@@?$tuple@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@V?$reference_wrapper@H@2@V32@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@2@Z ; std::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> ><std::_Exact_args_t,std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>
PUBLIC	??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@?$_Tuple_val@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z@Z ; std::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>
PUBLIC	??$?0AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > * &>
PUBLIC	??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
PUBLIC	??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@Z@?$_Tuple_val@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z@Z ; std::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>
PUBLIC	??$?0AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>
PUBLIC	??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$$V$0A@@?$tuple@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::tuple<std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
PUBLIC	??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@?$_Tuple_val@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z@Z ; std::_Tuple_val<void (__cdecl*)(std::vector<int,std::allocator<int> > &)>::_Tuple_val<void (__cdecl*)(std::vector<int,std::allocator<int> > &)><void (__cdecl&)(std::vector<int,std::allocator<int> > &)>
PUBLIC	??$?0AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1><std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>
PUBLIC	??$forward@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> const &>
PUBLIC	??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV31@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> const &>
PUBLIC	??$?0V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> ><std::allocator<std::_List_node<int,void *> > >
PUBLIC	??$_Get_unwrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@$0A@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,0>
PUBLIC	??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int const &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z ; std::_Fill_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Uninitialized_move@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@PAV12@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@0PAV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z ; std::_Uninitialized_move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
PUBLIC	??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > > >
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$?0U_Exact_args_t@std@@V?$reference_wrapper@H@1@V21@$0A@@?$tuple@V?$reference_wrapper@H@std@@V12@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@H@1@1@Z ; std::tuple<std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<std::reference_wrapper<int>,std::reference_wrapper<int> ><std::_Exact_args_t,std::reference_wrapper<int>,std::reference_wrapper<int>,0>
PUBLIC	??$?0V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@?$_Tuple_val@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@QAE@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@@Z ; std::_Tuple_val<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > >::_Tuple_val<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > ><std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > >
PUBLIC	??$forward@AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@YAAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@AAPAV10@@Z ; std::forward<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > * &>
PUBLIC	??$forward@AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@YAAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@AAPAV10@@Z ; std::forward<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$?0V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@?$_Tuple_val@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Tuple_val<std::reference_wrapper<std::vector<int,std::allocator<int> > > >::_Tuple_val<std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::reference_wrapper<std::vector<int,std::allocator<int> > > >
PUBLIC	??$forward@AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@YAAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@AAPAV10@@Z ; std::forward<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>
PUBLIC	??$?0U?$_List_node@HPAX@std@@@?$allocator@H@std@@QAE@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z ; std::allocator<int>::allocator<int><std::_List_node<int,void *> >
PUBLIC	??$?0U?$_List_node@HPAX@std@@@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> ><std::_List_node<int,void *> >
PUBLIC	??$insert@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@0@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::insert<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Buy_if_not_node@ABH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABHV21@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Buy_if_not_node<int const &>
PUBLIC	??$_Fill_unchecked1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Get_unwrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@@Z ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Idl_distance@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@PAV12@@std@@YAHABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Idl_distance<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *>
PUBLIC	??$_Get_unwrapped_n@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@H$0A@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@H@Z ; std::_Get_unwrapped_n<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,int,0>
PUBLIC	??$move@AAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z ; std::move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> &>
PUBLIC	??$_Emplace_back@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEX$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Emplace_back<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Seek_wrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@@Z ; std::_Seek_wrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Insert@ABH@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABH@Z ; std::list<int,std::allocator<int> >::_Insert<int const &>
PUBLIC	??$?0U_Exact_args_t@std@@V?$reference_wrapper@H@1@$$V$0A@@?$tuple@V?$reference_wrapper@H@std@@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@H@1@@Z ; std::tuple<std::reference_wrapper<int> >::tuple<std::reference_wrapper<int> ><std::_Exact_args_t,std::reference_wrapper<int>,0>
PUBLIC	??$?0V?$reference_wrapper@H@std@@@?$_Tuple_val@V?$reference_wrapper@H@std@@@std@@QAE@$$QAV?$reference_wrapper@H@1@@Z ; std::_Tuple_val<std::reference_wrapper<int> >::_Tuple_val<std::reference_wrapper<int> ><std::reference_wrapper<int> >
PUBLIC	??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$_Get_unwrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@$0A@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,0>
PUBLIC	??$emplace@ABH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::emplace<int const &>
PUBLIC	??$forward@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEPAU?$_List_node@HPAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >
PUBLIC	??$construct@HABH@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<int,int const &>
PUBLIC	??$construct@PAU?$_List_node@HPAX@std@@ABQAU12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@ABQAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<std::_List_node<int,void *> *,std::_List_node<int,void *> * const &>
PUBLIC	??$exchange@PAU?$_List_node@HPAX@std@@$$T@std@@YAPAU?$_List_node@HPAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_List_node<int,void *> *,std::nullptr_t>
PUBLIC	??$emplace_front@ABH@?$list@HV?$allocator@H@std@@@std@@QAEAAHABH@Z ; std::list<int,std::allocator<int> >::emplace_front<int const &>
PUBLIC	??$_Insert@AAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@AAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert<int &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$forward@ABQAU?$_List_node@HPAX@std@@@std@@YAABQAU?$_List_node@HPAX@0@ABQAU10@@Z ; std::forward<std::_List_node<int,void *> * const &>
PUBLIC	??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$_Buy_if_not_node@H@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QAHV21@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Buy_if_not_node<int>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic@			; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error@	; `string'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@	; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@	; `string'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_03LLKPDBLO@ms?6@				; `string'
PUBLIC	??_C@_0BI@FPMLGDN@Multiple?5Threads?5Time?3?5@	; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_C@_02BBAHNLBA@?$CFp@				; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu@				; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld@				; `string'
PUBLIC	??_C@_02BDDLJJBK@lu@				; `string'
PUBLIC	??_C@_02EAOCLKAK@ld@				; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	??_C@_02MDKMJEGG@eE@				; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP@				; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
PUBLIC	?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ ; `string'
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@4202a05f20000000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	_frexp:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	_terminate:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	_strcspn:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xruntime_error@std@@YAXPBD@Z:PROC		; std::_Xruntime_error
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z:PROC ; std::_Execute_once
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	_localeconv:PROC
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	?_Random_device@std@@YAIXZ:PROC			; std::_Random_device
EXTRN	__Xtime_get_ticks:PROC
EXTRN	__beginthreadex:PROC
EXTRN	__Thrd_join:PROC
EXTRN	__Thrd_id:PROC
EXTRN	__Cnd_do_broadcast_at_thread_exit:PROC
EXTRN	?_Throw_Cpp_error@std@@YAXH@Z:PROC		; std::_Throw_Cpp_error
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftoui3:PROC
EXTRN	_ceil:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cout
EXTRN	?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cerr
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA
_BSS	SEGMENT
?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA DD 01H DUP (?) ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
_BSS	ENDS
;	COMDAT ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A
_BSS	SEGMENT
?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A DQ 01H DUP (?) ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$r	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$r	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$r	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$r	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$r	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$r	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$r	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
CONST	SEGMENT
??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@ DB 'invalid hash bucket '
	DB	'count', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@ DB 'vector<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp@ DB '%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_C@_0BI@FPMLGDN@Multiple?5Threads?5Time?3?5@
CONST	SEGMENT
??_C@_0BI@FPMLGDN@Multiple?5Threads?5Time?3?5@ DB 'Multiple Threads Time:'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03LLKPDBLO@ms?6@
CONST	SEGMENT
??_C@_03LLKPDBLO@ms?6@ DB 'ms', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@ DB 'ios_base::failbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error@ DB 'iostream stream error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream@ DB 'iostream', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$2
__catchsym$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$0
__unwindtable$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
	DD	02H
	DD	FLAT:__tryblocktable$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$2
__catchsym$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$0
__unwindtable$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
	DD	02H
	DD	FLAT:__tryblocktable$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z$2
__catchsym$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z$0
__unwindtable$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z
	DD	02H
	DD	FLAT:__tryblocktable$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$0
__unwindtable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$0
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$2
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$0
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$2
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z$0
__unwindtable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z$2
__ehfuncinfo$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$_Buy_if_not_node@H@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QAHV21@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
__Plist$ = 16						; size = 4
??$_Buy_if_not_node@H@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QAHV21@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Buy_if_not_node<int>, COMDAT
; _this$ = ecx

; 870  :         return _Plist;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Plist$[esp-4]
	mov	DWORD PTR [eax], ecx

; 871  :     }

	ret	12					; 0000000cH
??$_Buy_if_not_node@H@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QAHV21@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Buy_if_not_node<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 4
__Bucket$ = -28						; size = 4
__Where$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T3 = 8							; size = 4
___$ReturnUdt$ = 8					; size = 4
$T4 = 12						; size = 4
__Plist$ = 12						; size = 4
__Val$ = 12						; size = 4
__Pnode$ = 16						; size = 4
??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 1040 :     _Pairib _Insert_unverified(_Valty&& _Val, _Nodety _Pnode) { // try to insert existing node with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	DWORD PTR _this$[ebp], ebx

; 1041 :         size_type _Bucket;
; 1042 :         _Unchecked_iterator _Where;
; 1043 : 
; 1044 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1045 :         _Bucket = _Hashval(_Traits::_Kfn(_Val));

	push	DWORD PTR __Val$[ebp]
	call	?_Hashval@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIABH@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hashval
	mov	edi, eax
	mov	DWORD PTR __Bucket$[ebp], edi

; 1046 :         _Where  = _End(_Bucket);

	push	edi
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, ebx
	call	?_End@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_End
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], esi
$LL2@Insert_unv:

; 1114 :         return _Vec_lo(_Bucket);

	mov	eax, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1047 :         while (_Where != _Begin(_Bucket)) {

	je	SHORT $LN3@Insert_unv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 61   :         _Ptr = _Ptr->_Prev;

	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR __Where$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 88   :         return _Left == _Right;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1050 :             if (!_Traitsobj(_Traits::_Kfn(_Val), _Traits::_Kfn(*--_Where))) { // not still too high in bucket list

	jne	SHORT $LL2@Insert_unv

; 1051 :                 if (_Multi
; 1052 :                     || (!_Traits::_Standard
; 1053 :                            && _Traitsobj(_Traits::_Kfn(*_Where),
; 1054 :                                   _Traits::_Kfn(_Val)))) { // found insertion point, back up to it
; 1055 :                     ++_Where;
; 1056 :                     break;
; 1057 :                 }
; 1058 : 
; 1059 :                 // discard new list element and return existing
; 1060 :                 _Destroy_if_node(_Pnode);

	push	DWORD PTR __Pnode$[ebp]
	mov	ecx, ebx
	call	?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Destroy_if_node
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1095 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_unv:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 870  :         return _Plist;

	mov	edi, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Plist$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR [edi]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1073 :         if (_Where != ++_Next) { // move element into place

	je	SHORT $LN7@Insert_unv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1467 :         _First._Ptr->_Prev->_Next = _Last._Ptr;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx], eax

; 1468 :         _Last._Ptr->_Prev->_Next  = _Where._Ptr;

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], esi

; 1469 :         _Where._Ptr->_Prev->_Next = _First._Ptr;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx], edi

; 1470 : 
; 1471 :         _Nodeptr _Pnode    = _Where._Ptr->_Prev;

	mov	edx, DWORD PTR [esi+4]

; 1472 :         _Where._Ptr->_Prev = _Last._Ptr->_Prev;

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 1473 :         _Last._Ptr->_Prev  = _First._Ptr->_Prev;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ecx

; 1474 :         _First._Ptr->_Prev = _Pnode;

	mov	DWORD PTR [edi+4], edx
$LN7@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	ecx, DWORD PTR __Bucket$[ebp]
	mov	edx, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR [ebx+4]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	DWORD PTR [edx+ecx*8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1078 :         if (_Vec_lo(_Bucket) == _Unchecked_end()) { // make bucket non-empty

	jne	SHORT $LN8@Insert_unv

; 1079 :             _Vec_lo(_Bucket) = _Plist;

	mov	DWORD PTR [edx+ecx*8], edi

; 1080 :             _Vec_hi(_Bucket) = _Plist;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+ecx*8+4], edi

; 1081 :         } else if (_Vec_lo(_Bucket) == _Where) {

	jmp	SHORT $LN12@Insert_unv
$LN8@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	DWORD PTR [edx+ecx*8], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1081 :         } else if (_Vec_lo(_Bucket) == _Where) {

	jne	SHORT $LN10@Insert_unv

; 1082 :             _Vec_lo(_Bucket) = _Plist; // move beginning back one element

	mov	DWORD PTR [edx+ecx*8], edi

; 1083 :         } else if (++_Vec_hi(_Bucket) != _Plist) { // move end up one element

	jmp	SHORT $LN12@Insert_unv
$LN10@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR [edx+ecx*8+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+ecx*8+4], eax

; 72   :         return _Ptr == _Right._Ptr;

	cmp	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1083 :         } else if (++_Vec_hi(_Bucket) != _Plist) { // move end up one element

	je	SHORT $LN12@Insert_unv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax+ecx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 61   :         _Ptr = _Ptr->_Prev;

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
$LN12@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1087 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1088 :         _Check_size();

	mov	ecx, ebx
	call	?_Check_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Check_size
	mov	DWORD PTR __$EHRec$[ebp+12], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1095 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$0:

; 1061 :                 return _Pairib(_Make_iter(_Where), false);
; 1062 :             }
; 1063 : #pragma warning(pop)
; 1064 :         }
; 1065 :         _CATCH_ALL
; 1066 :         _Destroy_if_node(_Pnode);

	push	DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Destroy_if_node

; 1067 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
__catch$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$2:

; 1089 :         _CATCH_ALL
; 1090 :         erase(_Make_iter(_Plist));

	push	DWORD PTR __Plist$[ebp]
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Make_iter
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V32@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::erase

; 1091 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN229@Insert_unv:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@ABQAU?$_List_node@HPAX@std@@@std@@YAABQAU?$_List_node@HPAX@0@ABQAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAU?$_List_node@HPAX@std@@@std@@YAABQAU?$_List_node@HPAX@0@ABQAU10@@Z PROC ; std::forward<std::_List_node<int,void *> * const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@ABQAU?$_List_node@HPAX@std@@@std@@YAABQAU?$_List_node@HPAX@0@ABQAU10@@Z ENDP ; std::forward<std::_List_node<int,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$_Insert@AAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@AAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
__Pnode$ = 16						; size = 4
??$_Insert@AAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@AAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert<int &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 1031 :         // try to insert existing node with value _Val
; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	DWORD PTR __Pnode$[esp-4]
	push	DWORD PTR __Val$[esp]
	push	DWORD PTR ___$ReturnUdt$[esp+4]
	call	??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >

; 1033 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1034 :         _Stl_internal_check_container_invariants();
; 1035 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1036 :         return _Result;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1037 :     }

	ret	12					; 0000000cH
??$_Insert@AAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@AAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert<int &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??$emplace_front@ABH@?$list@HV?$allocator@H@std@@@std@@QAEAAHABH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_front@ABH@?$list@HV?$allocator@H@std@@@std@@QAEAAHABH@Z PROC ; std::list<int,std::allocator<int> >::emplace_front<int const &>, COMDAT
; _this$ = ecx

; 721  :     decltype(auto) emplace_front(_Valty&&... _Val) { // insert element at beginning

	push	ebx
	mov	ebx, ecx
	push	esi

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+4], 357913941		; 15555555H

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	esi, DWORD PTR [ebx]

; 722  :         _Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);

	mov	esi, DWORD PTR [esi]

; 750  :         if (max_size() == _Mysize()) {

	je	SHORT $LN161@emplace_fr
	push	edi

; 752  :         }
; 753  : 
; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;
; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	edi, DWORD PTR [esi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR _<_Val_0>$[esp+12]

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	inc	DWORD PTR [ebx+4]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [esi+4], eax

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	mov	DWORD PTR [edi], eax

; 836  :         return iterator(_Myhead()->_Next, _STD addressof(_Get_data()));

	mov	eax, DWORD PTR [ebx]

; 723  : 
; 724  : #if _HAS_CXX17
; 725  :         return front();

	pop	edi
	pop	esi

; 726  : #endif // _HAS_CXX17
; 727  :     }

	pop	ebx

; 161  :         return this->_Ptr->_Myval;

	mov	eax, DWORD PTR [eax]
	add	eax, 8

; 726  : #endif // _HAS_CXX17
; 727  :     }

	ret	4
$LN161@emplace_fr:

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN159@emplace_fr:
	int	3
??$emplace_front@ABH@?$list@HV?$allocator@H@std@@@std@@QAEAAHABH@Z ENDP ; std::list<int,std::allocator<int> >::emplace_front<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
;	COMDAT ??$exchange@PAU?$_List_node@HPAX@std@@$$T@std@@YAPAU?$_List_node@HPAX@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU?$_List_node@HPAX@std@@$$T@std@@YAPAU?$_List_node@HPAX@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_List_node<int,void *> *,std::nullptr_t>, COMDAT

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	edx, DWORD PTR __Val$[esp-4]

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	ecx, DWORD PTR __New_val$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx

; 528  :     return _Old_val;
; 529  : }

	ret	0
??$exchange@PAU?$_List_node@HPAX@std@@$$T@std@@YAPAU?$_List_node@HPAX@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_List_node<int,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@HPAX@std@@ABQAU12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@ABQAU31@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@HPAX@std@@ABQAU12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@ABQAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<std::_List_node<int,void *> *,std::_List_node<int,void *> * const &>, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@PAU?$_List_node@HPAX@std@@ABQAU12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@ABQAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<std::_List_node<int,void *> *,std::_List_node<int,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAHABH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAHABH@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<int,int const &>, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAHABH@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >, COMDAT
; _this$ = ecx

; 1198 :         if (_Ptr) {

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN19@Alloc_cons

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN19@Alloc_cons:

; 1199 :             _Al.deallocate(_Ptr, 1);
; 1200 :         }
; 1201 :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1192 :     void _Allocate() { // disengage *this, then allocate a new memory block

	push	esi
	mov	esi, ecx

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH

; 1193 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	DWORD PTR [esi+4], 0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1194 :         _Ptr = _Al.allocate(1);

	mov	DWORD PTR [esi+4], eax
	pop	esi

; 1195 :     }

	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEPAU?$_List_node@HPAX@2@XZ
_TEXT	SEGMENT
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEPAU?$_List_node@HPAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Release, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR [ecx+4]

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1190 :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAEPAU?$_List_node@HPAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >, COMDAT
; _this$ = ecx

; 1186 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@HPAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >::_Alloc_construct_ptr<std::allocator<std::_List_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QAV31@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z PROC ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z ENDP ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$emplace@ABH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Val_0>$ = 12						; size = 4
??$emplace@ABH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::emplace<int const &>, COMDAT
; _this$ = ecx

; 428  :     _Pairib emplace(_Valty&&... _Val) { // try to insert value_type(_Val...)

	push	ebx
	mov	ebx, ecx
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+8], 357913941		; 15555555H

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	esi, DWORD PTR [ebx+4]

; 722  :         _Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);

	mov	esi, DWORD PTR [esi]

; 750  :         if (max_size() == _Mysize()) {

	je	SHORT $LN216@emplace
	push	edi

; 752  :         }
; 753  : 
; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;
; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	edi, DWORD PTR [esi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR _<_Val_0>$[esp+12]

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	inc	DWORD PTR [ebx+8]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [esi+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	mov	DWORD PTR [edi], eax

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	eax, DWORD PTR [eax]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 161  :         return this->_Ptr->_Myval;

	add	eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	eax
	push	esi
	call	??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >

; 429  :         _List.emplace_front(_STD forward<_Valty>(_Val)...);
; 430  :         return _Insert(_List.front(), _Unchecked_begin());

	pop	edi
	mov	eax, esi
	pop	esi

; 431  :     }

	pop	ebx
	ret	8
$LN216@emplace:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN214@emplace:
	int	3
??$emplace@ABH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::emplace<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Get_unwrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@$0A@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@$0A@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,0>, COMDAT

; 264  :     return _It;

	mov	eax, DWORD PTR __It$[esp-4]

; 265  : }

	ret	0
??$_Get_unwrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@$0A@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 217  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 218  :         _Verify_range(_First, _Last);
; 219  :     } else {
; 220  :         (void) _First; // TRANSITION, VSO#486357
; 221  :         (void) _Last; // TRANSITION, VSO#486357
; 222  :     }
; 223  : }

	ret	0
??$_Adl_verify_range@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::_Adl_verify_range<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0V?$reference_wrapper@H@std@@@?$_Tuple_val@V?$reference_wrapper@H@std@@@std@@QAE@$$QAV?$reference_wrapper@H@1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0V?$reference_wrapper@H@std@@@?$_Tuple_val@V?$reference_wrapper@H@std@@@std@@QAE@$$QAV?$reference_wrapper@H@1@@Z PROC ; std::_Tuple_val<std::reference_wrapper<int> >::_Tuple_val<std::reference_wrapper<int> ><std::reference_wrapper<int> >, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR __Arg$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 161  :     }

	mov	eax, ecx
	ret	4
??$?0V?$reference_wrapper@H@std@@@?$_Tuple_val@V?$reference_wrapper@H@std@@@std@@QAE@$$QAV?$reference_wrapper@H@1@@Z ENDP ; std::_Tuple_val<std::reference_wrapper<int> >::_Tuple_val<std::reference_wrapper<int> ><std::reference_wrapper<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@V?$reference_wrapper@H@1@$$V$0A@@?$tuple@V?$reference_wrapper@H@std@@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@V?$reference_wrapper@H@1@$$V$0A@@?$tuple@V?$reference_wrapper@H@std@@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@H@1@@Z PROC ; std::tuple<std::reference_wrapper<int> >::tuple<std::reference_wrapper<int> ><std::_Exact_args_t,std::reference_wrapper<int>,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 251  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element
; 252  :     }

	mov	eax, ecx
	ret	8
??$?0U_Exact_args_t@std@@V?$reference_wrapper@H@1@$$V$0A@@?$tuple@V?$reference_wrapper@H@std@@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@H@1@@Z ENDP ; std::tuple<std::reference_wrapper<int> >::tuple<std::reference_wrapper<int> ><std::_Exact_args_t,std::reference_wrapper<int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??$_Insert@ABH@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABH@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Insert@ABH@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABH@Z PROC ; std::list<int,std::allocator<int> >::_Insert<int const &>, COMDAT
; _this$ = ecx

; 749  :     void _Insert(_Unchecked_const_iterator _Where, _Valty&&... _Val) { // insert element at _Where

	push	ebx
	mov	ebx, ecx

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+4], 357913941		; 15555555H
	je	SHORT $LN114@Insert

; 752  :         }
; 753  : 
; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;

	push	esi
	push	edi
	mov	edi, DWORD PTR __Where$[esp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	esi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR _<_Val_0>$[esp+12]

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	inc	DWORD PTR [ebx+4]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [edi+4], eax

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	pop	edi
	mov	DWORD PTR [esi], eax
	pop	esi
	pop	ebx

; 764  :         (void) _Newnode._Release();
; 765  :     }

	ret	8
$LN114@Insert:

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN112@Insert:
	int	3
??$_Insert@ABH@?$list@HV?$allocator@H@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABH@Z ENDP ; std::list<int,std::allocator<int> >::_Insert<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@@Z PROC ; std::_Seek_wrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 435  :     _It = _UIt;

	mov	eax, DWORD PTR __It$[esp-4]
	mov	ecx, DWORD PTR __UIt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 436  : }

	ret	0
??$_Seek_wrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAXAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@@Z ENDP ; std::_Seek_wrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Emplace_back@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEX$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEX$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Emplace_back<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edx, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 143  :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 144  :     }

	ret	4
??$_Emplace_back@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEX$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Emplace_back<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z PROC ; std::move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z ENDP ; std::move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Get_unwrapped_n@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@H$0A@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@H@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Get_unwrapped_n@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@H$0A@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@H@Z PROC ; std::_Get_unwrapped_n<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,int,0>, COMDAT

; 395  :     return _Src;

	mov	eax, DWORD PTR __Src$[esp-4]

; 396  : }

	ret	0
??$_Get_unwrapped_n@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@H$0A@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@H@Z ENDP ; std::_Get_unwrapped_n<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Idl_distance@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@PAV12@@std@@YAHABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Idl_distance@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@PAV12@@std@@YAHABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::_Idl_distance<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *>, COMDAT

; 487  :     if constexpr (_Is_random_iter_v<_Iter>) {
; 488  :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 489  :     } else {
; 490  :         (void) _First; // TRANSITION, VSO#486357
; 491  :         (void) _Last; // TRANSITION, VSO#486357
; 492  :         return _Distance_unknown{};
; 493  :     }
; 494  : }

	ret	0
??$_Idl_distance@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@PAV12@@std@@YAHABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::_Idl_distance<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Get_unwrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@@Z PROC ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 275  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[esp-4]

; 276  : }

	ret	0
??$_Get_unwrapped@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@@Z ENDP ; std::_Get_unwrapped<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Fill_unchecked1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_unchecked1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Fill_unchecked1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 2257 :     false_type) { // copy _Val through [_First, _Last), no special optimization

	push	ebx

; 2258 :     for (; _First != _Last; ++_First) {

	mov	ebx, DWORD PTR __First$[esp]
	xor	ecx, ecx
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+4]
	xor	edx, edx
	sub	ebp, ebx
	add	ebp, 3
	shr	ebp, 2
	cmp	ebx, DWORD PTR __Last$[esp+4]
	cmova	ebp, ecx
	test	ebp, ebp
	je	SHORT $LN3@Fill_unche
	mov	ecx, DWORD PTR __Val$[esp+4]
	push	esi
	cmp	ebp, 4
	jb	SHORT $LN9@Fill_unche

; 2259 :         *_First = _Val;

	mov	eax, DWORD PTR [ecx]
	lea	esi, DWORD PTR [ebx-4]
	lea	esi, DWORD PTR [esi+ebp*4]
	cmp	ebx, ecx
	ja	SHORT $LN10@Fill_unche

; 2258 :     for (; _First != _Last; ++_First) {

	cmp	esi, ecx
	jae	SHORT $LN9@Fill_unche
$LN10@Fill_unche:
	mov	esi, ebp
	and	esi, -4					; fffffffcH
$LL4@Fill_unche:
	add	edx, 4
	cmp	edx, esi
	jne	SHORT $LL4@Fill_unche
	shl	esi, 2
	push	edi
	mov	ecx, esi
	mov	edi, ebx
	shr	ecx, 2
	add	ebx, esi
	rep stosd
	mov	ecx, DWORD PTR __Val$[esp+12]
	pop	edi
$LN9@Fill_unche:
	pop	esi
	cmp	edx, ebp
	je	SHORT $LN3@Fill_unche
$LL8@Fill_unche:

; 2259 :         *_First = _Val;

	mov	eax, DWORD PTR [ecx]
	lea	ebx, DWORD PTR [ebx+4]
	inc	edx
	mov	DWORD PTR [ebx-4], eax
	cmp	edx, ebp
	jne	SHORT $LL8@Fill_unche
$LN3@Fill_unche:
	pop	ebp

; 2260 :     }
; 2261 : }

	pop	ebx
	ret	0
??$_Fill_unchecked1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Fill_unchecked1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$_Buy_if_not_node@ABH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABHV21@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
__Plist$ = 16						; size = 4
??$_Buy_if_not_node@ABH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABHV21@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Buy_if_not_node<int const &>, COMDAT
; _this$ = ecx

; 870  :         return _Plist;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Plist$[esp-4]
	mov	DWORD PTR [eax], ecx

; 871  :     }

	ret	12					; 0000000cH
??$_Buy_if_not_node@ABH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABHV21@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Buy_if_not_node<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$insert@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@0@Z
_TEXT	SEGMENT
__Rightnode$1$ = -12					; size = 4
$T2 = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$insert@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@0@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::insert<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 699  :     void insert(_Iter _First, _Iter _Last) { // insert [_First, _Last) at front, then put in place

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 700  :         _Adl_verify_range(_First, _Last);
; 701  :         auto _UFirst      = _Get_unwrapped(_First);

	mov	esi, DWORD PTR __First$[esp+16]
	mov	ebx, ecx
	push	edi

; 702  :         const auto _ULast = _Get_unwrapped(_Last);

	mov	edi, DWORD PTR __Last$[esp+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN3@insert
	push	ebp
$LL4@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+8], 357913941		; 15555555H
	je	SHORT $LN234@insert

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Rightnode$1$[esp+32], eax

; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	ebp, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [esi+8]

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Rightnode$1$[esp+28]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	inc	DWORD PTR [ebx+8]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	mov	DWORD PTR [ebp], eax

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	eax, DWORD PTR [eax]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 161  :         return this->_Ptr->_Myval;

	add	eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	eax
	lea	eax, DWORD PTR $T2[esp+36]
	push	eax
	call	??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	esi, DWORD PTR [esi]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL4@insert
	pop	ebp
$LN3@insert:
	pop	edi

; 706  :     }

	pop	esi
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN234@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN242@insert:
$LN240@insert:
	int	3
??$insert@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@0@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::insert<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0U?$_List_node@HPAX@std@@@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$_List_node@HPAX@std@@@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> ><std::_List_node<int,void *> >, COMDAT
; _this$ = ecx

; 921  :     }

	mov	eax, ecx
	ret	4
??$?0U?$_List_node@HPAX@std@@@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> ><std::_List_node<int,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0U?$_List_node@HPAX@std@@@?$allocator@H@std@@QAE@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$_List_node@HPAX@std@@@?$allocator@H@std@@QAE@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z PROC ; std::allocator<int>::allocator<int><std::_List_node<int,void *> >, COMDAT
; _this$ = ecx

; 921  :     }

	mov	eax, ecx
	ret	4
??$?0U?$_List_node@HPAX@std@@@?$allocator@H@std@@QAE@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z ENDP ; std::allocator<int>::allocator<int><std::_List_node<int,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@YAAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@YAAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@AAPAV10@@Z PROC ; std::forward<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@YAAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@AAPAV10@@Z ENDP ; std::forward<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@?$_Tuple_val@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@?$_Tuple_val@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Tuple_val<std::reference_wrapper<std::vector<int,std::allocator<int> > > >::_Tuple_val<std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::reference_wrapper<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR __Arg$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 161  :     }

	mov	eax, ecx
	ret	4
??$?0V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@?$_Tuple_val@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Tuple_val<std::reference_wrapper<std::vector<int,std::allocator<int> > > >::_Tuple_val<std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::reference_wrapper<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT
; _this$ = ecx

; 224  :     }

	mov	eax, ecx
	ret	4
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@YAAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@YAAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@AAPAV10@@Z PROC ; std::forward<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@YAAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@AAPAV10@@Z ENDP ; std::forward<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@YAAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@YAAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@AAPAV10@@Z PROC ; std::forward<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > * &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@YAAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@AAPAV10@@Z ENDP ; std::forward<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@?$_Tuple_val@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@QAE@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@?$_Tuple_val@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@QAE@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@@Z PROC ; std::_Tuple_val<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > >::_Tuple_val<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > ><std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR __Arg$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 161  :     }

	mov	eax, ecx
	ret	4
??$?0V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@?$_Tuple_val@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@QAE@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@@Z ENDP ; std::_Tuple_val<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > >::_Tuple_val<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > ><std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@V?$reference_wrapper@H@1@V21@$0A@@?$tuple@V?$reference_wrapper@H@std@@V12@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@H@1@1@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
??$?0U_Exact_args_t@std@@V?$reference_wrapper@H@1@V21@$0A@@?$tuple@V?$reference_wrapper@H@std@@V12@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@H@1@1@Z PROC ; std::tuple<std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<std::reference_wrapper<int>,std::reference_wrapper<int> ><std::_Exact_args_t,std::reference_wrapper<int>,std::reference_wrapper<int>,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 251  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element
; 252  :     }

	mov	eax, ecx
	ret	12					; 0000000cH
??$?0U_Exact_args_t@std@@V?$reference_wrapper@H@1@V21@$0A@@?$tuple@V?$reference_wrapper@H@std@@V12@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@H@1@1@Z ENDP ; std::tuple<std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<std::reference_wrapper<int>,std::reference_wrapper<int> ><std::_Exact_args_t,std::reference_wrapper<int>,std::reference_wrapper<int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > > >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@PAV12@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@0PAV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@PAV12@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@0PAV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >, COMDAT

; 131  :     _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 222  :                    // note: only called internally from elsewhere in the STL
; 223  :     auto _UFirst      = _Get_unwrapped(_First);

	xor	edx, edx
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	xor	ebx, ebx
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	esi, edi
	add	esi, 3
	shr	esi, 2
	cmp	edi, DWORD PTR __Last$[esp+8]
	cmova	esi, ebx

; 232  :         for (; _UFirst != _ULast; ++_UFirst) {

	test	esi, esi
	je	SHORT $LN3@Uninitiali

; 131  :     _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	sub	edi, eax
$LL4@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [edi+eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 232  :         for (; _UFirst != _ULast; ++_UFirst) {

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 143  :         ++_Last;

	add	eax, 4

; 232  :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	edi

; 233  :             _Backout._Emplace_back(_STD move(*_UFirst));
; 234  :         }
; 235  : 
; 236  :         _UDest = _Backout._Release();
; 237  :     }
; 238  : 
; 239  :     _Seek_wrapped(_Dest, _UDest);
; 240  :     return _Dest;
; 241  : }

	pop	esi
	pop	ebx
	ret	0
??$_Uninitialized_move@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@PAV12@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@0PAV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z PROC ; std::_Fill_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 2271 :     _FwdIt _First, _FwdIt _Last, const _Ty& _Val) { // copy _Val through [_First, _Last), choose optimization

	push	ebx

; 2272 :     _Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	mov	ebx, DWORD PTR __First$[esp]
	xor	ecx, ecx
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+4]
	xor	edx, edx
	sub	ebp, ebx
	add	ebp, 3
	shr	ebp, 2
	cmp	ebx, DWORD PTR __Last$[esp+4]
	cmova	ebp, ecx

; 2258 :     for (; _First != _Last; ++_First) {

	test	ebp, ebp
	je	SHORT $LN7@Fill_unche
	mov	ecx, DWORD PTR __Val$[esp+4]
	push	esi
	cmp	ebp, 4
	jb	SHORT $LN13@Fill_unche

; 2259 :         *_First = _Val;

	mov	eax, DWORD PTR [ecx]

; 2272 :     _Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	lea	esi, DWORD PTR [ebx-4]
	lea	esi, DWORD PTR [esi+ebp*4]
	cmp	ebx, ecx
	ja	SHORT $LN14@Fill_unche
	cmp	esi, ecx
	jae	SHORT $LN13@Fill_unche
$LN14@Fill_unche:
	mov	esi, ebp
	and	esi, -4					; fffffffcH
$LL8@Fill_unche:

; 2258 :     for (; _First != _Last; ++_First) {

	add	edx, 4
	cmp	edx, esi
	jne	SHORT $LL8@Fill_unche

; 2272 :     _Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	shl	esi, 2
	push	edi
	mov	ecx, esi
	mov	edi, ebx
	shr	ecx, 2
	add	ebx, esi
	rep stosd
	mov	ecx, DWORD PTR __Val$[esp+12]
	pop	edi
$LN13@Fill_unche:

; 2258 :     for (; _First != _Last; ++_First) {

	pop	esi
	cmp	edx, ebp
	je	SHORT $LN7@Fill_unche
$LL12@Fill_unche:

; 2259 :         *_First = _Val;

	mov	eax, DWORD PTR [ecx]

; 2272 :     _Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	lea	ebx, DWORD PTR [ebx+4]

; 2258 :     for (; _First != _Last; ++_First) {

	inc	edx

; 2259 :         *_First = _Val;

	mov	DWORD PTR [ebx-4], eax
	cmp	edx, ebp
	jne	SHORT $LL12@Fill_unche
$LN7@Fill_unche:
	pop	ebp

; 2273 : }

	pop	ebx
	ret	0
??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z ENDP ; std::_Fill_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 4
__Bucket$ = -28						; size = 4
__Where$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T3 = 8							; size = 4
___$ReturnUdt$ = 8					; size = 4
$T4 = 12						; size = 4
__Plist$ = 12						; size = 4
__Val$ = 12						; size = 4
__Pnode$ = 16						; size = 4
??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int const &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 1040 :     _Pairib _Insert_unverified(_Valty&& _Val, _Nodety _Pnode) { // try to insert existing node with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	DWORD PTR _this$[ebp], ebx

; 1041 :         size_type _Bucket;
; 1042 :         _Unchecked_iterator _Where;
; 1043 : 
; 1044 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1045 :         _Bucket = _Hashval(_Traits::_Kfn(_Val));

	push	DWORD PTR __Val$[ebp]
	call	?_Hashval@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIABH@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hashval
	mov	edi, eax
	mov	DWORD PTR __Bucket$[ebp], edi

; 1046 :         _Where  = _End(_Bucket);

	push	edi
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, ebx
	call	?_End@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_End
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], esi
$LL2@Insert_unv:

; 1114 :         return _Vec_lo(_Bucket);

	mov	eax, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1047 :         while (_Where != _Begin(_Bucket)) {

	je	SHORT $LN3@Insert_unv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 61   :         _Ptr = _Ptr->_Prev;

	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR __Where$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 88   :         return _Left == _Right;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1050 :             if (!_Traitsobj(_Traits::_Kfn(_Val), _Traits::_Kfn(*--_Where))) { // not still too high in bucket list

	jne	SHORT $LL2@Insert_unv

; 1051 :                 if (_Multi
; 1052 :                     || (!_Traits::_Standard
; 1053 :                            && _Traitsobj(_Traits::_Kfn(*_Where),
; 1054 :                                   _Traits::_Kfn(_Val)))) { // found insertion point, back up to it
; 1055 :                     ++_Where;
; 1056 :                     break;
; 1057 :                 }
; 1058 : 
; 1059 :                 // discard new list element and return existing
; 1060 :                 _Destroy_if_node(_Pnode);

	push	DWORD PTR __Pnode$[ebp]
	mov	ecx, ebx
	call	?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Destroy_if_node
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1095 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_unv:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 870  :         return _Plist;

	mov	edi, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Plist$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR [edi]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1073 :         if (_Where != ++_Next) { // move element into place

	je	SHORT $LN7@Insert_unv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1467 :         _First._Ptr->_Prev->_Next = _Last._Ptr;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx], eax

; 1468 :         _Last._Ptr->_Prev->_Next  = _Where._Ptr;

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], esi

; 1469 :         _Where._Ptr->_Prev->_Next = _First._Ptr;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx], edi

; 1470 : 
; 1471 :         _Nodeptr _Pnode    = _Where._Ptr->_Prev;

	mov	edx, DWORD PTR [esi+4]

; 1472 :         _Where._Ptr->_Prev = _Last._Ptr->_Prev;

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 1473 :         _Last._Ptr->_Prev  = _First._Ptr->_Prev;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ecx

; 1474 :         _First._Ptr->_Prev = _Pnode;

	mov	DWORD PTR [edi+4], edx
$LN7@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	ecx, DWORD PTR __Bucket$[ebp]
	mov	edx, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR [ebx+4]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	DWORD PTR [edx+ecx*8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1078 :         if (_Vec_lo(_Bucket) == _Unchecked_end()) { // make bucket non-empty

	jne	SHORT $LN8@Insert_unv

; 1079 :             _Vec_lo(_Bucket) = _Plist;

	mov	DWORD PTR [edx+ecx*8], edi

; 1080 :             _Vec_hi(_Bucket) = _Plist;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+ecx*8+4], edi

; 1081 :         } else if (_Vec_lo(_Bucket) == _Where) {

	jmp	SHORT $LN12@Insert_unv
$LN8@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	DWORD PTR [edx+ecx*8], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1081 :         } else if (_Vec_lo(_Bucket) == _Where) {

	jne	SHORT $LN10@Insert_unv

; 1082 :             _Vec_lo(_Bucket) = _Plist; // move beginning back one element

	mov	DWORD PTR [edx+ecx*8], edi

; 1083 :         } else if (++_Vec_hi(_Bucket) != _Plist) { // move end up one element

	jmp	SHORT $LN12@Insert_unv
$LN10@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR [edx+ecx*8+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+ecx*8+4], eax

; 72   :         return _Ptr == _Right._Ptr;

	cmp	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1083 :         } else if (++_Vec_hi(_Bucket) != _Plist) { // move end up one element

	je	SHORT $LN12@Insert_unv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	eax, DWORD PTR [ebx+12]
	lea	ecx, DWORD PTR [eax+ecx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 61   :         _Ptr = _Ptr->_Prev;

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
$LN12@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1087 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1088 :         _Check_size();

	mov	ecx, ebx
	call	?_Check_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Check_size
	mov	DWORD PTR __$EHRec$[ebp+12], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1095 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$0:

; 1061 :                 return _Pairib(_Make_iter(_Where), false);
; 1062 :             }
; 1063 : #pragma warning(pop)
; 1064 :         }
; 1065 :         _CATCH_ALL
; 1066 :         _Destroy_if_node(_Pnode);

	push	DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Destroy_if_node

; 1067 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
__catch$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z$2:

; 1089 :         _CATCH_ALL
; 1090 :         erase(_Make_iter(_Plist));

	push	DWORD PTR __Plist$[ebp]
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Make_iter
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V32@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::erase

; 1091 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN418@Insert_unv:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int const &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Get_unwrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@$0A@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
??$_Get_unwrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@$0A@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,0>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR __It$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 259  : }

	ret	0
??$_Get_unwrapped@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@$0A@@std@@YA?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$?0V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z
_TEXT	SEGMENT
$T2 = -8						; size = 8
$T3 = -8						; size = 4
__Rightnode$1$ = 8					; size = 4
$T4 = 8							; size = 1
__Right$ = 8						; size = 4
__Al$ = 12						; size = 4
??$?0V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> ><std::allocator<std::_List_node<int,void *> > >, COMDAT
; _this$ = ecx

; 254  :           _Maxidx(_Right._Maxidx) { // construct hash table by copying _Right

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Right$[esp+20]
	mov	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 252  :         : _Traitsobj(_Right._Traitsobj), _List(static_cast<allocator_type>(_Al)),

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 521  :         return _List._Unchecked_end();

	mov	DWORD PTR $T3[esp+24], eax

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	lea	ecx, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1528 :         _My_data._Myhead = _Newhead;

	mov	DWORD PTR [ebx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	lea	eax, DWORD PTR $T4[esp+20]
	push	eax
	lea	eax, DWORD PTR $T3[esp+28]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [edi+16]
	sub	eax, DWORD PTR [edi+12]
	sar	eax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	push	eax
	call	??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@IABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [ebx+24], eax

; 254  :           _Maxidx(_Right._Maxidx) { // construct hash table by copying _Right

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [ebx+28], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 856  :         return _Unchecked_const_iterator(_Myhead()->_Next, nullptr);

	mov	edi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 701  :         auto _UFirst      = _Get_unwrapped(_First);

	mov	esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN136@allocator
$LL137@allocator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+8], 357913941		; 15555555H
	je	SHORT $LN367@allocator

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Rightnode$1$[esp+24], eax

; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	ebp, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [esi+8]

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Rightnode$1$[esp+20]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	inc	DWORD PTR [ebx+8]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	mov	DWORD PTR [ebp], eax

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	eax, DWORD PTR [eax]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 161  :         return this->_Ptr->_Myval;

	add	eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	eax
	lea	eax, DWORD PTR $T2[esp+32]
	push	eax
	call	??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	esi, DWORD PTR [esi]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL137@allocator
$LN136@allocator:
	pop	edi

; 260  :     }

	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	add	esp, 8
	ret	8
$LN367@allocator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN373@allocator:
	int	3
??$?0V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@ABV?$allocator@U?$_List_node@HPAX@std@@@1@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> ><std::allocator<std::_List_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV31@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> const &>, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z PROC ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z ENDP ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1><std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>, COMDAT
; _this$ = ecx

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR _<_Val2_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1528 :     }

	mov	eax, ecx
	ret	8
??$?0AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1><std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@?$_Tuple_val@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@?$_Tuple_val@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z@Z PROC ; std::_Tuple_val<void (__cdecl*)(std::vector<int,std::allocator<int> > &)>::_Tuple_val<void (__cdecl*)(std::vector<int,std::allocator<int> > &)><void (__cdecl&)(std::vector<int,std::allocator<int> > &)>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR __Arg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 161  :     }

	mov	eax, ecx
	ret	4
??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@?$_Tuple_val@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z@Z ENDP ; std::_Tuple_val<void (__cdecl*)(std::vector<int,std::allocator<int> > &)>::_Tuple_val<void (__cdecl*)(std::vector<int,std::allocator<int> > &)><void (__cdecl&)(std::vector<int,std::allocator<int> > &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$$V$0A@@?$tuple@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$$V$0A@@?$tuple@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::tuple<std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 251  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element
; 252  :     }

	mov	eax, ecx
	ret	8
??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$$V$0A@@?$tuple@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::tuple<std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>, COMDAT
; _this$ = ecx

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR _<_Val2_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1528 :     }

	mov	eax, ecx
	ret	8
??$?0AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@Z@?$_Tuple_val@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@Z@?$_Tuple_val@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z@Z PROC ; std::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR __Arg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 161  :     }

	mov	eax, ecx
	ret	4
??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@Z@?$_Tuple_val@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z@Z ENDP ; std::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 251  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element
; 252  :     }

	mov	eax, ecx
	ret	12					; 0000000cH
??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > * &>, COMDAT
; _this$ = ecx

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR _<_Val2_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1528 :     }

	mov	eax, ecx
	ret	8
??$?0AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@?$_Tuple_val@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@?$_Tuple_val@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z@Z PROC ; std::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR __Arg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 161  :     }

	mov	eax, ecx
	ret	4
??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@?$_Tuple_val@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z@Z ENDP ; std::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>::_Tuple_val<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@$0A@@?$tuple@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@V?$reference_wrapper@H@2@V32@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@2@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
_<_Rest_arg_1>$ = 20					; size = 4
??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@$0A@@?$tuple@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@V?$reference_wrapper@H@2@V32@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@2@Z PROC ; std::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> ><std::_Exact_args_t,std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR _<_Rest_arg_1>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], eax

; 251  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element
; 252  :     }

	mov	eax, ecx
	ret	16					; 00000010H
??$?0U_Exact_args_t@std@@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@$0A@@?$tuple@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@V?$reference_wrapper@H@2@V32@@std@@QAE@U_Exact_args_t@1@$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@2@Z ENDP ; std::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> ><std::_Exact_args_t,std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$_Buy_if_not_node@$$CBH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QBHU_Not_a_node_tag@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Buy_if_not_node@$$CBH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QBHU_Not_a_node_tag@1@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Buy_if_not_node<int const >, COMDAT
; _this$ = ecx

; 874  :     _Unchecked_iterator _Buy_if_not_node(_Valty&& _Val, _Not_a_node_tag) { // node doesn't exist, make it

	push	ebx
	mov	ebx, ecx
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+8], 357913941		; 15555555H

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	esi, DWORD PTR [ebx+4]

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	esi, DWORD PTR [esi]

; 750  :         if (max_size() == _Mysize()) {

	je	SHORT $LN152@Buy_if_not
	push	edi

; 752  :         }
; 753  : 
; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;
; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	edi, DWORD PTR [esi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR __Val$[esp+12]

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	inc	DWORD PTR [ebx+8]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [esi+4], eax

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	mov	DWORD PTR [edi], eax

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 876  :         return _Unchecked_begin();

	pop	edi
	pop	esi

; 877  :     }

	pop	ebx

; 513  :         return _List._Unchecked_begin();

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 877  :     }

	ret	12					; 0000000cH
$LN152@Buy_if_not:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN150@Buy_if_not:
	int	3
??$_Buy_if_not_node@$$CBH@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@$$QBHU_Not_a_node_tag@1@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Buy_if_not_node<int const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@$$CBH@std@@YA$$QBHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@$$CBH@std@@YA$$QBHABH@Z PROC			; std::forward<int const >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@$$CBH@std@@YA$$QBHABH@Z ENDP			; std::forward<int const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
;	COMDAT ??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,bool><std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,bool,0>, COMDAT
; _this$ = ecx

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al
	mov	eax, ecx
	ret	8
??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,bool><std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z PROC		; std::_Seek_wrapped<int>, COMDAT

; 435  :     _It = _UIt;

	mov	eax, DWORD PTR __It$[esp-4]
	mov	ecx, DWORD PTR __UIt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 436  : }

	ret	0
??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z ENDP		; std::_Seek_wrapped<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 1762 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 1763 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 1764 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __First$[esp-4]
	push	esi

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 1767 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 1768 : }

	ret	0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z PROC	; std::_Get_unwrapped_n<int,int,0>, COMDAT

; 395  :     return _Src;

	mov	eax, DWORD PTR __Src$[esp-4]

; 396  : }

	ret	0
??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z ENDP	; std::_Get_unwrapped_n<int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z PROC		; std::_Idl_distance<int *,int *>, COMDAT

; 487  :     if constexpr (_Is_random_iter_v<_Iter>) {
; 488  :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 489  :     } else {
; 490  :         (void) _First; // TRANSITION, VSO#486357
; 491  :         (void) _Last; // TRANSITION, VSO#486357
; 492  :         return _Distance_unknown{};
; 493  :     }
; 494  : }

	ret	0
??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z ENDP		; std::_Idl_distance<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Get_unwrapped@H@std@@YAPAHQAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@H@std@@YAPAHQAH@Z PROC		; std::_Get_unwrapped<int>, COMDAT

; 275  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[esp-4]

; 276  : }

	ret	0
??$_Get_unwrapped@H@std@@YAPAHQAH@Z ENDP		; std::_Get_unwrapped<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Emplace_back@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Emplace_back<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edx, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Vals_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 143  :         ++_Last;

	add	DWORD PTR [ecx+4], 4

; 144  :     }

	ret	4
??$_Emplace_back@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Emplace_back<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Release, COMDAT
; _this$ = ecx

; 147  :         _First = _Last;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax

; 148  :         return _Last;
; 149  :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::~_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >, COMDAT
; _this$ = ecx

; 137  :         _Destroy_range(_First, _Last, _Al);
; 138  :     }

	ret	0
??1?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::~_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >, COMDAT
; _this$ = ecx

; 131  :     _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	ret	8
??0?$_Uninitialized_backout_al@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Uninitialized_backout_al<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$?0PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1816 :     }

	mov	eax, ecx
	ret	4
??$?0PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
??$?0U_Exact_args_t@std@@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 251  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element
; 252  :     }

	mov	eax, ecx
	ret	12					; 0000000cH
??$?0U_Exact_args_t@std@@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$?0PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1816 :     }

	mov	eax, ecx
	ret	4
??$?0PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
_<_Rest_arg_1>$ = 20					; size = 4
??$?0U_Exact_args_t@std@@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR _<_Rest_arg_1>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 251  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element
; 252  :     }

	mov	eax, ecx
	ret	16					; 00000010H
??$?0U_Exact_args_t@std@@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@U_Exact_args_t@1@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > ><std::_Exact_args_t,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$?0PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > ><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1816 :     }

	mov	eax, ecx
	ret	4
??$?0PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > ><std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V41@$0A@@?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@QAE@U_Exact_args_t@1@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@4@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
_<_Rest_arg_1>$ = 20					; size = 4
_<_Rest_arg_2>$ = 24					; size = 4
??$?0U_Exact_args_t@std@@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V41@$0A@@?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@QAE@U_Exact_args_t@1@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@4@Z PROC ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> ><std::_Exact_args_t,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR _<_Rest_arg_2>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<_Rest_arg_1>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 251  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element
; 252  :     }

	mov	eax, ecx
	ret	20					; 00000014H
??$?0U_Exact_args_t@std@@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V41@$0A@@?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@QAE@U_Exact_args_t@1@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@4@Z ENDP ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> ><std::_Exact_args_t,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z
_TEXT	SEGMENT
__Plist$ = -40						; size = 4
$T3 = -40						; size = 4
__Plist$1$ = -36					; size = 4
__Bucket$ = -32						; size = 4
__Where$ = -28						; size = 4
tv1149 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T4 = 8							; size = 4
___$ReturnUdt$ = 8					; size = 4
tv1157 = 12						; size = 4
$T5 = 12						; size = 4
__Val$ = 12						; size = 4
__Pnode$ = 16						; size = 1
??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int const ,std::_Not_a_node_tag>, COMDAT
; _this$ = ecx

; 1040 :     _Pairib _Insert_unverified(_Valty&& _Val, _Nodety _Pnode) { // try to insert existing node with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	DWORD PTR _this$[ebp], ebx

; 1041 :         size_type _Bucket;
; 1042 :         _Unchecked_iterator _Where;
; 1043 : 
; 1044 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1045 :         _Bucket = _Hashval(_Traits::_Kfn(_Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, ebx
	call	?_Hashval@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIABH@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hashval
	mov	edi, eax
	mov	DWORD PTR __Bucket$[ebp], edi

; 1046 :         _Where  = _End(_Bucket);

	push	edi
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, ebx
	call	?_End@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_End
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], esi
$LL2@Insert_unv:

; 1114 :         return _Vec_lo(_Bucket);

	mov	eax, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax+edi*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1047 :         while (_Where != _Begin(_Bucket)) {

	je	SHORT $LN3@Insert_unv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 61   :         _Ptr = _Ptr->_Prev;

	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR __Where$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 88   :         return _Left == _Right;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1050 :             if (!_Traitsobj(_Traits::_Kfn(_Val), _Traits::_Kfn(*--_Where))) { // not still too high in bucket list

	jne	SHORT $LL2@Insert_unv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1095 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_unv:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	edi, DWORD PTR [ebx+4]

; 974  :         _Insert(_Unchecked_begin(), _Val);

	mov	edi, DWORD PTR [edi]

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+8], 357913941		; 15555555H
	je	$LN381@Insert_unv

; 752  :         }
; 753  : 
; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;
; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	ebx, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	mov	edx, DWORD PTR _this$[ebp]
	inc	DWORD PTR [edx+8]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [edi+4], eax

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	mov	DWORD PTR [ebx], eax

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	ecx, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 513  :         return _List._Unchecked_begin();

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Plist$1$[ebp], edi
	mov	DWORD PTR __Plist$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR [edi]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1073 :         if (_Where != ++_Next) { // move element into place

	je	SHORT $LN7@Insert_unv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1467 :         _First._Ptr->_Prev->_Next = _Last._Ptr;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx], eax

; 1468 :         _Last._Ptr->_Prev->_Next  = _Where._Ptr;

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], esi

; 1469 :         _Where._Ptr->_Prev->_Next = _First._Ptr;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx], edi

; 1470 : 
; 1471 :         _Nodeptr _Pnode    = _Where._Ptr->_Prev;

	mov	edx, DWORD PTR [esi+4]

; 1472 :         _Where._Ptr->_Prev = _Last._Ptr->_Prev;

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 1473 :         _Last._Ptr->_Prev  = _First._Ptr->_Prev;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ecx

; 1474 :         _First._Ptr->_Prev = _Pnode;

	mov	DWORD PTR [edi+4], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
$LN7@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	eax, DWORD PTR __Bucket$[ebp]
	lea	ebx, DWORD PTR [eax*8]
	mov	DWORD PTR tv1149[ebp], ebx
	mov	ebx, DWORD PTR [edx+12]
	mov	DWORD PTR tv1157[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	lea	ebx, DWORD PTR [eax*8]
	mov	edx, DWORD PTR tv1157[ebp]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	edi, DWORD PTR tv1149[ebp]
	cmp	DWORD PTR [edi+edx], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1078 :         if (_Vec_lo(_Bucket) == _Unchecked_end()) { // make bucket non-empty

	mov	edi, DWORD PTR __Plist$1$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	jne	SHORT $LN8@Insert_unv

; 1079 :             _Vec_lo(_Bucket) = _Plist;

	mov	DWORD PTR [eax], edi

; 1080 :             _Vec_hi(_Bucket) = _Plist;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ebx+eax+4], edi

; 1081 :         } else if (_Vec_lo(_Bucket) == _Where) {

	jmp	SHORT $LN12@Insert_unv
$LN8@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	DWORD PTR [eax], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1081 :         } else if (_Vec_lo(_Bucket) == _Where) {

	jne	SHORT $LN10@Insert_unv

; 1082 :             _Vec_lo(_Bucket) = _Plist; // move beginning back one element

	mov	eax, DWORD PTR tv1157[ebp]
	mov	DWORD PTR [eax+ebx], edi

; 1083 :         } else if (++_Vec_hi(_Bucket) != _Plist) { // move end up one element

	jmp	SHORT $LN12@Insert_unv
$LN10@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	ecx, DWORD PTR tv1157[ebp]
	mov	eax, DWORD PTR [ecx+ebx+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+ebx+4], eax

; 72   :         return _Ptr == _Right._Ptr;

	cmp	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1083 :         } else if (++_Vec_hi(_Bucket) != _Plist) { // move end up one element

	je	SHORT $LN12@Insert_unv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	ecx, DWORD PTR tv1149[ebp]
	add	ecx, DWORD PTR [edx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 61   :         _Ptr = _Ptr->_Prev;

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
$LN12@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1087 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1088 :         _Check_size();

	mov	ecx, edx
	call	?_Check_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Check_size
	mov	DWORD PTR __$EHRec$[ebp+12], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edi
	mov	BYTE PTR [eax+4], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1095 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z$2:

; 1089 :         _CATCH_ALL
; 1090 :         erase(_Make_iter(_Plist));

	push	DWORD PTR __Plist$[ebp]
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Make_iter
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V32@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::erase
__catch$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z$0:

; 1095 :     }

	push	0
	push	0
	call	__CxxThrowException@8
$LN381@Insert_unv:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN379@Insert_unv:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int const ,std::_Not_a_node_tag>
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAU_Not_a_node_tag@std@@@std@@YA$$QAU_Not_a_node_tag@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU_Not_a_node_tag@std@@@std@@YA$$QAU_Not_a_node_tag@0@AAU10@@Z PROC ; std::move<std::_Not_a_node_tag &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAU_Not_a_node_tag@std@@@std@@YA$$QAU_Not_a_node_tag@0@AAU10@@Z ENDP ; std::move<std::_Not_a_node_tag &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@ABH@std@@YA$$QBHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@ABH@std@@YA$$QBHABH@Z PROC			; std::move<int const &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@ABH@std@@YA$$QBHABH@Z ENDP			; std::move<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ PROC ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits, COMDAT
; _this$ = ecx

; 3314 :     _Udiff _Get_bits() { // return a random value within [0, _Bmask]

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$1$[esp+16], ecx
	push	edi
	npad	7
$LL2@Get_bits:

; 3315 :         for (;;) { // repeat until random value is in range
; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	mov	edi, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1136 :         if (this->_Idx == _Nx) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 624				; 00000270H
	jne	SHORT $LN8@Get_bits

; 1178 :         for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { // fill in values

	lea	eax, DWORD PTR [edi+8]
	mov	esi, 624				; 00000270H
$LL15@Get_bits:

; 1179 :             _Ty _Tmp       = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + 1] & _LMSK);

	mov	edx, DWORD PTR [eax-4]
	lea	eax, DWORD PTR [eax+4]
	xor	edx, DWORD PTR [eax-4]
	and	edx, 2147483647				; 7fffffffH
	xor	edx, DWORD PTR [eax-8]

; 1180 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	ecx, edx
	and	cl, 1
	movzx	ecx, cl
	neg	ecx
	sbb	ecx, ecx
	shr	edx, 1
	and	ecx, -1727483681			; 9908b0dfH
	xor	ecx, DWORD PTR [eax+1580]
	xor	ecx, edx
	mov	DWORD PTR [eax+2488], ecx
	sub	esi, 1
	jne	SHORT $LL15@Get_bits

; 1138 :         } else if (2 * _Nx <= this->_Idx) {

	mov	eax, DWORD PTR [edi]
	jmp	$LN10@Get_bits
$LN8@Get_bits:
	cmp	eax, 1248				; 000004e0H
	jb	$LN10@Get_bits

; 1161 :         for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix) { // fill in lower region

	mov	eax, DWORD PTR [edi+2500]
	lea	ebx, DWORD PTR [edi+2500]
	mov	ebp, 227				; 000000e3H
	npad	1
$LL20@Get_bits:

; 1162 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR [ebx+4]
	xor	ecx, eax
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1163 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [ebx+1588]
	xor	eax, ecx
	mov	DWORD PTR [ebx-2496], eax
	lea	ebx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL20@Get_bits

; 1164 :         }
; 1165 : 
; 1166 :         for (; _Ix < _Nx - 1; ++_Ix) { // fill in upper region (avoids modulus operation)

	mov	eax, DWORD PTR [edi+3408]
	lea	ebx, DWORD PTR [edi+3408]
	mov	ebp, 396				; 0000018cH
	npad	6
$LL23@Get_bits:

; 1167 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, eax
	lea	edx, DWORD PTR [ebx+4]
	xor	ecx, DWORD PTR [edx]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1168 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [ebx-3404]
	xor	eax, ecx
	mov	DWORD PTR [ebx-2496], eax
	lea	ebx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL23@Get_bits

; 1169 :         }
; 1170 : 
; 1171 :         _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

	mov	ecx, DWORD PTR [edi+4992]
	xor	ecx, DWORD PTR [edi+4]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, DWORD PTR [edi+4992]

; 1172 :         this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [edi+1588]
	xor	eax, ecx
	mov	DWORD PTR [edi+2496], eax

; 1173 :         this->_Idx     = 0;

	xor	eax, eax
	mov	DWORD PTR [edi], 0
$LN10@Get_bits:

; 1142 :         _Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

	mov	edx, DWORD PTR [edi+eax*4+4]
	inc	eax
	mov	DWORD PTR [edi], eax

; 1143 :         _Res ^= (_Res >> _Ux) & _Dxval;

	mov	ecx, edx
	mov	eax, DWORD PTR [edi+4996]
	shr	ecx, 11					; 0000000bH
	and	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3318 :             if (_Val <= _Bmask) {

	mov	ecx, DWORD PTR _this$1$[esp+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1143 :         _Res ^= (_Res >> _Ux) & _Dxval;

	xor	edx, eax

; 1144 :         _Res ^= (_Res << _Sx) & _Bx;

	mov	eax, edx
	and	eax, -12953427				; ff3a58adH
	shl	eax, 7
	xor	edx, eax

; 1145 :         _Res ^= (_Res << _Tx) & _Cx;

	mov	eax, edx
	and	eax, -8308				; ffffdf8cH
	shl	eax, 15					; 0000000fH
	xor	edx, eax

; 1146 :         _Res ^= (_Res & _WMSK) >> _Lx;

	mov	eax, edx
	shr	eax, 18					; 00000012H
	xor	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3318 :             if (_Val <= _Bmask) {

	cmp	eax, DWORD PTR [ecx+8]
	ja	$LL2@Get_bits

; 3319 :                 return _Val;

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3320 :             }
; 3321 :         }
; 3322 :     }

	pop	ecx
	ret	0
?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ?_Get_all_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEIXZ
_TEXT	SEGMENT
?_Get_all_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEIXZ PROC ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_all_bits, COMDAT
; _this$ = ecx

; 3298 :     _Udiff _Get_all_bits() { // return a random value

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 3299 :         _Udiff _Ret = 0;

	xor	edi, edi

; 3300 : 
; 3301 :         for (size_t _Num = 0; _Num < CHAR_BIT * sizeof(_Udiff); _Num += _Bits) { // don't mask away any bits

	xor	ebx, ebx
	mov	eax, DWORD PTR [esi+4]
	npad	4
$LL4@Get_all_bi:

; 3302 :             _Ret <<= _Bits - 1; // avoid full shift

	lea	ecx, DWORD PTR [eax-1]
	shl	edi, cl

; 3303 :             _Ret <<= 1;

	add	edi, edi
$LL7@Get_all_bi:

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	mov	ecx, DWORD PTR [esi]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 3317 : 
; 3318 :             if (_Val <= _Bmask) {

	cmp	eax, DWORD PTR [esi+8]
	ja	SHORT $LL7@Get_all_bi

; 3300 : 
; 3301 :         for (size_t _Num = 0; _Num < CHAR_BIT * sizeof(_Udiff); _Num += _Bits) { // don't mask away any bits

	or	edi, eax
	mov	eax, DWORD PTR [esi+4]
	add	ebx, eax
	cmp	ebx, 32					; 00000020H
	jb	SHORT $LL4@Get_all_bi

; 3304 :             _Ret |= _Get_bits();
; 3305 :         }
; 3306 : 
; 3307 :         return _Ret;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3308 :     }

	ret	0
?_Get_all_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_all_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??R?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEII@Z
_TEXT	SEGMENT
__Index$ = 8						; size = 4
??R?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEII@Z PROC ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::operator(), COMDAT
; _this$ = ecx

; 3277 :     _Diff operator()(_Diff _Index) { // adapt _Urng closed range to [0, _Index)

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Index$[esp+4]
	push	esi
	push	edi
	mov	esi, ecx
	dec	ebp
	npad	5
$LL2@operator:

; 3278 :         for (;;) { // try a sample random value
; 3279 :             _Udiff _Ret  = 0; // random bits

	xor	edi, edi

; 3280 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

	xor	ebx, ebx

; 3281 : 
; 3282 :             while (_Mask < _Udiff(_Index - 1)) { // need more random bits

	test	ebp, ebp
	je	SHORT $LN6@operator
	mov	edx, DWORD PTR [esi+4]
	npad	5
$LL5@operator:

; 3283 :                 _Ret <<= _Bits - 1; // avoid full shift

	lea	ecx, DWORD PTR [edx-1]
	shl	edi, cl

; 3284 :                 _Ret <<= 1;

	add	edi, edi
$LL11@operator:

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	mov	ecx, DWORD PTR [esi]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
	mov	ecx, eax

; 3317 : 
; 3318 :             if (_Val <= _Bmask) {

	mov	eax, DWORD PTR [esi+8]
	cmp	ecx, eax
	ja	SHORT $LL11@operator

; 3285 :                 _Ret |= _Get_bits();

	mov	edx, DWORD PTR [esi+4]
	or	edi, ecx

; 3286 :                 _Mask <<= _Bits - 1; // avoid full shift

	lea	ecx, DWORD PTR [edx-1]
	shl	ebx, cl

; 3287 :                 _Mask <<= 1;

	add	ebx, ebx

; 3288 :                 _Mask |= _Bmask;

	or	ebx, eax
	cmp	ebx, ebp
	jb	SHORT $LL5@operator
$LN6@operator:

; 3289 :             }
; 3290 : 
; 3291 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3292 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

	xor	edx, edx
	mov	eax, ebx
	div	DWORD PTR __Index$[esp+12]
	mov	ecx, eax
	mov	ebx, edx
	xor	edx, edx
	mov	eax, edi
	div	DWORD PTR __Index$[esp+12]
	cmp	eax, ecx
	jb	SHORT $LN23@operator
	cmp	ebx, ebp
	jne	SHORT $LL2@operator
$LN23@operator:

; 3293 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, edi
	xor	edx, edx
	div	DWORD PTR __Index$[esp+12]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, edx
	pop	ebx

; 3294 :             }
; 3295 :         }
; 3296 :     }

	ret	4
??R?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEII@Z ENDP ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??0?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAE@AAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
_TEXT	SEGMENT
__Func$ = 8						; size = 4
??0?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAE@AAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z PROC ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT
; _this$ = ecx

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	eax, DWORD PTR __Func$[esp-4]
	mov	DWORD PTR [ecx], eax

; 3272 :         for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1) {
; 3273 :             --_Bits;
; 3274 :         }
; 3275 :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 32			; 00000020H
	mov	DWORD PTR [ecx+8], -1
	ret	4
??0?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAE@AAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ENDP ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT
; _this$ = ecx

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR _<_Val2_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1528 :     }

	mov	eax, ecx
	ret	8
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,int *,std::allocator<int> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 221  :     _Alloc& _Al) { // move [_First, _Last) to raw _Dest, using _Al

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 221  :     _Alloc& _Al) { // move [_First, _Last) to raw _Dest, using _Al

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, eax

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 1767 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 240  :     return _Dest;

	pop	edi
	pop	esi

; 241  : }

	ret	0
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@IV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@IABV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@IV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@IABV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,unsigned int,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >, COMDAT

; 280  :     _Uninitialized_backout_al<_NoThrowFwdIt, _Alloc> _Backout{_First, _Al};
; 281  :     for (; 0 < _Count; --_Count) {

	mov	edx, DWORD PTR __Count$[esp-4]

; 131  :     _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __First$[esp-4]

; 280  :     _Uninitialized_backout_al<_NoThrowFwdIt, _Alloc> _Backout{_First, _Al};
; 281  :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN3@Uninit_all
	push	esi
	mov	esi, DWORD PTR __Val$[esp]
$LL4@Uninit_all:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 143  :         ++_Last;

	add	eax, 4

; 280  :     _Uninitialized_backout_al<_NoThrowFwdIt, _Alloc> _Backout{_First, _Al};
; 281  :     for (; 0 < _Count; --_Count) {

	sub	edx, 1
	jne	SHORT $LL4@Uninit_all

; 282  :         _Backout._Emplace_back(_Val);
; 283  :     }
; 284  : 
; 285  :     return _Backout._Release();

	pop	esi
$LN3@Uninit_all:

; 286  : }

	ret	0
??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@IV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@IABV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,unsigned int,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$_Unfancy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z PROC ; std::_Unfancy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 295  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[esp-4]

; 296  : }

	ret	0
??$_Unfancy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z ENDP ; std::_Unfancy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Fill_memset_is_safe@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV20@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Fill_memset_is_safe@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV20@@Z PROC ; std::_Fill_memset_is_safe<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT

; 2252 :     return {};

	xor	al, al

; 2253 : }

	ret	0
??$_Fill_memset_is_safe@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@ABV20@@Z ENDP ; std::_Fill_memset_is_safe<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAH@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::destroy<int>, COMDAT

; 824  :         _Ptr->~_Uty();
; 825  :     }

	ret	0
??$destroy@H@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$invoke@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAX$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$invoke@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAX$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::invoke<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >, COMDAT

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR __Obj$[esp]
	mov	eax, DWORD PTR [eax]
	call	eax
	pop	ecx
	ret	0
??$invoke@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAX$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::invoke<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$_Call@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@_Invoker_functor@std@@SAX$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Call@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@_Invoker_functor@std@@SAX$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Invoker_functor::_Call<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >, COMDAT

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR __Obj$[esp]
	mov	eax, DWORD PTR [eax]
	call	eax
	pop	ecx
	ret	0
??$_Call@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@_Invoker_functor@std@@SAX$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Invoker_functor::_Call<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YA$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YA$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX0@Z@Z PROC ; std::forward<void (__cdecl*)(std::vector<int,std::allocator<int> > &)>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YA$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX0@Z@Z ENDP ; std::forward<void (__cdecl*)(std::vector<int,std::allocator<int> > &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$get@$00P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$00P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z PROC ; std::get<1,void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >, COMDAT

; 645  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 646  :     return ((_Ttype&) _Tuple)._Myfirst._Val;

	mov	eax, DWORD PTR __Tuple$[esp-4]

; 647  : }

	ret	0
??$get@$00P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z ENDP ; std::get<1,void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAP6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YA$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YA$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX0@Z@Z PROC ; std::move<void (__cdecl*&)(std::vector<int,std::allocator<int> > &)>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAP6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YA$$QAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX0@Z@Z ENDP ; std::move<void (__cdecl*&)(std::vector<int,std::allocator<int> > &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$get@$0A@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z PROC ; std::get<0,void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >, COMDAT

; 645  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 646  :     return ((_Ttype&) _Tuple)._Myfirst._Val;

	mov	eax, DWORD PTR __Tuple$[esp-4]
	add	eax, 4

; 647  : }

	ret	0
??$get@$0A@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAP6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZAAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z ENDP ; std::get<0,void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$?0U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,0>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1871 :     }

	mov	eax, ecx
	ret	4
??$?0U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > ><void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 319  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

	mov	eax, ecx
	ret	8
??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > ><void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$invoke@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAX$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
tv1046 = -12						; size = 4
$T2 = -8						; size = 8
__Rightnode$1$ = 8					; size = 4
$T3 = 8							; size = 1
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
$T4 = 16						; size = 4
_<_Args_1>$ = 16					; size = 4
??$invoke@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAX$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::invoke<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >, COMDAT

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR __Obj$[esp+8]
	push	ebx
	push	ebp
	push	esi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv1046[esp+24], eax

; 1692 :         return *_Ptr;

	mov	eax, DWORD PTR _<_Args_1>$[esp+20]

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	edi

; 1692 :         return *_Ptr;

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _<_Args_0>$[esp+24]

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	ecx
	sub	esp, 32					; 00000020H
	mov	ebx, esp

; 1692 :         return *_Ptr;

	mov	edi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 252  :         : _Traitsobj(_Right._Traitsobj), _List(static_cast<allocator_type>(_Al)),

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 521  :         return _List._Unchecked_end();

	mov	DWORD PTR $T4[esp+60], eax

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	lea	ecx, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1528 :         _My_data._Myhead = _Newhead;

	mov	DWORD PTR [ebx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	lea	eax, DWORD PTR $T3[esp+60]
	push	eax
	lea	eax, DWORD PTR $T4[esp+64]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [edi+16]
	sub	eax, DWORD PTR [edi+12]
	sar	eax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	push	eax
	call	??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@IABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [ebx+24], eax

; 254  :           _Maxidx(_Right._Maxidx) { // construct hash table by copying _Right

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [ebx+28], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 856  :         return _Unchecked_const_iterator(_Myhead()->_Next, nullptr);

	mov	edi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 701  :         auto _UFirst      = _Get_unwrapped(_First);

	mov	esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN166@invoke
	npad	4
$LL167@invoke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+8], 357913941		; 15555555H
	je	SHORT $LN400@invoke

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Rightnode$1$[esp+64], eax

; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	ebp, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [esi+8]

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Rightnode$1$[esp+60]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	inc	DWORD PTR [ebx+8]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	mov	DWORD PTR [ebp], eax

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	eax, DWORD PTR [eax]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 161  :         return this->_Ptr->_Myval;

	add	eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	eax
	lea	eax, DWORD PTR $T2[esp+72]
	push	eax
	call	??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	esi, DWORD PTR [esi]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL167@invoke
$LN166@invoke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	call	DWORD PTR tv1046[esp+64]
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
$LN400@invoke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN406@invoke:
	int	3
??$invoke@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAX$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::invoke<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$_Call@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@_Invoker_functor@std@@SAX$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv1046 = -12						; size = 4
$T2 = -8						; size = 8
__Rightnode$1$ = 8					; size = 4
$T3 = 8							; size = 1
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
$T4 = 16						; size = 4
_<_Args_1>$ = 16					; size = 4
??$_Call@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@_Invoker_functor@std@@SAX$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Invoker_functor::_Call<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >, COMDAT

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR __Obj$[esp+8]
	push	ebx
	push	ebp
	push	esi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv1046[esp+24], eax

; 1692 :         return *_Ptr;

	mov	eax, DWORD PTR _<_Args_1>$[esp+20]

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	edi

; 1692 :         return *_Ptr;

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _<_Args_0>$[esp+24]

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	ecx
	sub	esp, 32					; 00000020H
	mov	ebx, esp

; 1692 :         return *_Ptr;

	mov	edi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 252  :         : _Traitsobj(_Right._Traitsobj), _List(static_cast<allocator_type>(_Al)),

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 521  :         return _List._Unchecked_end();

	mov	DWORD PTR $T4[esp+60], eax

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	lea	ecx, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1528 :         _My_data._Myhead = _Newhead;

	mov	DWORD PTR [ebx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	lea	eax, DWORD PTR $T3[esp+60]
	push	eax
	lea	eax, DWORD PTR $T4[esp+64]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [edi+16]
	sub	eax, DWORD PTR [edi+12]
	sar	eax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	push	eax
	call	??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@IABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [ebx+24], eax

; 254  :           _Maxidx(_Right._Maxidx) { // construct hash table by copying _Right

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [ebx+28], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 856  :         return _Unchecked_const_iterator(_Myhead()->_Next, nullptr);

	mov	edi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 701  :         auto _UFirst      = _Get_unwrapped(_First);

	mov	esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN158@Call
	npad	4
$LL159@Call:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+8], 357913941		; 15555555H
	je	SHORT $LN391@Call

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Rightnode$1$[esp+64], eax

; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	ebp, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [esi+8]

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Rightnode$1$[esp+60]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	inc	DWORD PTR [ebx+8]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	mov	DWORD PTR [ebp], eax

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	eax, DWORD PTR [eax]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 161  :         return this->_Ptr->_Myval;

	add	eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	eax
	lea	eax, DWORD PTR $T2[esp+72]
	push	eax
	call	??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	esi, DWORD PTR [esi]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL159@Call
$LN158@Call:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	call	DWORD PTR tv1046[esp+64]
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
$LN391@Call:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN397@Call:
	int	3
??$_Call@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@_Invoker_functor@std@@SAX$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Invoker_functor::_Call<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YA$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX01@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YA$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX01@Z@Z PROC ; std::forward<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YA$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX01@Z@Z ENDP ; std::forward<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::reference_wrapper<std::vector<int,std::allocator<int> > > &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::reference_wrapper<std::vector<int,std::allocator<int> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$get@$01P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$01P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z PROC ; std::get<2,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >, COMDAT

; 645  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 646  :     return ((_Ttype&) _Tuple)._Myfirst._Val;

	mov	eax, DWORD PTR __Tuple$[esp-4]

; 647  : }

	ret	0
??$get@$01P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z ENDP ; std::get<2,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$get@$00P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$00P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z PROC ; std::get<1,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >, COMDAT

; 645  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 646  :     return ((_Ttype&) _Tuple)._Myfirst._Val;

	mov	eax, DWORD PTR __Tuple$[esp-4]
	add	eax, 4

; 647  : }

	ret	0
??$get@$00P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z ENDP ; std::get<1,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YA$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX01@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YA$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX01@Z@Z PROC ; std::move<void (__cdecl*&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YA$$QAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAP6AX01@Z@Z ENDP ; std::move<void (__cdecl*&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$get@$0A@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z PROC ; std::get<0,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >, COMDAT

; 645  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 646  :     return ((_Ttype&) _Tuple)._Myfirst._Val;

	mov	eax, DWORD PTR __Tuple$[esp-4]
	add	eax, 8

; 647  : }

	ret	0
??$get@$0A@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAAAP6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZAAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@0@@Z ENDP ; std::get<0,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$?0U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,0>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1871 :     }

	mov	eax, ecx
	ret	4
??$?0U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > ><std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
_<_Rest_arg_1>$ = 16					; size = 4
??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > ><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR _<_Rest_arg_1>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 319  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

	mov	eax, ecx
	ret	12					; 0000000cH
??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@$0A@@?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > ><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z PROC ; std::addressof<std::vector<int,std::allocator<int> > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z ENDP ; std::addressof<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<int,std::allocator<int> > &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAAAV?$vector@HV?$allocator@H@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<int,std::allocator<int> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$invoke@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAX$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@H@0@3@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$ = 20					; size = 4
??$invoke@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAX$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@H@0@3@Z PROC ; std::invoke<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >, COMDAT

; 1692 :         return *_Ptr;

	mov	eax, DWORD PTR _<_Args_2>$[esp-4]
	mov	eax, DWORD PTR [eax]

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	DWORD PTR [eax]

; 1692 :         return *_Ptr;

	mov	eax, DWORD PTR _<_Args_1>$[esp]
	mov	eax, DWORD PTR [eax]

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR _<_Args_0>$[esp+4]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR __Obj$[esp+8]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	ret	0
??$invoke@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAX$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@H@0@3@Z ENDP ; std::invoke<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$_Call@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@_Invoker_functor@std@@SAX$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$ = 20					; size = 4
??$_Call@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@_Invoker_functor@std@@SAX$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z PROC ; std::_Invoker_functor::_Call<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >, COMDAT

; 1692 :         return *_Ptr;

	mov	eax, DWORD PTR _<_Args_2>$[esp-4]
	mov	eax, DWORD PTR [eax]

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	DWORD PTR [eax]

; 1692 :         return *_Ptr;

	mov	eax, DWORD PTR _<_Args_1>$[esp]
	mov	eax, DWORD PTR [eax]

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR _<_Args_0>$[esp+4]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR __Obj$[esp+8]
	mov	eax, DWORD PTR [eax]
	call	eax
	add	esp, 12					; 0000000cH
	ret	0
??$_Call@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@_Invoker_functor@std@@SAX$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z ENDP ; std::_Invoker_functor::_Call<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YA$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAP6AX0HH@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YA$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAP6AX0HH@Z@Z PROC ; std::forward<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YA$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAP6AX0HH@Z@Z ENDP ; std::forward<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$get@$02P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@H@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$02P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@H@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z PROC ; std::get<3,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >, COMDAT

; 645  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 646  :     return ((_Ttype&) _Tuple)._Myfirst._Val;

	mov	eax, DWORD PTR __Tuple$[esp-4]

; 647  : }

	ret	0
??$get@$02P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@H@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z ENDP ; std::get<3,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAV?$reference_wrapper@H@std@@@std@@YA$$QAV?$reference_wrapper@H@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$reference_wrapper@H@std@@@std@@YA$$QAV?$reference_wrapper@H@0@AAV10@@Z PROC ; std::move<std::reference_wrapper<int> &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAV?$reference_wrapper@H@std@@@std@@YA$$QAV?$reference_wrapper@H@0@AAV10@@Z ENDP ; std::move<std::reference_wrapper<int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$get@$01P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@H@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$01P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@H@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z PROC ; std::get<2,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >, COMDAT

; 645  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 646  :     return ((_Ttype&) _Tuple)._Myfirst._Val;

	mov	eax, DWORD PTR __Tuple$[esp-4]
	add	eax, 4

; 647  : }

	ret	0
??$get@$01P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@H@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z ENDP ; std::get<2,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV10@@Z PROC ; std::move<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV10@@Z ENDP ; std::move<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$get@$00P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$00P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z PROC ; std::get<1,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >, COMDAT

; 645  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 646  :     return ((_Ttype&) _Tuple)._Myfirst._Val;

	mov	eax, DWORD PTR __Tuple$[esp-4]
	add	eax, 8

; 647  : }

	ret	0
??$get@$00P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z ENDP ; std::get<1,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YA$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAP6AX0HH@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YA$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAP6AX0HH@Z@Z PROC ; std::move<void (__cdecl*&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YA$$QAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAP6AX0HH@Z@Z ENDP ; std::move<void (__cdecl*&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$get@$0A@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z PROC ; std::get<0,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >, COMDAT

; 645  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 646  :     return ((_Ttype&) _Tuple)._Myfirst._Val;

	mov	eax, DWORD PTR __Tuple$[esp-4]
	add	eax, 12					; 0000000cH

; 647  : }

	ret	0
??$get@$0A@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@YAAAP6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZAAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@0@@Z ENDP ; std::get<0,void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$?0U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > ><std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,0>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1871 :     }

	mov	eax, ecx
	ret	4
??$?0U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@$0A@@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > ><std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@$0A@@?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z
_TEXT	SEGMENT
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
_<_Rest_arg_1>$ = 16					; size = 4
_<_Rest_arg_2>$ = 20					; size = 4
??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@$0A@@?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z PROC ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> ><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR _<_Rest_arg_2>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<_Rest_arg_1>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _<_Rest_arg_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 319  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

	mov	eax, ecx
	ret	16					; 00000010H
??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@$0A@@?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z ENDP ; std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> ><void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$_Insert@ABHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHU_Not_a_node_tag@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
__Pnode$ = 16						; size = 1
??$_Insert@ABHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHU_Not_a_node_tag@1@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert<int const &,std::_Not_a_node_tag>, COMDAT
; _this$ = ecx

; 1031 :         // try to insert existing node with value _Val
; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	DWORD PTR __Pnode$[esp-4]
	push	DWORD PTR __Val$[esp]
	push	DWORD PTR ___$ReturnUdt$[esp+4]
	call	??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int const ,std::_Not_a_node_tag>

; 1033 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1034 :         _Stl_internal_check_container_invariants();
; 1035 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1036 :         return _Result;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1037 :     }

	ret	12					; 0000000cH
??$_Insert@ABHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHU_Not_a_node_tag@1@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert<int const &,std::_Not_a_node_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@ABEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@HH@Z
_TEXT	SEGMENT
__Rng$ = -12						; size = 12
__Eng$ = 8						; size = 4
__Umin$1$ = 12						; size = 4
__Min$ = 12						; size = 4
__Max$ = 16						; size = 4
??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@ABEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@HH@Z PROC ; std::uniform_int<int>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT
; _this$ = ecx

; 1873 :     result_type _Eval(_Engine& _Eng, _Ty _Min, _Ty _Max) const { // compute next value in range [_Min, _Max]

	sub	esp, 12					; 0000000cH

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	mov	eax, DWORD PTR __Min$[esp+8]
	cmp	eax, -2147483648			; 80000000H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	edx, DWORD PTR __Eng$[esp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1873 :     result_type _Eval(_Engine& _Eng, _Ty _Min, _Ty _Max) const { // compute next value in range [_Min, _Max]

	push	ebx
	push	esi

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	lea	ecx, DWORD PTR [eax-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$[esp+20], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	lea	ebx, DWORD PTR [eax-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$[esp+24], 32		; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1877 :         const _Uty _Umax = _Adjust(_Uty(_Max));

	mov	eax, DWORD PTR __Max$[esp+16]
	cmovae	ebx, ecx
	cmp	eax, -2147483648			; 80000000H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$[esp+28], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	mov	DWORD PTR __Umin$1$[esp+16], ebx

; 1877 :         const _Uty _Umax = _Adjust(_Uty(_Max));

	lea	ecx, DWORD PTR [eax-2147483648]
	lea	esi, DWORD PTR [eax-2147483648]
	cmovae	esi, ecx

; 1878 : 
; 1879 :         _Uty _Uret;
; 1880 : 
; 1881 :         if (_Umax - _Umin == _Uty(-1)) {

	sub	esi, ebx
	cmp	esi, -1
	jne	SHORT $LN2@Eval
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3304 :             _Ret |= _Get_bits();

	lea	ecx, DWORD PTR __Rng$[esp+20]
	call	?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1882 :             _Uret = static_cast<_Uty>(_Rng._Get_all_bits());

	mov	edx, eax

; 1883 :         } else {

	jmp	SHORT $LN33@Eval
$LN2@Eval:
	push	ebp
	push	edi

; 1884 :             _Uret = static_cast<_Uty>(_Rng(static_cast<_Uty>(_Umax - _Umin + 1)));

	lea	ebp, DWORD PTR [esi+1]
	npad	6
$LL32@Eval:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3279 :             _Udiff _Ret  = 0; // random bits

	xor	edi, edi

; 3280 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

	xor	eax, eax

; 3281 : 
; 3282 :             while (_Mask < _Udiff(_Index - 1)) { // need more random bits

	test	esi, esi
	je	SHORT $LN36@Eval

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	mov	ecx, edx
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
	mov	edi, eax

; 3288 :                 _Mask |= _Bmask;

	or	eax, -1
$LN36@Eval:

; 3289 :             }
; 3290 : 
; 3291 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3292 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

	xor	edx, edx
	div	ebp
	mov	ecx, eax
	mov	ebx, edx
	xor	edx, edx
	mov	eax, edi
	div	ebp
	cmp	eax, ecx
	jb	SHORT $LN61@Eval
	mov	edx, DWORD PTR __Eng$[esp+24]
	cmp	ebx, esi
	jne	SHORT $LL32@Eval
$LN61@Eval:
	mov	ebx, DWORD PTR __Umin$1$[esp+24]

; 3293 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, edi
	xor	edx, edx
	pop	edi
	div	ebp
	pop	ebp
$LN33@Eval:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1887 :         return _Ty(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	ecx, DWORD PTR [edx+ebx]
	cmp	ecx, -2147483648			; 80000000H
	lea	edx, DWORD PTR [ecx-2147483648]
	lea	eax, DWORD PTR [ecx-2147483648]
	pop	esi
	cmovae	eax, edx
	pop	ebx

; 1888 :     }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@ABEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@HH@Z ENDP ; std::uniform_int<int>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@H@std@@YAPAHAAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@H@std@@YAPAHAAH@Z PROC			; std::addressof<int>, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@H@std@@YAPAHAAH@Z ENDP			; std::addressof<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YAPAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YAPAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV10@@Z PROC ; std::addressof<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YAPAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV10@@Z ENDP ; std::addressof<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YAAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YAAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV10@@Z PROC ; std::forward<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YAAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV10@@Z ENDP ; std::forward<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1816 :     }

	mov	eax, ecx
	ret	4
??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Ptr$ = 12						; size = 4
__Cvt$ = 16						; size = 44
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z PROC ; std::numpunct<char>::_Getvals<char>, COMDAT
; _this$ = ecx

; 170  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	mov	eax, DWORD PTR [edx]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ecx+12], al

; 171  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	eax, DWORD PTR [edx+4]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ecx+13], al

; 172  :     }

	ret	52					; 00000034H
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ENDP ; std::numpunct<char>::_Getvals<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 546  :     return (_Elem)(unsigned char) _Byte;

	mov	al, BYTE PTR __Byte$[esp-4]

; 547  : }

	ret	0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 572  :     const _Locinfo::_Cvtvec&) { // convert C string to _Elem sequence using _Cvtvec

	push	esi

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	esi, DWORD PTR __Ptr$[esp]
	push	edi
	mov	edi, esi
	lea	ecx, DWORD PTR [edi+1]
	npad	5
$LL11@Maklocstr:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL11@Maklocstr
	sub	edi, ecx
	inc	edi

; 574  : 
; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
	call	_calloc
	mov	edx, eax
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	edx, edx
	je	SHORT $LN14@Maklocstr

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	test	edi, edi
	je	SHORT $LN3@Maklocstr
	mov	ecx, edx
	sub	ecx, esi
$LL4@Maklocstr:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL4@Maklocstr
$LN3@Maklocstr:
	pop	edi

; 583  :     }
; 584  : 
; 585  :     return _Ptrdest;

	mov	eax, edx

; 586  : }

	pop	esi
	ret	0
$LN14@Maklocstr:

; 578  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN12@Maklocstr:
	int	3
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ PROC	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >, COMDAT
; _this$ = ecx

; 3513 :     ~_Tidy_guard() {

	push	esi

; 3514 :         if (_Target) {

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN2@Tidy_guard
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 224  :         _CSTD free((void*) _Grouping);

	push	DWORD PTR [esi+8]
	call	_free

; 225  :         _CSTD free((void*) _Falsename);

	push	DWORD PTR [esi+16]
	call	_free

; 226  :         _CSTD free((void*) _Truename);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 12					; 0000000cH
$LN2@Tidy_guard:
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3517 :     }

	ret	0
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ENDP	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@H@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@H@std@@@0@AAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<int> > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@H@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@H@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@H@std@@@0@ABV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<int> > const >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@H@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<int> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 24   :     constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   :     size_t _Result                 = _Count * _Ty_size;

	mov	ecx, DWORD PTR __Count$[esp-4]

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	ecx, 1073741823				; 3fffffffH
	lea	eax, DWORD PTR [ecx*4]
	cmova	eax, edx

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);
; 29   :     }
; 30   : 
; 31   :     return _Result;
; 32   : }

	ret	0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*, COMDAT
; _this$ = ecx

; 161  :         return this->_Ptr->_Myval;

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 253  :         return (reference) * *(_Mybase*) this;
; 254  :     }

	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEAAHXZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_iterator<std::_List_val<std::_List_simple_types<int> > >, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 249  :         : _Mybase(_Pnode, _Plist) { // construct with node pointer _Pnode
; 250  :     }

	mov	eax, ecx
	ret	8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_iterator<std::_List_val<std::_List_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@IV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@IABV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@IV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@IABV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z PROC ; std::_Uninitialized_fill_n<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,unsigned int,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >, COMDAT

; 299  :     return _Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	mov	edx, DWORD PTR __Count$[esp-4]

; 131  :     _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __First$[esp-4]

; 281  :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN5@Uninitiali
	push	esi
	mov	esi, DWORD PTR __Val$[esp]
$LL6@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 143  :         ++_Last;

	add	eax, 4

; 281  :     for (; 0 < _Count; --_Count) {

	sub	edx, 1
	jne	SHORT $LL6@Uninitiali

; 299  :     return _Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	pop	esi
$LN5@Uninitiali:

; 300  :         bool_constant<conjunction_v<decltype(_Fill_memset_is_safe(_First, _Val)),
; 301  :             _Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(_Val)>>>{});
; 302  : }

	ret	0
??$_Uninitialized_fill_n@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@IV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@QAV10@IABV10@AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,unsigned int,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
tv793 = -36						; size = 4
__Newsize$1$ = -32					; size = 4
__Newcapacity$ = -28					; size = 4
tv801 = -24						; size = 4
$T2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>, COMDAT
; _this$ = ecx

; 659  :         const pointer _Whereptr, _Valty&&... _Val) { // reallocate and insert by perfectly forwarding _Val at _Whereptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 660  :                                                      // pre: !_Has_unused_capacity()
; 661  :         const size_type _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst());

	mov	edx, DWORD PTR [edi]
	mov	ebx, DWORD PTR __Whereptr$[ebp]
	sub	ebx, edx
	sar	ebx, 2

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [edi+4]
	sub	eax, edx
	sar	eax, 2

; 662  :         _Alty& _Al                = _Getal();
; 663  :         const size_type _Oldsize  = size();
; 664  : 
; 665  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN314@Emplace_re

; 667  :         }
; 668  : 
; 669  :         const size_type _Newsize     = _Oldsize + 1;

	lea	esi, DWORD PTR [eax+1]
	mov	DWORD PTR __Newsize$1$[ebp], esi

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN48@Emplace_re

; 1476 :             return _Newsize; // geometric growth would overflow

	mov	eax, esi
	mov	DWORD PTR __Newcapacity$[ebp], esi
	jmp	SHORT $LN49@Emplace_re
$LN48@Emplace_re:

; 1477 :         }
; 1478 : 
; 1479 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [edx+ecx]

; 1480 : 
; 1481 :         if (_Geometric < _Newsize) {

	cmp	eax, esi
	cmovb	eax, esi
	mov	DWORD PTR __Newcapacity$[ebp], eax
$LN49@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 25   :     size_t _Result                 = _Count * _Ty_size;

	lea	ecx, DWORD PTR [eax*4]
	mov	DWORD PTR tv793[ebp], ecx

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN80@Emplace_re

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	or	ecx, -1

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN309@Emplace_re
$LN80@Emplace_re:
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN83@Emplace_re
$LN309@Emplace_re:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN278@Emplace_re

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN312@Emplace_re
$LN83@Emplace_re:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN84@Emplace_re

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 179  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	mov	DWORD PTR $T2[ebp], eax
	jmp	SHORT $LN82@Emplace_re
$LN84@Emplace_re:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	esi, esi
$LN312@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 676  :         _TRY_BEGIN

	mov	DWORD PTR $T2[ebp], esi
$LN82@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 677  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	ecx, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR tv801[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 680  :         if (_Whereptr == _Mylast()) { // at back, provide strong guarantee

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	mov	ebx, DWORD PTR __Whereptr$[ebp]
	cmp	ebx, eax
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	eax, ecx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 682  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, ebx
	sub	eax, ecx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	esi
	call	_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 685  :             _Umove(_Whereptr, _Mylast(), _Newvec + _Whereoff + 1);

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR tv801[ebp]
	add	ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	eax, ebx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ebx
	push	ecx
	call	_memmove
	add	esp, 24					; 00000018H
$LN5@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1512 :         if (_Myfirst() != pointer()) { // destroy and deallocate old array

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN282@Emplace_re

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	ecx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN281@Emplace_re

; 107  :     _Bytes += _Non_user_size;

	add	ecx, 35					; 00000023H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN278@Emplace_re

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN281@Emplace_re:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN282@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1517 :         _Myfirst() = _Newvec;

	mov	DWORD PTR [edi], esi

; 1518 :         _Mylast()  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [edi+4], ecx

; 1519 :         _Myend()   = _Newvec + _Newcapacity;

	mov	ecx, DWORD PTR tv793[ebp]
	add	ecx, esi
	mov	DWORD PTR [edi+8], ecx

; 691  :         _CATCH_END
; 692  : 
; 693  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 694  :         return this->_Myfirst() + _Whereoff;

	mov	eax, DWORD PTR tv801[ebp]

; 695  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$0:

; 686  :         }
; 687  :         _CATCH_ALL
; 688  :         _Destroy(_Constructed_first, _Constructed_last);
; 689  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	DWORD PTR __Newcapacity$[ebp]
	push	DWORD PTR $T2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@H@std@@QAEXQAHI@Z ; std::allocator<int>::deallocate

; 690  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN314@Emplace_re:

; 666  :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN278@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN311@Emplace_re:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEAAHABH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEAAHABH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edx, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 624  :         _Ty& _Result = *_Mylast();

	mov	eax, DWORD PTR [ecx+4]

; 625  :         ++_Mylast();

	lea	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 626  : #if _HAS_CXX17
; 627  :         return _Result;
; 628  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 629  :         (void) _Result;
; 630  : #endif // _HAS_CXX17
; 631  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEAAHABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEAAHABH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEAAHABH@Z PROC ; std::vector<int,std::allocator<int> >::emplace_back<int const &>, COMDAT
; _this$ = ecx

; 636  :         _Valty&&... _Val) { // insert by perfectly forwarding into element at end, provide strong guarantee

	mov	edx, ecx

; 1357 :         return _Myend() != _Mylast();

	mov	ecx, DWORD PTR [edx+4]
	cmp	DWORD PTR [edx+8], ecx

; 637  :         if (_Has_unused_capacity()) {

	je	SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 624  :         _Ty& _Result = *_Mylast();

	mov	eax, DWORD PTR [edx+4]

; 625  :         ++_Mylast();

	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 642  : #if _HAS_CXX17
; 643  :         return _Result;
; 644  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 645  :         (void) _Result;
; 646  : #endif // _HAS_CXX17
; 647  :     }

	ret	4
$LN2@emplace_ba:

; 638  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 639  :         }
; 640  : 
; 641  :         _Ty& _Result = *_Emplace_reallocate(_Mylast(), _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	ecx
	mov	ecx, edx
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>

; 642  : #if _HAS_CXX17
; 643  :         return _Result;
; 644  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 645  :         (void) _Result;
; 646  : #endif // _HAS_CXX17
; 647  :     }

	ret	4
??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEAAHABH@Z ENDP ; std::vector<int,std::allocator<int> >::emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>, COMDAT

; 824  :         _Ptr->~_Uty();
; 825  :     }

	ret	0
??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$_Unfancy@H@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@H@std@@YAPAHPAH@Z PROC			; std::_Unfancy<int>, COMDAT

; 295  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[esp-4]

; 296  : }

	ret	0
??$_Unfancy@H@std@@YAPAHPAH@Z ENDP			; std::_Unfancy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@HPAX@std@@@std@@YAAAPAU?$_List_node@HPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@HPAX@std@@@std@@YAAAPAU?$_List_node@HPAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<int,void *> * &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAPAU?$_List_node@HPAX@std@@@std@@YAAAPAU?$_List_node@HPAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0H@?$allocator@U?$_List_node@HPAX@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0H@?$allocator@U?$_List_node@HPAX@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_List_node<int,void *> >::allocator<std::_List_node<int,void *> ><int>, COMDAT
; _this$ = ecx

; 921  :     }

	mov	eax, ecx
	ret	4
??$?0H@?$allocator@U?$_List_node@HPAX@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_List_node<int,void *> >::allocator<std::_List_node<int,void *> ><int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z PROC ; std::forward<std::allocator<int> const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ENDP ; std::forward<std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??1?$_Tidy_guard@V?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > > >::~_Tidy_guard<std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > > >, COMDAT
; _this$ = ecx

; 3514 :         if (_Target) {

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	?_Tidy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Tidy

; 3515 :             _Target->_Tidy();
; 3516 :         }
; 3517 :     }

	ret	0
??1?$_Tidy_guard@V?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > > >::~_Tidy_guard<std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@YAABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@YAABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@ABV10@@Z PROC ; std::forward<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@YAABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	mov	eax, DWORD PTR __Bytes$[esp-4]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	lea	ecx, DWORD PTR [eax+35]
	cmp	ecx, eax
	cmovbe	ecx, edx

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 89   :                                  // allocation function will throw bad_alloc
; 90   :         _Block_size = static_cast<size_t>(-1);
; 91   :     }
; 92   : 
; 93   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN7@Allocate_m

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 97   : 
; 98   : #ifdef _DEBUG
; 99   :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 100  : #endif // _DEBUG
; 101  :     return _Ptr;
; 102  : }

	ret	0
$LN7@Allocate_m:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	jmp	__invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@H@std@@YAIIABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Fnv1a_append_value@H@std@@YAIIABH@Z PROC		; std::_Fnv1a_append_value<int>, COMDAT

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	edx, DWORD PTR __Keyval$[esp-4]
	movzx	eax, BYTE PTR [edx]
	xor	eax, DWORD PTR __Val$[esp-4]

; 1937 :         _Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619

; 1955 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 1956 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
; 1957 : }

	ret	0
??$_Fnv1a_append_value@H@std@@YAIIABH@Z ENDP		; std::_Fnv1a_append_value<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0AAU?$equal_to@H@std@@M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@H@1@$$QAM@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0AAU?$equal_to@H@std@@M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@H@1@$$QAM@Z PROC ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Compressed_pair<std::equal_to<int>,float,1><std::equal_to<int> &,float>, COMDAT
; _this$ = ecx

; 1533 :           _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR _<_Val2_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1534 :     }

	mov	eax, ecx
	ret	12					; 0000000cH
??$?0AAU?$equal_to@H@std@@M@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@H@1@$$QAM@Z ENDP ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Compressed_pair<std::equal_to<int>,float,1><std::equal_to<int> &,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QAMAAM@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@M@std@@YA$$QAMAAM@Z PROC			; std::forward<float>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@M@std@@YA$$QAMAAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAU?$equal_to@H@std@@@std@@YAAAU?$equal_to@H@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$equal_to@H@std@@@std@@YAAAU?$equal_to@H@0@AAU10@@Z PROC ; std::forward<std::equal_to<int> &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAU?$equal_to@H@std@@@std@@YAAAU?$equal_to@H@0@AAU10@@Z ENDP ; std::forward<std::equal_to<int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_One_then_variadic_args_t>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_One_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAU?$hash@H@std@@@std@@YAAAU?$hash@H@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$hash@H@std@@@std@@YAAAU?$hash@H@0@AAU10@@Z PROC ; std::forward<std::hash<int> &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAU?$hash@H@std@@@std@@YAAAU?$hash@H@0@AAU10@@Z ENDP ; std::forward<std::hash<int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@HPAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@HPAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::destroy<std::_List_node<int,void *> *>, COMDAT

; 824  :         _Ptr->~_Uty();
; 825  :     }

	ret	0
??$destroy@PAU?$_List_node@HPAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::destroy<std::_List_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z PROC ; std::_List_node<int,void *>::_Freenode<std::allocator<std::_List_node<int,void *> > >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	DWORD PTR __Ptr$[esp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 336  :     }

	ret	0
??$_Freenode@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<int,void *>::_Freenode<std::allocator<std::_List_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>, COMDAT
; _this$ = ecx

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 77   :         }

	mov	eax, ecx
	ret	4
??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >, COMDAT

; 248  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 249  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	mov	ecx, DWORD PTR __Left$[esp-4]
	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	sbb	ecx, DWORD PTR [eax+4]

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 250  :     }

	ret	0
??$?G_JU?$ratio@$00$0JIJGIA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,10000000>,__int64,std::ratio<1,10000000> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
;	COMDAT ??$_Invoke@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00@thread@std@@CGIPAX@Z
_TEXT	SEGMENT
__RawVals$ = 8						; size = 4
??$_Invoke@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00@thread@std@@CGIPAX@Z PROC ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,0,1>, COMDAT

; 35   :     static unsigned int __stdcall _Invoke(void* _RawVals) noexcept { // enforces termination

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	esi, DWORD PTR __RawVals$[esp]
	push	DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	call	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 40   :         _Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABI

	call	__Cnd_do_broadcast_at_thread_exit
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1768 :         delete _Ptr;

	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 41   :         return 0;

	xor	eax, eax
	pop	esi

; 42   :     }

	ret	4
??$_Invoke@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00@thread@std@@CGIPAX@Z ENDP ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,0,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?release@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?release@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::release, COMDAT
; _this$ = ecx

; 1947 :         return this->_Myptr();

	mov	eax, DWORD PTR [ecx]

; 1955 :         pointer _Ans   = get();
; 1956 :         this->_Myptr() = pointer();

	mov	DWORD PTR [ecx], 0

; 1957 :         return _Ans;
; 1958 :     }

	ret	0
?release@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?get@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?get@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get, COMDAT
; _this$ = ecx

; 1947 :         return this->_Myptr();

	mov	eax, DWORD PTR [ecx]

; 1948 :     }

	ret	0
?get@?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??D?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEAAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@XZ
_TEXT	SEGMENT
??D?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEAAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::operator*, COMDAT
; _this$ = ecx

; 1939 :         return *get();

	mov	eax, DWORD PTR [ecx]

; 1940 :     }

	ret	0
??D?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEAAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??1?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::~unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >, COMDAT
; _this$ = ecx

; 1933 :         if (get() != pointer()) {

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN2@unique_ptr

; 1768 :         delete _Ptr;

	push	8
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@unique_ptr:

; 1934 :             this->get_deleter()(get());
; 1935 :         }
; 1936 :     }

	ret	0
??1?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::~unique_ptr<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QBEABQAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QBEABQAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QBEABQAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEABQAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEABQAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr, COMDAT
; _this$ = ecx

; 1831 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1832 :     }

	ret	0
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEABQAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr, COMDAT
; _this$ = ecx

; 1827 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1828 :     }

	ret	0
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get_deleter, COMDAT
; _this$ = ecx

; 1819 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1820 :     }

	ret	0
?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??R?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QBEXPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??R?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QBEXPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z PROC ; std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >::operator(), COMDAT
; _this$ = ecx

; 1767 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1768 :         delete _Ptr;

	push	8
	push	DWORD PTR __Ptr$[esp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 1769 :     }

	ret	4
??R?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QBEXPAV?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ENDP ; std::default_delete<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > > >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$make_unique@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A6AXAAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@0@A6AXAAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$make_unique@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A6AXAAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@0@A6AXAAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::make_unique<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>, COMDAT

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	test	edx, edx
	je	SHORT $LN3@make_uniqu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	ecx, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	DWORD PTR [edx+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	DWORD PTR [eax], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2116 : }

	ret	0
$LN3@make_uniqu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	DWORD PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2116 : }

	ret	0
??$make_unique@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A6AXAAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@0@A6AXAAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::make_unique<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YAA6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZA6AX0@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YAA6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZA6AX0@Z@Z PROC ; std::forward<void (__cdecl&)(std::vector<int,std::allocator<int> > &)>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@Z@std@@YAA6AXAAV?$vector@HV?$allocator@H@std@@@0@@ZA6AX0@Z@Z ENDP ; std::forward<void (__cdecl&)(std::vector<int,std::allocator<int> > &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
;	COMDAT ??$_Invoke@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00$01@thread@std@@CGIPAX@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
__Rightnode$1$ = -16					; size = 4
$T3 = -16						; size = 4
tv1181 = -12						; size = 4
$T4 = -8						; size = 8
__RawVals$ = 8						; size = 4
??$_Invoke@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00$01@thread@std@@CGIPAX@Z PROC ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,0,1,2>, COMDAT

; 35   :     static unsigned int __stdcall _Invoke(void* _RawVals) noexcept { // enforces termination

	sub	esp, 20					; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	eax, DWORD PTR __RawVals$[esp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 35   :     static unsigned int __stdcall _Invoke(void* _RawVals) noexcept { // enforces termination

	push	ebx
	push	ebp
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	mov	ecx, DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 35   :     static unsigned int __stdcall _Invoke(void* _RawVals) noexcept { // enforces termination

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	DWORD PTR [eax]

; 1692 :         return *_Ptr;

	mov	edi, DWORD PTR [eax+4]

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	sub	esp, 32					; 00000020H
	mov	DWORD PTR tv1181[esp+72], ecx
	mov	ebx, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 252  :         : _Traitsobj(_Right._Traitsobj), _List(static_cast<allocator_type>(_Al)),

	mov	eax, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 252  :         : _Traitsobj(_Right._Traitsobj), _List(static_cast<allocator_type>(_Al)),

	mov	DWORD PTR [ebx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 521  :         return _List._Unchecked_end();

	mov	DWORD PTR $T3[esp+72], eax

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	lea	ecx, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1528 :         _My_data._Myhead = _Newhead;

	mov	DWORD PTR [ebx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	lea	eax, DWORD PTR $T2[esp+72]
	push	eax
	lea	eax, DWORD PTR $T3[esp+76]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [edi+16]
	sub	eax, DWORD PTR [edi+12]
	sar	eax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	push	eax
	call	??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@IABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [ebx+24], eax

; 254  :           _Maxidx(_Right._Maxidx) { // construct hash table by copying _Right

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [ebx+28], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 856  :         return _Unchecked_const_iterator(_Myhead()->_Next, nullptr);

	mov	edi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 701  :         auto _UFirst      = _Get_unwrapped(_First);

	mov	esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN196@Invoke
$LL197@Invoke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+8], 357913941		; 15555555H
	je	SHORT $LN452@Invoke

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Rightnode$1$[esp+76], eax

; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	ebp, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [esi+8]

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Rightnode$1$[esp+72]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	inc	DWORD PTR [ebx+8]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	mov	DWORD PTR [ebp], eax

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	eax, DWORD PTR [eax]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 161  :         return this->_Ptr->_Myval;

	add	eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	eax
	lea	eax, DWORD PTR $T4[esp+80]
	push	eax
	call	??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	esi, DWORD PTR [esi]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL197@Invoke
$LN196@Invoke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	call	DWORD PTR tv1181[esp+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 40   :         _Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABI

	call	__Cnd_do_broadcast_at_thread_exit
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1768 :         delete _Ptr;

	push	12					; 0000000cH
	push	DWORD PTR __RawVals$[esp+72]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 44					; 0000002cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 41   :         return 0;

	xor	eax, eax

; 42   :     }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN452@Invoke:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN458@Invoke:
	int	3
??$_Invoke@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00$01@thread@std@@CGIPAX@Z ENDP ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,0,1,2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?release@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?release@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::release, COMDAT
; _this$ = ecx

; 1947 :         return this->_Myptr();

	mov	eax, DWORD PTR [ecx]

; 1955 :         pointer _Ans   = get();
; 1956 :         this->_Myptr() = pointer();

	mov	DWORD PTR [ecx], 0

; 1957 :         return _Ans;
; 1958 :     }

	ret	0
?release@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?get@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?get@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get, COMDAT
; _this$ = ecx

; 1947 :         return this->_Myptr();

	mov	eax, DWORD PTR [ecx]

; 1948 :     }

	ret	0
?get@?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??D?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEAAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@XZ
_TEXT	SEGMENT
??D?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEAAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::operator*, COMDAT
; _this$ = ecx

; 1939 :         return *get();

	mov	eax, DWORD PTR [ecx]

; 1940 :     }

	ret	0
??D?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEAAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??1?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::~unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >, COMDAT
; _this$ = ecx

; 1933 :         if (get() != pointer()) {

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN2@unique_ptr

; 1768 :         delete _Ptr;

	push	12					; 0000000cH
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@unique_ptr:

; 1934 :             this->get_deleter()(get());
; 1935 :         }
; 1936 :     }

	ret	0
??1?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::~unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QBEABQAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QBEABQAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QBEABQAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@PAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEABQAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEABQAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr, COMDAT
; _this$ = ecx

; 1831 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1832 :     }

	ret	0
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QBEABQAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr, COMDAT
; _this$ = ecx

; 1827 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1828 :     }

	ret	0
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@2@XZ ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get_deleter, COMDAT
; _this$ = ecx

; 1819 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1820 :     }

	ret	0
?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@XZ ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > > >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??R?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QBEXPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??R?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QBEXPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z PROC ; std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >::operator(), COMDAT
; _this$ = ecx

; 1767 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1768 :         delete _Ptr;

	push	12					; 0000000cH
	push	DWORD PTR __Ptr$[esp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 1769 :     }

	ret	4
??R?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QBEXPAV?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@1@@Z ENDP ; std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > > >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$make_unique@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@2@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@0@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$ = 20					; size = 4
??$make_unique@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@2@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@0@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::make_unique<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>, COMDAT

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	test	edx, edx
	je	SHORT $LN3@make_uniqu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	ecx, DWORD PTR _<_Args_2>$[esp-4]
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+4], ecx
	mov	DWORD PTR [edx+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2116 : }

	ret	0
$LN3@make_uniqu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2116 : }

	ret	0
??$make_unique@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@2@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@U?$default_delete@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@2@@0@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::make_unique<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::reference_wrapper<std::vector<int,std::allocator<int> > > >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::reference_wrapper<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YAA6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZA6AX01@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YAA6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZA6AX01@Z@Z PROC ; std::forward<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@Z@std@@YAA6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@AAV?$vector@HV?$allocator@H@std@@@0@@ZA6AX01@Z@Z ENDP ; std::forward<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$?0AAV?$vector@HV?$allocator@H@std@@@std@@$0A@@?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@AAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0AAV?$vector@HV?$allocator@H@std@@@std@@$0A@@?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@AAV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::reference_wrapper<std::vector<int,std::allocator<int> > >::reference_wrapper<std::vector<int,std::allocator<int> > ><std::vector<int,std::allocator<int> > &,0>, COMDAT
; _this$ = ecx

; 1687 :         _Ty& _Ref = _STD forward<_Uty>(_Val);
; 1688 :         _Ptr      = _STD addressof(_Ref);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1689 :     }

	mov	eax, ecx
	ret	4
??$?0AAV?$vector@HV?$allocator@H@std@@@std@@$0A@@?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@AAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::reference_wrapper<std::vector<int,std::allocator<int> > >::reference_wrapper<std::vector<int,std::allocator<int> > ><std::vector<int,std::allocator<int> > &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
;	COMDAT ??$_Invoke@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@$0A@$00$01$02@thread@std@@CGIPAX@Z
_TEXT	SEGMENT
__RawVals$ = 8						; size = 4
??$_Invoke@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@$0A@$00$01$02@thread@std@@CGIPAX@Z PROC ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,0,1,2,3>, COMDAT

; 35   :     static unsigned int __stdcall _Invoke(void* _RawVals) noexcept { // enforces termination

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1692 :         return *_Ptr;

	mov	esi, DWORD PTR __RawVals$[esp]
	mov	eax, DWORD PTR [esi]

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	DWORD PTR [eax]

; 1692 :         return *_Ptr;

	mov	eax, DWORD PTR [esi+4]

; 1447 : _IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [esi+8]
	call	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 40   :         _Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABI

	call	__Cnd_do_broadcast_at_thread_exit
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1768 :         delete _Ptr;

	push	16					; 00000010H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 20					; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 41   :         return 0;

	xor	eax, eax
	pop	esi

; 42   :     }

	ret	4
??$_Invoke@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@$0A@$00$01$02@thread@std@@CGIPAX@Z ENDP ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,0,1,2,3>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?release@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ
_TEXT	SEGMENT
?release@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::release, COMDAT
; _this$ = ecx

; 1947 :         return this->_Myptr();

	mov	eax, DWORD PTR [ecx]

; 1955 :         pointer _Ans   = get();
; 1956 :         this->_Myptr() = pointer();

	mov	DWORD PTR [ecx], 0

; 1957 :         return _Ans;
; 1958 :     }

	ret	0
?release@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?get@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ
_TEXT	SEGMENT
?get@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::get, COMDAT
; _this$ = ecx

; 1947 :         return this->_Myptr();

	mov	eax, DWORD PTR [ecx]

; 1948 :     }

	ret	0
?get@?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??D?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEAAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@XZ
_TEXT	SEGMENT
??D?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEAAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::operator*, COMDAT
; _this$ = ecx

; 1939 :         return *get();

	mov	eax, DWORD PTR [ecx]

; 1940 :     }

	ret	0
??D?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEAAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??1?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::~unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >, COMDAT
; _this$ = ecx

; 1933 :         if (get() != pointer()) {

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN2@unique_ptr

; 1768 :         delete _Ptr;

	push	16					; 00000010H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@unique_ptr:

; 1934 :             this->get_deleter()(get());
; 1935 :         }
; 1936 :     }

	ret	0
??1?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::~unique_ptr<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QBEABQAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QBEABQAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QBEABQAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAEAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAEAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAEAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@PAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@$00@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >,std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEABQAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEABQAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::_Myptr, COMDAT
; _this$ = ecx

; 1831 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1832 :     }

	ret	0
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QBEABQAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::_Myptr, COMDAT
; _this$ = ecx

; 1827 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1828 :     }

	ret	0
?_Myptr@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEAAPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@2@XZ ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@XZ
_TEXT	SEGMENT
?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@XZ PROC ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::get_deleter, COMDAT
; _this$ = ecx

; 1819 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1820 :     }

	ret	0
?get_deleter@?$_Unique_ptr_base@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@std@@QAEAAU?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@XZ ENDP ; std::_Unique_ptr_base<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > > >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??R?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@QBEXPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??R?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@QBEXPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z PROC ; std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >::operator(), COMDAT
; _this$ = ecx

; 1767 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1768 :         delete _Ptr;

	push	16					; 00000010H
	push	DWORD PTR __Ptr$[esp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 1769 :     }

	ret	4
??R?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@std@@QBEXPAV?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@1@@Z ENDP ; std::default_delete<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> > >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$make_unique@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@2@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V52@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@0@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@H@0@3@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$ = 20					; size = 4
_<_Args_3>$ = 24					; size = 4
??$make_unique@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@2@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V52@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@0@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@H@0@3@Z PROC ; std::make_unique<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>, COMDAT

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	test	edx, edx
	je	SHORT $LN3@make_uniqu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	ecx, DWORD PTR _<_Args_3>$[esp-4]
	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR _<_Args_2>$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	DWORD PTR [edx+12], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2116 : }

	ret	0
$LN3@make_uniqu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2116 : }

	ret	0
??$make_unique@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@2@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V52@$0A@@std@@YA?AV?$unique_ptr@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@U?$default_delete@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@@2@@0@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@$$QAV?$reference_wrapper@H@0@3@Z ENDP ; std::make_unique<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$reference_wrapper@H@std@@@std@@YA$$QAV?$reference_wrapper@H@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$reference_wrapper@H@std@@@std@@YA$$QAV?$reference_wrapper@H@0@AAV10@@Z PROC ; std::forward<std::reference_wrapper<int> >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@V?$reference_wrapper@H@std@@@std@@YA$$QAV?$reference_wrapper@H@0@AAV10@@Z ENDP ; std::forward<std::reference_wrapper<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV10@@Z PROC ; std::forward<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@V?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@@std@@YA$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV10@@Z ENDP ; std::forward<std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YAA6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZA6AX0HH@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YAA6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZA6AX0HH@Z@Z PROC ; std::forward<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z@std@@YAA6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@HH@ZA6AX0HH@Z@Z ENDP ; std::forward<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??$insert@$0A@$0A@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@$0A@$0A@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::insert<0,0>, COMDAT
; _this$ = ecx

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	DWORD PTR $T1[esp-4]
	push	DWORD PTR __Val$[esp]
	push	DWORD PTR ___$ReturnUdt$[esp+4]
	call	??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int const ,std::_Not_a_node_tag>

; 671  :         return _Insert(_Val, _Not_a_node_tag());

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 672  :     }

	ret	8
??$insert@$0A@$0A@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::insert<0,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 224  :         return _List_unchecked_const_iterator<_Mylist>(this->_Ptr, static_cast<const _Mylist*>(this->_Getcont()));
; 225  :     }

	ret	4
?_Unwrapped@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=, COMDAT
; _this$ = ecx

; 212  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 213  :     }

	ret	4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator==, COMDAT
; _this$ = ecx

; 204  : #if _ITERATOR_DEBUG_LEVEL != 0
; 205  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "list iterators incompatible");
; 206  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 207  : 
; 208  :         return this->_Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 209  :     }

	ret	4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++, COMDAT
; _this$ = ecx

; 180  :         _List_const_iterator _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 175  :         this->_Ptr = this->_Ptr->_Next;

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 181  :         ++*this;
; 182  :         return _Tmp;
; 183  :     }

	ret	8
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++, COMDAT
; _this$ = ecx

; 169  : #if _ITERATOR_DEBUG_LEVEL != 0
; 170  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 171  :         _STL_ASSERT(_Mycont, "cannot increment value-initialized list iterator");
; 172  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot increment end list iterator");
; 173  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 174  : 
; 175  :         this->_Ptr = this->_Ptr->_Next;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 176  :         return *this;

	mov	eax, ecx

; 177  :     }

	ret	0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEABHXZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*, COMDAT
; _this$ = ecx

; 155  : #if _ITERATOR_DEBUG_LEVEL != 0
; 156  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 157  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized list iterator");
; 158  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end list iterator");
; 159  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 160  : 
; 161  :         return this->_Ptr->_Myval;

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 162  :     }

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QBEABHXZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 151  :         : _Mybase(_Pnode, _Plist) { // construct with node pointer _Pnode
; 152  :     }

	mov	eax, ecx
	ret	8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@QBEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
_TEXT	SEGMENT
__Umin$1$ = -16						; size = 4
__Rng$1 = -12						; size = 12
__Eng$ = 8						; size = 4
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@QBEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z PROC ; std::uniform_int<int>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT
; _this$ = ecx

; 1840 :     _NODISCARD result_type operator()(_Engine& _Eng) const { // return next value

	sub	esp, 16					; 00000010H

; 1841 :         return _Eval(_Eng, _Par._Min, _Par._Max);

	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	cmp	ecx, -2147483648			; 80000000H

; 1840 :     _NODISCARD result_type operator()(_Engine& _Eng) const { // return next value

	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	ebx, DWORD PTR __Eng$[esp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1840 :     _NODISCARD result_type operator()(_Engine& _Eng) const { // return next value

	push	ebp

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	lea	eax, DWORD PTR [ecx-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$1[esp+24], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	lea	ebp, DWORD PTR [ecx-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$1[esp+28], 32		; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	cmovae	ebp, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$1[esp+32], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1840 :     _NODISCARD result_type operator()(_Engine& _Eng) const { // return next value

	push	esi

; 1877 :         const _Uty _Umax = _Adjust(_Uty(_Max));

	cmp	edx, -2147483648			; 80000000H
	mov	DWORD PTR __Umin$1$[esp+28], ebp
	lea	eax, DWORD PTR [edx-2147483648]
	lea	esi, DWORD PTR [edx-2147483648]
	cmovae	esi, eax

; 1878 : 
; 1879 :         _Uty _Uret;
; 1880 : 
; 1881 :         if (_Umax - _Umin == _Uty(-1)) {

	sub	esi, ebp
	cmp	esi, -1
	jne	SHORT $LN4@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3304 :             _Ret |= _Get_bits();

	lea	ecx, DWORD PTR __Rng$1[esp+28]
	call	?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1882 :             _Uret = static_cast<_Uty>(_Rng._Get_all_bits());

	mov	edx, eax

; 1883 :         } else {

	jmp	SHORT $LN35@operator
$LN4@operator:

; 1884 :             _Uret = static_cast<_Uty>(_Rng(static_cast<_Uty>(_Umax - _Umin + 1)));

	lea	ebp, DWORD PTR [esi+1]
	push	edi
	npad	7
$LL34@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3279 :             _Udiff _Ret  = 0; // random bits

	xor	edi, edi

; 3280 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

	xor	eax, eax

; 3281 : 
; 3282 :             while (_Mask < _Udiff(_Index - 1)) { // need more random bits

	test	esi, esi
	je	SHORT $LN38@operator

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	mov	ecx, ebx
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
	mov	edi, eax

; 3288 :                 _Mask |= _Bmask;

	or	eax, -1
$LN38@operator:

; 3289 :             }
; 3290 : 
; 3291 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3292 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

	xor	edx, edx
	div	ebp
	mov	ecx, eax
	mov	ebx, edx
	xor	edx, edx
	mov	eax, edi
	div	ebp
	cmp	eax, ecx
	jb	SHORT $LN63@operator
	cmp	ebx, esi
	mov	ebx, DWORD PTR __Eng$[esp+28]
	jne	SHORT $LL34@operator
$LN63@operator:

; 3293 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, edi
	xor	edx, edx
	div	ebp
	mov	ebp, DWORD PTR __Umin$1$[esp+32]
	pop	edi
$LN35@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1887 :         return _Ty(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	ecx, DWORD PTR [edx+ebp]

; 1841 :         return _Eval(_Eng, _Par._Min, _Par._Max);

	pop	esi
	cmp	ecx, -2147483648			; 80000000H
	lea	edx, DWORD PTR [ecx-2147483648]
	lea	eax, DWORD PTR [ecx-2147483648]
	pop	ebp
	cmovae	eax, edx
	pop	ebx

; 1842 :     }

	add	esp, 16					; 00000010H
	ret	4
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@QBEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ENDP ; std::uniform_int<int>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??0?$uniform_int_distribution@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0?$uniform_int_distribution@H@std@@QAE@HH@Z PROC	; std::uniform_int_distribution<int>::uniform_int_distribution<int>, COMDAT
; _this$ = ecx

; 1798 :             _Min = _Min0;

	mov	eax, DWORD PTR __Min0$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1799 :             _Max = _Max0;

	mov	eax, DWORD PTR __Max0$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 1945 :         : _Mybase(_Min0, _Max0) { // construct from parameters
; 1946 :     }

	mov	eax, ecx
	ret	8
??0?$uniform_int_distribution@H@std@@QAE@HH@Z ENDP	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z PROC	; std::uniform_int<int>::param_type::_Init, COMDAT
; _this$ = ecx

; 1797 :             _STL_ASSERT(_Min0 <= _Max0, "invalid min and max arguments for uniform_int");
; 1798 :             _Min = _Min0;

	mov	eax, DWORD PTR __Min0$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1799 :             _Max = _Max0;

	mov	eax, DWORD PTR __Max0$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 1800 :         }

	ret	8
?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z ENDP	; std::uniform_int<int>::param_type::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??0param_type@?$uniform_int@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0param_type@?$uniform_int@H@std@@QAE@HH@Z PROC	; std::uniform_int<int>::param_type::param_type, COMDAT
; _this$ = ecx

; 1798 :             _Min = _Min0;

	mov	eax, DWORD PTR __Min0$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1799 :             _Max = _Max0;

	mov	eax, DWORD PTR __Max0$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 1777 :             _Init(_Min0, _Max0);
; 1778 :         }

	mov	eax, ecx
	ret	8
??0param_type@?$uniform_int@H@std@@QAE@HH@Z ENDP	; std::uniform_int<int>::param_type::param_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Uval$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z PROC ; std::uniform_int<int>::_Adjust, COMDAT

; 1895 :         const _Uty _Adjuster = (_Uty(-1) >> 1) + 1; // 2^(N-1)
; 1896 : 
; 1897 :         if (_Uval < _Adjuster) {

	mov	eax, DWORD PTR __Uval$[esp-4]

; 1898 :             return static_cast<_Uty>(_Uval + _Adjuster);
; 1899 :         } else {
; 1900 :             return static_cast<_Uty>(_Uval - _Adjuster);
; 1901 :         }
; 1902 :     }

	add	eax, -2147483648			; 80000000H
	ret	0
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ENDP ; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAII@Z
_TEXT	SEGMENT
__Uval$ = 8						; size = 4
?_Adjust@?$uniform_int@H@std@@CAII@Z PROC		; std::uniform_int<int>::_Adjust, COMDAT

; 1891 :         return _Adjust(_Uval, is_signed<_Ty>());

	mov	ecx, DWORD PTR __Uval$[esp-4]
	cmp	ecx, -2147483648			; 80000000H
	lea	edx, DWORD PTR [ecx-2147483648]
	lea	eax, DWORD PTR [ecx-2147483648]
	cmovae	eax, edx

; 1892 :     }

	ret	0
?_Adjust@?$uniform_int@H@std@@CAII@Z ENDP		; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??0?$uniform_int@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0?$uniform_int@H@std@@QAE@HH@Z PROC			; std::uniform_int<int>::uniform_int<int>, COMDAT
; _this$ = ecx

; 1798 :             _Min = _Min0;

	mov	eax, DWORD PTR __Min0$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1799 :             _Max = _Max0;

	mov	eax, DWORD PTR __Max0$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 1807 :     }

	mov	eax, ecx
	ret	8
??0?$uniform_int@H@std@@QAE@HH@Z ENDP			; std::uniform_int<int>::uniform_int<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?max@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ
_TEXT	SEGMENT
?max@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::max, COMDAT

; 1306 :         return _Mybase::_WMSK;

	or	eax, -1

; 1307 :     }

	ret	0
?max@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?min@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ
_TEXT	SEGMENT
?min@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::min, COMDAT

; 1302 :         return 0;

	xor	eax, eax

; 1303 :     }

	ret	0
?min@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>, COMDAT
; _this$ = ecx

; 1101 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

	mov	edx, DWORD PTR __X0$[esp-4]

; 1257 :     explicit mersenne_twister_engine(result_type _X0 = default_seed)

	push	esi
	push	edi

; 1090 :         : _Dxval(_Dxarg) { // construct with specified seed

	mov	DWORD PTR [ecx+4996], -1
	lea	edi, DWORD PTR [ecx+8]

; 1101 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

	mov	DWORD PTR [ecx+4], edx

; 1090 :         : _Dxval(_Dxarg) { // construct with specified seed

	mov	esi, 1
	npad	5
$LL8@mersenne_t:

; 1103 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	eax, edx
	lea	edi, DWORD PTR [edi+4]
	shr	eax, 30					; 0000001eH
	xor	eax, edx
	imul	edx, eax, 1812433253
	add	edx, esi
	inc	esi
	mov	DWORD PTR [edi-4], edx
	cmp	esi, 624				; 00000270H
	jl	SHORT $LL8@mersenne_t

; 1258 :         : _Mybase(_X0, _Dx, _Fx) { // construct with default seed
; 1259 :     }

	pop	edi

; 1106 :         this->_Idx = _Nx;

	mov	DWORD PTR [ecx], 624			; 00000270H

; 1258 :         : _Mybase(_X0, _Dx, _Fx) { // construct with default seed
; 1259 :     }

	mov	eax, ecx
	pop	esi
	ret	4
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ
_TEXT	SEGMENT
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper, COMDAT
; _this$ = ecx

; 1176 :     void _Refill_upper() { // compute values for the upper half of the history array

	push	esi

; 1177 :         int _Ix;
; 1178 :         for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { // fill in values

	lea	eax, DWORD PTR [ecx+8]
	mov	esi, 624				; 00000270H
	npad	7
$LL4@Refill_upp:

; 1179 :             _Ty _Tmp       = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + 1] & _LMSK);

	mov	edx, DWORD PTR [eax-4]
	lea	eax, DWORD PTR [eax+4]
	xor	edx, DWORD PTR [eax-4]
	and	edx, 2147483647				; 7fffffffH
	xor	edx, DWORD PTR [eax-8]

; 1180 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	ecx, edx
	and	cl, 1
	movzx	ecx, cl
	neg	ecx
	sbb	ecx, ecx
	shr	edx, 1
	and	ecx, -1727483681			; 9908b0dfH
	xor	ecx, DWORD PTR [eax+1580]
	xor	ecx, edx
	mov	DWORD PTR [eax+2488], ecx
	sub	esi, 1
	jne	SHORT $LL4@Refill_upp

; 1181 :         }
; 1182 :     }

	pop	esi
	ret	0
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ
_TEXT	SEGMENT
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower, COMDAT
; _this$ = ecx

; 1159 :         void _Refill_lower() { // compute values for the lower half of the history array

	push	ebx
	push	ebp
	mov	ebx, ecx

; 1160 :         int _Ix;
; 1161 :         for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix) { // fill in lower region

	mov	ebp, 227				; 000000e3H
	mov	eax, DWORD PTR [ebx+2500]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebx+2500]
$LL4@Refill_low:

; 1162 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [edi+4]
	xor	ecx, eax
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1163 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [edi+1588]
	xor	eax, ecx
	mov	DWORD PTR [edi-2496], eax
	lea	edi, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL4@Refill_low

; 1164 :         }
; 1165 : 
; 1166 :         for (; _Ix < _Nx - 1; ++_Ix) { // fill in upper region (avoids modulus operation)

	mov	eax, DWORD PTR [ebx+3408]
	lea	edi, DWORD PTR [ebx+3408]
	mov	ebp, 396				; 0000018cH
$LL7@Refill_low:

; 1167 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [edi+4]
	xor	ecx, eax
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1168 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [edi-3404]
	xor	eax, ecx
	mov	DWORD PTR [edi-2496], eax
	lea	edi, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL7@Refill_low

; 1169 :         }
; 1170 : 
; 1171 :         _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

	mov	ecx, DWORD PTR [ebx+4992]
	xor	ecx, DWORD PTR [ebx+4]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, DWORD PTR [ebx+4992]

; 1172 :         this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax

; 1173 :         this->_Idx     = 0;

	pop	edi
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [ebx+1588]
	pop	esi
	xor	eax, ecx
	mov	DWORD PTR [ebx+2496], eax
	pop	ebp
	mov	DWORD PTR [ebx], 0
	pop	ebx

; 1174 :     }

	ret	0
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ
_TEXT	SEGMENT
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator(), COMDAT
; _this$ = ecx

; 1135 :     _NODISCARD result_type operator()() { // return next value

	push	esi
	push	edi
	mov	edi, ecx

; 1136 :         if (this->_Idx == _Nx) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 624				; 00000270H
	jne	SHORT $LN2@operator

; 1178 :         for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { // fill in values

	lea	edx, DWORD PTR [edi+8]
	mov	esi, eax
$LL9@operator:

; 1179 :             _Ty _Tmp       = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + 1] & _LMSK);

	mov	ecx, DWORD PTR [edx-4]
	lea	edx, DWORD PTR [edx+4]
	xor	ecx, DWORD PTR [edx-4]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, DWORD PTR [edx-8]

; 1180 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [edx+1580]
	xor	eax, ecx
	mov	DWORD PTR [edx+2488], eax
	sub	esi, 1
	jne	SHORT $LL9@operator

; 1181 :         }
; 1182 :     }

	mov	eax, DWORD PTR [edi]
	jmp	$LN4@operator
$LN2@operator:

; 1137 :             _Refill_upper();
; 1138 :         } else if (2 * _Nx <= this->_Idx) {

	cmp	eax, 1248				; 000004e0H
	jb	$LN4@operator

; 1161 :         for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix) { // fill in lower region

	mov	eax, DWORD PTR [edi+2500]
	push	ebx
	lea	ebx, DWORD PTR [edi+2500]
	push	ebp
	mov	ebp, 227				; 000000e3H
	npad	2
$LL14@operator:

; 1162 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR [ebx+4]
	xor	ecx, eax
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1163 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [ebx+1588]
	xor	eax, ecx
	mov	DWORD PTR [ebx-2496], eax
	lea	ebx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL14@operator

; 1164 :         }
; 1165 : 
; 1166 :         for (; _Ix < _Nx - 1; ++_Ix) { // fill in upper region (avoids modulus operation)

	mov	eax, DWORD PTR [edi+3408]
	lea	ebx, DWORD PTR [edi+3408]
	mov	ebp, 396				; 0000018cH
	npad	6
$LL17@operator:

; 1167 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, eax
	lea	edx, DWORD PTR [ebx+4]
	xor	ecx, DWORD PTR [edx]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1168 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [ebx-3404]
	xor	eax, ecx
	mov	DWORD PTR [ebx-2496], eax
	lea	ebx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL17@operator

; 1169 :         }
; 1170 : 
; 1171 :         _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

	mov	ecx, DWORD PTR [edi+4992]
	xor	ecx, DWORD PTR [edi+4]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, DWORD PTR [edi+4992]

; 1172 :         this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax

; 1173 :         this->_Idx     = 0;

	pop	ebp
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [edi+1588]
	xor	eax, ecx
	mov	DWORD PTR [edi+2496], eax
	xor	eax, eax
	mov	DWORD PTR [edi], 0
	pop	ebx
$LN4@operator:

; 1139 :             _Refill_lower();
; 1140 :         }
; 1141 : 
; 1142 :         _Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

	mov	edx, DWORD PTR [edi+eax*4+4]
	inc	eax
	mov	DWORD PTR [edi], eax

; 1143 :         _Res ^= (_Res >> _Ux) & _Dxval;

	mov	ecx, edx
	mov	eax, DWORD PTR [edi+4996]
	shr	ecx, 11					; 0000000bH
	and	eax, ecx
	xor	edx, eax

; 1144 :         _Res ^= (_Res << _Sx) & _Bx;

	mov	eax, edx
	and	eax, -12953427				; ff3a58adH
	shl	eax, 7
	xor	edx, eax

; 1145 :         _Res ^= (_Res << _Tx) & _Cx;

	mov	eax, edx
	and	eax, -8308				; ffffdf8cH
	shl	eax, 15					; 0000000fH
	xor	edx, eax

; 1146 :         _Res ^= (_Res & _WMSK) >> _Lx;

	mov	eax, edx
	shr	eax, 18					; 00000012H

; 1147 :         return _Res;

	pop	edi
	xor	eax, edx
	pop	esi

; 1148 :     }

	ret	0
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
__Fx$ = 12						; size = 4
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed, COMDAT
; _this$ = ecx

; 1101 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

	mov	edx, DWORD PTR __X0$[esp-4]
	mov	eax, 1
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Fx$[esp+8]
	mov	DWORD PTR [ebx+4], edx
	lea	esi, DWORD PTR [ebx+8]
$LL4@seed:

; 1102 :         for (int _Ix = 1; _Ix < _Nx; ++_Ix) {
; 1103 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	ecx, edx
	lea	esi, DWORD PTR [esi+4]
	shr	ecx, 30					; 0000001eH
	xor	edx, ecx
	imul	edx, edi
	add	edx, eax
	inc	eax
	mov	DWORD PTR [esi-4], edx
	cmp	eax, 624				; 00000270H
	jl	SHORT $LL4@seed

; 1104 :         }
; 1105 : 
; 1106 :         this->_Idx = _Nx;

	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], 624			; 00000270H
	pop	ebx

; 1107 :     }

	ret	8
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
__Dxarg$ = 12						; size = 4
__Fxarg$ = 16						; size = 4
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>, COMDAT
; _this$ = ecx

; 1089 :         _Ty _Fxarg = (_Ty) 1812433253)
; 1090 :         : _Dxval(_Dxarg) { // construct with specified seed

	mov	eax, DWORD PTR __Dxarg$[esp-4]

; 1101 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

	mov	edx, DWORD PTR __X0$[esp-4]

; 1088 :     explicit mersenne_twister(_Ty _X0 = default_seed, _Ty _Dxarg = _WMSK,

	push	ebx

; 1089 :         _Ty _Fxarg = (_Ty) 1812433253)
; 1090 :         : _Dxval(_Dxarg) { // construct with specified seed

	mov	ebx, DWORD PTR __Fxarg$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+4996], eax
	lea	esi, DWORD PTR [edi+8]

; 1101 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

	mov	DWORD PTR [edi+4], edx

; 1089 :         _Ty _Fxarg = (_Ty) 1812433253)
; 1090 :         : _Dxval(_Dxarg) { // construct with specified seed

	mov	eax, 1
$LL6@mersenne_t:

; 1103 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	ecx, edx
	lea	esi, DWORD PTR [esi+4]
	shr	ecx, 30					; 0000001eH
	xor	edx, ecx
	imul	edx, ebx
	add	edx, eax
	inc	eax
	mov	DWORD PTR [esi-4], edx
	cmp	eax, 624				; 00000270H
	jl	SHORT $LL6@mersenne_t

; 1104 :         }
; 1105 : 
; 1106 :         this->_Idx = _Nx;

	mov	DWORD PTR [edi], 624			; 00000270H

; 1091 :         seed(_X0, _Fxarg);
; 1092 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	12					; 0000000cH
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$?0AAH$0A@@?$reference_wrapper@H@std@@QAE@AAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0AAH$0A@@?$reference_wrapper@H@std@@QAE@AAH@Z PROC	; std::reference_wrapper<int>::reference_wrapper<int><int &,0>, COMDAT
; _this$ = ecx

; 1687 :         _Ty& _Ref = _STD forward<_Uty>(_Val);
; 1688 :         _Ptr      = _STD addressof(_Ref);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1689 :     }

	mov	eax, ecx
	ret	4
??$?0AAH$0A@@?$reference_wrapper@H@std@@QAE@AAH@Z ENDP	; std::reference_wrapper<int>::reference_wrapper<int><int &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$?0AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@$0A@@?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@QAE@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@$0A@@?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@QAE@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@@Z PROC ; std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > ><std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,0>, COMDAT
; _this$ = ecx

; 1687 :         _Ty& _Ref = _STD forward<_Uty>(_Val);
; 1688 :         _Ptr      = _STD addressof(_Ref);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1689 :     }

	mov	eax, ecx
	ret	4
??$?0AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@$0A@@?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@QAE@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@@Z ENDP ; std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > ><std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAH@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAH@std@@YA$$QAHAAH@Z PROC			; std::move<int &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAH@std@@YA$$QAHAAH@Z ENDP			; std::move<int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1871 :     }

	mov	eax, ecx
	ret	4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; _this$ = ecx

; 1947 :         return this->_Myptr();

	mov	eax, DWORD PTR [ecx]

; 1955 :         pointer _Ans   = get();
; 1956 :         this->_Myptr() = pointer();

	mov	DWORD PTR [ecx], 0

; 1957 :         return _Ans;
; 1958 :     }

	ret	0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get, COMDAT
; _this$ = ecx

; 1947 :         return this->_Myptr();

	mov	eax, DWORD PTR [ecx]

; 1948 :     }

	ret	0
?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 1933 :         if (get() != pointer()) {

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN22@unique_ptr

; 1768 :         delete _Ptr;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN22@unique_ptr:

; 1934 :             this->get_deleter()(get());
; 1935 :         }
; 1936 :     }

	ret	0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr, COMDAT
; _this$ = ecx

; 1831 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1832 :     }

	ret	0
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr, COMDAT
; _this$ = ecx

; 1827 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1828 :     }

	ret	0
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter, COMDAT
; _this$ = ecx

; 1819 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1820 :     }

	ret	0
?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT
; _this$ = ecx

; 1767 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1768 :         delete _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Ptr$[esp-4], 1
	jmp	DWORD PTR [eax]
$LN3@operator:

; 1769 :     }

	ret	4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Storage_ptr$ = 12					; size = 4
___formal$ = 16						; size = 4
??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z PROC ; std::_Immortalize_impl<std::_Iostream_error_category>, COMDAT

; 420  :     _Iostream_error_category() noexcept { // default constructor

	mov	eax, DWORD PTR __Storage_ptr$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 421  :         _Addr = _Iostream_addr;

	mov	DWORD PTR [eax+4], 5

; 496  :     ::new (_Storage_ptr) _Ty();
; 497  :     return 1;

	mov	eax, 1

; 498  : }

	ret	12					; 0000000cH
??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ENDP ; std::_Immortalize_impl<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1025 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1026 :         _Left = _STD move(_Right);
; 1027 :     } else {
; 1028 :         (void) _Left; // TRANSITION, VSO#486357
; 1029 :         (void) _Right; // TRANSITION, VSO#486357
; 1030 :     }
; 1031 : }

	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$0M@@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0M@@std@@YAII@Z PROC			; std::_Get_size_of_n<12>, COMDAT

; 24   :     constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   :     size_t _Result                 = _Count * _Ty_size;

	mov	ecx, DWORD PTR __Count$[esp-4]

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	or	edx, -1
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 2
	cmp	ecx, 357913941				; 15555555H
	cmova	eax, edx

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);
; 29   :     }
; 30   : 
; 31   :     return _Result;
; 32   : }

	ret	0
??$_Get_size_of_n@$0M@@std@@YAII@Z ENDP			; std::_Get_size_of_n<12>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z
_TEXT	SEGMENT
__Old_size$1$ = -12					; size = 4
tv501 = -8						; size = 4
__New_ptr$1$ = -4					; size = 4
tv500 = 8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
tv499 = 16						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
tv502 = 24						; size = 4
_<_Args_2>$ = 24					; size = 1
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>, COMDAT
; _this$ = ecx

; 3809 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 3810 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3811 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3812 :         auto& _My_data            = _Get_data();
; 3813 :         const size_type _Old_size = _My_data._Mysize;
; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	push	edi
	mov	edi, DWORD PTR __Size_increase$[esp+16]
	mov	edx, DWORD PTR [esi+16]
	sub	eax, edx
	mov	DWORD PTR __Old_size$1$[esp+20], edx
	cmp	eax, edi
	jb	$LN104@Reallocate

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	push	ebx
	lea	ebx, DWORD PTR [edx+edi]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, ebx
	or	edi, 15					; 0000000fH
	push	ebp

; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	ebp, DWORD PTR [esi+20]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edi, ecx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN25@Reallocate

; 3770 :             return _Max;

	mov	edi, ecx
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, ebp
	shr	eax, 1
	sub	ecx, eax
	cmp	ebp, ecx
	jbe	SHORT $LN26@Reallocate

; 3775 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN24@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;
; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	movsx	ecx, BYTE PTR _<_Args_2>$[esp+24]
	mov	DWORD PTR tv502[esp+24], ecx
	mov	ecx, DWORD PTR __Old_size$1$[esp+28]
	mov	DWORD PTR [esi+16], ebx
	mov	ebx, DWORD PTR _<_Args_0>$[esp+24]
	sub	ecx, ebx
	inc	ecx
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR tv500[esp+24], ecx
	mov	ecx, DWORD PTR _<_Args_1>$[esp+24]
	lea	edi, DWORD PTR [eax+ebx]
	mov	DWORD PTR __New_ptr$1$[esp+28], eax
	add	ecx, edi
	mov	DWORD PTR tv501[esp+28], edi
	mov	DWORD PTR tv499[esp+24], ecx

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	push	ebx
	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN3@Reallocate

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR _<_Args_1>$[esp+36]
	push	DWORD PTR tv502[esp+40]
	push	DWORD PTR tv501[esp+48]
	call	_memset

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv500[esp+48]

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [edi+ebx]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	DWORD PTR tv499[esp+56]
	call	_memcpy

; 3829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [ebp+1]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 36					; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN80@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN77@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN80@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3837 :         return *this;

	mov	eax, DWORD PTR __New_ptr$1$[esp+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3837 :         return *this;

	mov	DWORD PTR [esi], eax
	mov	eax, esi
	pop	ebp
	pop	ebx
	pop	edi

; 3838 :     }

	pop	esi
	add	esp, 12					; 0000000cH
	ret	20					; 00000014H
$LN3@Reallocate:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR _<_Args_1>$[esp+36]
	push	DWORD PTR tv502[esp+40]
	push	edi
	call	_memset

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv500[esp+48]

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [ebx+esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	DWORD PTR tv499[esp+56]
	call	_memcpy

; 3837 :         return *this;

	mov	eax, DWORD PTR __New_ptr$1$[esp+64]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 36					; 00000024H

; 3837 :         return *this;

	mov	DWORD PTR [esi], eax
	mov	eax, esi
	pop	ebp
	pop	ebx
	pop	edi

; 3838 :     }

	pop	esi
	add	esp, 12					; 0000000cH
	ret	20					; 00000014H
$LN104@Reallocate:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN77@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN105@Reallocate:
$LN102@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Off$ = 20						; size = 4
__Count$ = 24						; size = 4
__Ch$ = 28						; size = 1
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z PROC ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator(), COMDAT
; _this$ = ecx

; 2817 :                 const size_type _Count, const _Elem _Ch) {

	push	ebx

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	ebx, DWORD PTR __Old_ptr$[esp]

; 2817 :                 const size_type _Count, const _Elem _Ch) {

	push	ebp

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	ebp, DWORD PTR __Off$[esp+4]

; 2817 :                 const size_type _Count, const _Elem _Ch) {

	push	esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[esp+8]

; 2817 :                 const size_type _Count, const _Elem _Ch) {

	push	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ebp
	push	ebx
	push	esi
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+24]

; 2818 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2819 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);

	lea	edi, DWORD PTR [esi+ebp]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	esi, DWORD PTR __Count$[esp+24]
	push	esi
	push	eax
	push	edi
	call	_memset

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	eax, DWORD PTR __Old_size$[esp+36]
	sub	eax, ebp
	inc	eax

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [ebx+ebp]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [edi+esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	call	_memcpy
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2821 :             },

	ret	24					; 00000018H
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z ENDP ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@HPAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@AAPAU31@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@HPAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@AAPAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<std::_List_node<int,void *> *,std::_List_node<int,void *> * &>, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@PAU?$_List_node@HPAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@QAPAU?$_List_node@HPAX@1@AAPAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::construct<std::_List_node<int,void *> *,std::_List_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@HPAX@std@@@std@@YAPAPAU?$_List_node@HPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@HPAX@std@@@std@@YAPAPAU?$_List_node@HPAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<int,void *> *>, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@PAU?$_List_node@HPAX@std@@@std@@YAPAPAU?$_List_node@HPAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<int> > >, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 99   :         : _Mybase(_Pnode, _Plist) { // construct with node pointer _Pnode
; 100  :     }

	mov	eax, ecx
	ret	8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<int> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1><std::allocator<int> const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	ret	8
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1><std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$_Construct_n_copies_of_ty@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct_n_copies_of_ty@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Construct_n_copies_of_ty<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 383  :     void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {

	push	esi

; 384  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 385  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 386  :         if (_Count != 0) {

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	je	SHORT $LN82@Construct_

; 1501 :         if (_Newcapacity > max_size()) {

	cmp	esi, 1073741823				; 3fffffffH
	ja	SHORT $LN92@Construct_

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	push	esi
	call	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocate
	mov	DWORD PTR [edi], eax

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;

	mov	DWORD PTR [edi+4], eax

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	ecx, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edi+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 281  :     for (; 0 < _Count; --_Count) {

	test	esi, esi
	je	SHORT $LN52@Construct_
	mov	edx, DWORD PTR __Val$[esp+4]
	npad	3
$LL53@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 143  :         ++_Last;

	add	eax, 4

; 281  :     for (; 0 < _Count; --_Count) {

	sub	esi, 1
	jne	SHORT $LL53@Construct_
$LN52@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 389  :             _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);

	mov	DWORD PTR [edi+4], eax
$LN82@Construct_:
	pop	edi

; 390  :             _Guard._Target = nullptr;
; 391  :         }
; 392  : 
; 393  :         _Proxy._Release();
; 394  :     }

	pop	esi
	ret	8
$LN92@Construct_:

; 1502 :             _Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Xlength
$LN90@Construct_:
	int	3
??$_Construct_n_copies_of_ty@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Construct_n_copies_of_ty<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1><std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	ret	8
??$?0ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1><std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >, COMDAT

; 1087 :                             // note that this is an optimization for debug mode codegen;
; 1088 :                             // in release mode the BE removes all of this
; 1089 :     using _Val = typename _Alloc::value_type;
; 1090 :     if
; 1091 :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Val>, _Uses_default_destroy<_Alloc, _Val*>>) {
; 1092 :             (void) _First;
; 1093 :             (void) _Last;
; 1094 :             (void) _Al;
; 1095 :         }
; 1096 :     else {
; 1097 :         for (; _First != _Last; ++_First) {
; 1098 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1099 :         }
; 1100 :     }
; 1101 : }

	ret	0
??$_Destroy_range@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0AAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 1087 :                             // note that this is an optimization for debug mode codegen;
; 1088 :                             // in release mode the BE removes all of this
; 1089 :     using _Val = typename _Alloc::value_type;
; 1090 :     if
; 1091 :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Val>, _Uses_default_destroy<_Alloc, _Val*>>) {
; 1092 :             (void) _First;
; 1093 :             (void) _Last;
; 1094 :             (void) _Al;
; 1095 :         }
; 1096 :     else {
; 1097 :         for (; _First != _Last; ++_First) {
; 1098 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1099 :         }
; 1100 :     }
; 1101 : }

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Pnavail
	mov	eax, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [eax]
	cdq

; 257  :     }

	ret	0
$LN3@Pnavail:

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	xor	eax, eax
	cdq

; 257  :     }

	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 251  :         --*_IPcount;

	mov	eax, DWORD PTR [ecx+48]
	dec	DWORD PTR [eax]

; 252  :         return (*_IPnext)++;

	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edx], ecx

; 253  :     }

	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 168  :         return xsputn(_Ptr, _Count);

	push	DWORD PTR __Count$[esp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Count$[esp]
	push	DWORD PTR __Ptr$[esp+4]
	mov	eax, DWORD PTR [eax+36]
	call	eax

; 169  :     }

	ret	12					; 0000000cH
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sputc
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	test	eax, eax
	jle	SHORT $LN3@sputc

; 251  :         --*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 252  :         return (*_IPnext)++;

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	al, BYTE PTR __Ch$[esp-4]
	mov	BYTE PTR [edx], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 164  :     }

	ret	4
$LN3@sputc:

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR __Ch$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	DWORD PTR __Ch$[esp-4], eax
	jmp	edx
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 121  :         return sync();

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+52]
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 188  :                                           // <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 189  : #if defined(_M_IX86) || defined(_M_X64)
; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	ecx, DWORD PTR __Bytes$[esp-4]
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@Deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, DWORD PTR __Ptr$[esp-4]
	add	ecx, 35					; 00000023H
	mov	edx, DWORD PTR [eax-4]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN13@Deallocate
	jmp	__invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 188  :                                           // <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 189  : #if defined(_M_IX86) || defined(_M_X64)
; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	edx, DWORD PTR __Ptr$[esp-4]
$LN13@Deallocate:

; 191  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 192  :     }
; 193  : #endif // defined(_M_IX86) || defined(_M_X64)
; 194  : 
; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	DWORD PTR __Bytes$[esp-4], ecx
	mov	DWORD PTR __Ptr$[esp-4], edx
	jmp	??3@YAXPAXI@Z				; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 172  : #if defined(_M_IX86) || defined(_M_X64)
; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	ecx, DWORD PTR __Bytes$[esp-4]
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN2@Allocate

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 93   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN11@Allocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 183  : }

	ret	0
$LN11@Allocate:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	jmp	__invalid_parameter_noinfo_noreturn
$LN2@Allocate:

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN3@Allocate

; 49   :         return ::operator new(_Bytes);

	mov	DWORD PTR __Bytes$[esp-4], ecx
	jmp	??2@YAPAXI@Z				; operator new
$LN3@Allocate:

; 179  :         return _Traits::_Allocate(_Bytes);
; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	eax, eax

; 183  : }

	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
tv450 = -4						; size = 4
__New_size$1$ = -4					; size = 4
__Old$1$ = 8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 3809 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ecx

; 3810 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3811 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3812 :         auto& _My_data            = _Get_data();
; 3813 :         const size_type _Old_size = _My_data._Mysize;
; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, DWORD PTR __Size_increase$[esp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	mov	ebx, DWORD PTR [esi+16]
	sub	eax, ebx
	cmp	eax, edx
	jb	$LN104@Reallocate

; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR [esi+20]
	add	edx, ebx
	push	edi

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, edx

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[esp+16], edx

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	edi, 15					; 0000000fH

; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[esp+12], eax

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edi, ecx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN25@Reallocate

; 3770 :             return _Max;

	mov	edi, ecx
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, eax
	shr	edx, 1
	sub	ecx, edx
	cmp	eax, ecx
	jbe	SHORT $LN26@Reallocate

; 3775 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN24@Reallocate:
	push	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	ebp, eax

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR [esi+20], edi
	mov	eax, DWORD PTR __New_size$1$[esp+20]
	mov	DWORD PTR [esi+16], eax

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR _<_Args_1>$[esp+16]
	lea	edi, DWORD PTR [ebx+ebp]
	add	eax, edi

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[esp+16], 16		; 00000010H
	mov	DWORD PTR tv450[esp+20], eax
	push	ebx
	jb	SHORT $LN3@Reallocate

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebp
	call	_memcpy
	push	DWORD PTR _<_Args_1>$[esp+28]
	lea	eax, DWORD PTR [ebx+ebp]
	push	DWORD PTR _<_Args_0>$[esp+32]
	push	eax
	call	_memcpy

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv450[esp+44]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H

; 3829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[esp+16]
	inc	ecx

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN80@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN77@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN80@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3837 :         return *this;

	mov	DWORD PTR [esi], ebp
	mov	eax, esi
	pop	ebp
	pop	edi
	pop	esi

; 3838 :     }

	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN3@Reallocate:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ebp
	call	_memcpy
	push	DWORD PTR _<_Args_1>$[esp+28]
	push	DWORD PTR _<_Args_0>$[esp+32]
	push	edi
	call	_memcpy

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv450[esp+44]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 3837 :         return *this;

	mov	eax, esi
	mov	DWORD PTR [esi], ebp
	pop	ebp
	pop	edi
	pop	esi

; 3838 :     }

	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN104@Reallocate:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN77@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN105@Reallocate:
$LN102@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$ = ecx

; 2618 :                 const size_type _Count) {

	push	esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[esp]

; 2618 :                 const size_type _Count) {

	push	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	edi, DWORD PTR __Old_size$[esp+4]
	push	edi
	push	DWORD PTR __Old_ptr$[esp+8]
	push	esi
	call	_memcpy

; 2619 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2620 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	add	edi, esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __Count$[esp+16]
	push	esi
	push	DWORD PTR __Ptr$[esp+20]
	push	edi
	call	_memcpy
	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi

; 2621 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2622 :             },

	ret	20					; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z
_TEXT	SEGMENT
tv489 = -4						; size = 4
__New_size$1$ = -4					; size = 4
__Old$1$ = 8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
tv491 = 20						; size = 4
_<_Args_1>$ = 20					; size = 1
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>, COMDAT
; _this$ = ecx

; 3809 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ecx

; 3810 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3811 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3812 :         auto& _My_data            = _Get_data();
; 3813 :         const size_type _Old_size = _My_data._Mysize;
; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, DWORD PTR __Size_increase$[esp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	mov	ebx, DWORD PTR [esi+16]
	sub	eax, ebx
	cmp	eax, edx
	jb	$LN104@Reallocate

; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR [esi+20]
	add	edx, ebx
	push	edi

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, edx

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[esp+16], edx

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	edi, 15					; 0000000fH

; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[esp+12], eax

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edi, ecx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN25@Reallocate

; 3770 :             return _Max;

	mov	edi, ecx
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, eax
	shr	edx, 1
	sub	ecx, edx
	cmp	eax, ecx
	jbe	SHORT $LN26@Reallocate

; 3775 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN24@Reallocate:
	push	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	ebp, eax

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR [esi+20], edi
	mov	eax, DWORD PTR __New_size$1$[esp+20]
	mov	DWORD PTR [esi+16], eax

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	movsx	eax, BYTE PTR _<_Args_1>$[esp+16]
	mov	DWORD PTR tv491[esp+16], eax
	lea	edi, DWORD PTR [ebx+ebp]
	mov	eax, DWORD PTR _<_Args_0>$[esp+16]
	add	eax, edi

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[esp+16], 16		; 00000010H
	mov	DWORD PTR tv489[esp+20], eax
	push	ebx
	jb	SHORT $LN3@Reallocate

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebp
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR _<_Args_0>$[esp+28]
	lea	eax, DWORD PTR [ebx+ebp]
	push	DWORD PTR tv491[esp+32]
	push	eax
	call	_memset

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv489[esp+44]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 24					; 00000018H

; 3829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[esp+16]
	inc	ecx

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN80@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN77@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN80@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3837 :         return *this;

	mov	DWORD PTR [esi], ebp
	mov	eax, esi
	pop	ebp
	pop	edi
	pop	esi

; 3838 :     }

	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN3@Reallocate:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ebp
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR _<_Args_0>$[esp+28]
	push	DWORD PTR tv491[esp+32]
	push	edi
	call	_memset

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv489[esp+44]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 3837 :         return *this;

	mov	eax, esi
	mov	DWORD PTR [esi], ebp
	pop	ebp
	pop	edi
	pop	esi

; 3838 :     }

	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN104@Reallocate:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN77@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN105@Reallocate:
$LN102@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Count$ = 20						; size = 4
__Ch$ = 24						; size = 1
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z PROC ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator(), COMDAT
; _this$ = ecx

; 2643 :                 const _Elem _Ch) {

	push	esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[esp]

; 2643 :                 const _Elem _Ch) {

	push	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	edi, DWORD PTR __Old_size$[esp+4]
	push	edi
	push	DWORD PTR __Old_ptr$[esp+8]
	push	esi
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+16]

; 2644 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2645 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	add	edi, esi

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	esi, DWORD PTR __Count$[esp+16]
	push	esi
	push	eax
	push	edi
	call	_memset
	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi

; 2646 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2647 :             },

	ret	20					; 00000014H
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z ENDP ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__New_ptr$1$ = 8					; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 3782 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebx

; 3783 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 3784 :         // _Fn(_New_ptr, _New_size, _Args...)
; 3785 :         if (_New_size > max_size()) {

	mov	ebx, DWORD PTR __New_size$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebx, 2147483647				; 7fffffffH
	ja	$LN92@Reallocate

; 3787 :         }
; 3788 : 
; 3789 :         auto& _My_data                = _Get_data();
; 3790 :         const size_type _Old_capacity = _My_data._Myres;

	push	ebp
	mov	ebp, DWORD PTR [edi+20]
	push	esi

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	esi, ebx
	or	esi, 15					; 0000000fH
	cmp	esi, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN25@Reallocate

; 3770 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, ebp
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	ebp, eax
	jbe	SHORT $LN26@Reallocate

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN24@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	mov	ecx, edi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
	push	DWORD PTR _<_Args_0>$[esp+16]

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	DWORD PTR __New_ptr$1$[esp+20], eax

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax

; 3794 :         _My_data._Orphan_all();
; 3795 :         _My_data._Mysize = _New_size;

	mov	DWORD PTR [edi+16], ebx

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR [edi+20], esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	call	_memcpy

; 343  :         _Left = _Right;

	mov	esi, DWORD PTR __New_ptr$1$[esp+24]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0

; 3797 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [ebp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN76@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN73@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN76@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3805 :         return *this;

	mov	DWORD PTR [edi], esi
	mov	eax, edi
	pop	esi
	pop	ebp
	pop	edi

; 3806 :     }

	pop	ebx
	ret	12					; 0000000cH
$LN73@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN93@Reallocate:
$LN92@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN90@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$ = ecx

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[esp]

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	edi, DWORD PTR __Count$[esp+4]
	push	edi
	push	DWORD PTR __Ptr$[esp+8]
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi

; 2697 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2698 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2699 :             },

	ret	12					; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z
_TEXT	SEGMENT
__New_ptr$1$ = 8					; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>, COMDAT
; _this$ = ecx

; 3782 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebx

; 3783 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 3784 :         // _Fn(_New_ptr, _New_size, _Args...)
; 3785 :         if (_New_size > max_size()) {

	mov	ebx, DWORD PTR __New_size$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebx, 2147483647				; 7fffffffH
	ja	$LN92@Reallocate

; 3787 :         }
; 3788 : 
; 3789 :         auto& _My_data                = _Get_data();
; 3790 :         const size_type _Old_capacity = _My_data._Myres;

	push	ebp
	mov	ebp, DWORD PTR [edi+20]
	push	esi

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	esi, ebx
	or	esi, 15					; 0000000fH
	cmp	esi, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN25@Reallocate

; 3770 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, ebp
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	ebp, eax
	jbe	SHORT $LN26@Reallocate

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN24@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	mov	ecx, edi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR _<_Args_0>$[esp+12]
	push	ebx
	push	ecx
	push	eax

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	DWORD PTR __New_ptr$1$[esp+24], eax

; 3794 :         _My_data._Orphan_all();
; 3795 :         _My_data._Mysize = _New_size;

	mov	DWORD PTR [edi+16], ebx

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR [edi+20], esi

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	call	_memset

; 343  :         _Left = _Right;

	mov	esi, DWORD PTR __New_ptr$1$[esp+24]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0

; 3797 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [ebp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN76@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN73@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN76@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3805 :         return *this;

	mov	DWORD PTR [edi], esi
	mov	eax, edi
	pop	esi
	pop	ebp
	pop	edi

; 3806 :     }

	pop	ebx
	ret	12					; 0000000cH
$LN73@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN93@Reallocate:
$LN92@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN90@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z PROC ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator(), COMDAT
; _this$ = ecx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp-4]

; 2718 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {

	push	esi

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	esi, DWORD PTR __New_ptr$[esp]

; 2718 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {

	push	edi

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	edi, DWORD PTR __Count$[esp+4]
	push	edi
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi

; 2719 :                 _Traits::assign(_New_ptr, _Count, _Ch);
; 2720 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2721 :             },

	ret	12					; 0000000cH
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z ENDP ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	cmovb	eax, ecx

; 29   : }

	ret	0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 824  :         _Ptr->~_Uty();
; 825  :     }

	ret	0
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$_Hash_representation@H@std@@YAIABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??$_Hash_representation@H@std@@YAIABH@Z PROC		; std::_Hash_representation<int>, COMDAT

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	edx, DWORD PTR __Keyval$[esp-4]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 1937 :         _Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619

; 1963 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
; 1964 : }

	ret	0
??$_Hash_representation@H@std@@YAIABH@Z ENDP		; std::_Hash_representation<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0AAU?$hash@H@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@H@1@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@H@1@$$QAU21@AAU?$equal_to@H@1@$$QAM@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
_<_Val2_1>$ = 20					; size = 4
_<_Val2_2>$ = 24					; size = 4
??$?0AAU?$hash@H@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@H@1@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@H@1@$$QAU21@AAU?$equal_to@H@1@$$QAM@Z PROC ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1><std::hash<int> &,std::_One_then_variadic_args_t,std::equal_to<int> &,float>, COMDAT
; _this$ = ecx

; 1533 :           _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR _<_Val2_2>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1534 :     }

	mov	eax, ecx
	ret	20					; 00000014H
??$?0AAU?$hash@H@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@H@1@M@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@H@1@$$QAU21@AAU?$equal_to@H@1@$$QAM@Z ENDP ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1><std::hash<int> &,std::_One_then_variadic_args_t,std::equal_to<int> &,float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0H@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0H@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> ><int>, COMDAT
; _this$ = ecx

; 921  :     }

	mov	eax, ecx
	ret	4
??$?0H@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> ><int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z PROC ; std::_List_node<int,void *>::_Freenode0<std::allocator<std::_List_node<int,void *> > >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	DWORD PTR __Ptr$[esp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 329  :     }

	ret	0
??$_Freenode0@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<int,void *>::_Freenode0<std::allocator<std::_List_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z PROC ; std::_List_node<int,void *>::_Free_non_head<std::allocator<std::_List_node<int,void *> > >, COMDAT

; 341  :         _Head->_Prev->_Next = nullptr;

	mov	ecx, DWORD PTR __Head$[esp-4]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], 0

; 342  : 
; 343  :         auto _Pnode = _Head->_Next;

	mov	eax, DWORD PTR [ecx]

; 344  :         for (_Nodeptr _Pnext; _Pnode != nullptr; _Pnode = _Pnext) {

	test	eax, eax
	je	SHORT $LN3@Free_non_h
	push	esi
$LL4@Free_non_h:

; 345  :             _Pnext = _Pnode->_Next;

	mov	esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 344  :         for (_Nodeptr _Pnext; _Pnode != nullptr; _Pnode = _Pnext) {

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL4@Free_non_h
	pop	esi
$LN3@Free_non_h:

; 346  :             _Freenode(_Al, _Pnode);
; 347  :         }
; 348  :     }

	ret	0
??$_Free_non_head@V?$allocator@U?$_List_node@HPAX@std@@@std@@@?$_List_node@HPAX@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<int,void *>::_Free_non_head<std::allocator<std::_List_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator!=, COMDAT
; _this$ = ecx

; 76   :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 77   :     }

	ret	4
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator==, COMDAT
; _this$ = ecx

; 72   :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 73   :     }

	ret	4
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 61   :         _Ptr = _Ptr->_Prev;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], eax

; 62   :         return *this;

	mov	eax, ecx

; 63   :     }

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 50   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 51   :         return *this;

	mov	eax, ecx

; 52   :     }

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBEABHXZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = ecx

; 42   :         return _Ptr->_Myval;

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 43   :     }

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBEABHXZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 38   :         this->_Adopt(_Plist);
; 39   :     }

	mov	eax, ecx
	ret	8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@HPAX@1@PBV?$_List_val@U?$_List_simple_types@H@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 33   :     _List_unchecked_const_iterator() : _Ptr() { // construct with null node pointer

	mov	DWORD PTR [ecx], 0

; 34   :     }

	mov	eax, ecx
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 157  :     virtual __CLR_OR_THIS_CALL ~numpunct() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 224  :         _CSTD free((void*) _Grouping);

	push	DWORD PTR [esi+8]

; 157  :     virtual __CLR_OR_THIS_CALL ~numpunct() noexcept { // destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@

; 224  :         _CSTD free((void*) _Grouping);

	call	_free

; 225  :         _CSTD free((void*) _Falsename);

	push	DWORD PTR [esi+16]
	call	_free

; 226  :         _CSTD free((void*) _Truename);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN12@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = ecx

; 223  :     void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 224  :         _CSTD free((void*) _Grouping);

	push	DWORD PTR [esi+8]
	call	_free

; 225  :         _CSTD free((void*) _Falsename);

	push	DWORD PTR [esi+16]
	call	_free

; 226  :         _CSTD free((void*) _Truename);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 12					; 0000000cH
	pop	esi

; 227  :     }

	ret	0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 219  :         return string_type(_Truename);

	mov	edx, DWORD PTR [ecx+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 218  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const { // return name for true

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 218  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const { // return name for true

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	npad	1
$LL33@do_truenam:

; 301  :         return __builtin_strlen(_First);

	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL33@do_truenam
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 219  :         return string_type(_Truename);

	pop	edi
	mov	eax, esi
	pop	esi

; 220  :     }

	ret	4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 215  :         return string_type(_Falsename);

	mov	edx, DWORD PTR [ecx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 214  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const { // return name for false

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 214  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const { // return name for false

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	npad	1
$LL33@do_falsena:

; 301  :         return __builtin_strlen(_First);

	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL33@do_falsena
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 215  :         return string_type(_Falsename);

	pop	edi
	mov	eax, esi
	pop	esi

; 216  :     }

	ret	4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 211  :         return string(_Grouping);

	mov	edx, DWORD PTR [ecx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 210  :     virtual string __CLR_OR_THIS_CALL do_grouping() const { // return grouping string

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 210  :     virtual string __CLR_OR_THIS_CALL do_grouping() const { // return grouping string

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	npad	1
$LL33@do_groupin:

; 301  :         return __builtin_strlen(_First);

	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL33@do_groupin
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 211  :         return string(_Grouping);

	pop	edi
	mov	eax, esi
	pop	esi

; 212  :     }

	ret	4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 207  :         return _Kseparator;

	mov	al, BYTE PTR [ecx+13]

; 208  :     }

	ret	0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 203  :         return _Dp;

	mov	al, BYTE PTR [ecx+12]

; 204  :     }

	ret	0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
$T1 = -44						; size = 44
$T2 = -44						; size = 44
__Lobj$ = 8						; size = 4
__Isdef$ = 12						; size = 1
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<char>::_Init, COMDAT
; _this$ = ecx

; 179  :     void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { // initialize from _Lobj

	sub	esp, 44					; 0000002cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 116  :         return localeconv();

	call	_localeconv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 180  :         const lconv* _Ptr      = _Lobj._Getlconv();

	mov	ebp, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	lea	eax, DWORD PTR $T2[esp+60]
	push	eax
	call	__Getcvt
	lea	eax, DWORD PTR $T1[esp+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 183  :         _Grouping  = nullptr;

	mov	DWORD PTR [ebx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 184  :         _Falsename = nullptr;

	mov	DWORD PTR [ebx+16], 0

; 185  :         _Truename  = nullptr;

	mov	DWORD PTR [ebx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	call	__Getcvt
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	esi, OFFSET ??_C@_00CNPNBAHC@@
	cmp	BYTE PTR __Isdef$[esp+56], 0
	jne	SHORT $LN6@Init
	mov	esi, DWORD PTR [ebp+8]
$LN6@Init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, esi
	lea	ecx, DWORD PTR [edi+1]
$LL64@Init:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL64@Init
	sub	edi, ecx
	inc	edi

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
	call	_calloc
	mov	edx, eax
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	edx, edx
	je	$LN63@Init

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	test	edi, edi
	je	SHORT $LN15@Init
	mov	ecx, edx
	sub	ecx, esi
$LL16@Init:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL16@Init
$LN15@Init:

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	DWORD PTR [ebx+8], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_05LAPONLG@false@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	SHORT $LN63@Init

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, esi
$LL25@Init:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [edx+esi-1], cl
	sub	edi, 1
	jne	SHORT $LL25@Init

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [ebx+16], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_04LOAJBDKD@true@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	SHORT $LN63@Init

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, esi
$LL33@Init:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [edx+esi-1], cl
	sub	edi, 1
	jne	SHORT $LL33@Init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	cmp	BYTE PTR __Isdef$[esp+56], 0
	mov	DWORD PTR [ebx+20], eax

; 191  :         _Guard._Target = nullptr;
; 192  : 
; 193  :         if (_Isdef) { // apply defaults for required facets

	je	SHORT $LN2@Init

; 200  :     }

	pop	edi
	pop	esi
	mov	BYTE PTR [ebx+12], 46			; 0000002eH
	mov	al, 44					; 0000002cH
	pop	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3514 :         if (_Target) {

	mov	BYTE PTR [ebx+13], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 200  :     }

	pop	ebx
	add	esp, 44					; 0000002cH
	ret	8
$LN2@Init:

; 170  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	eax, DWORD PTR [ebp]
	pop	edi

; 200  :     }

	pop	esi

; 170  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ebx+12], al

; 171  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	eax, DWORD PTR [ebp+4]

; 200  :     }

	pop	ebp

; 171  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	al, BYTE PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3514 :         if (_Target) {

	mov	BYTE PTR [ebx+13], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 200  :     }

	pop	ebx
	add	esp, 44					; 0000002cH
	ret	8
$LN63@Init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 578  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN65@Init:
	int	3
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<char>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 157  :     virtual __CLR_OR_THIS_CALL ~numpunct() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 224  :         _CSTD free((void*) _Grouping);

	push	DWORD PTR [esi+8]

; 157  :     virtual __CLR_OR_THIS_CALL ~numpunct() noexcept { // destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@

; 224  :         _CSTD free((void*) _Grouping);

	call	_free

; 225  :         _CSTD free((void*) _Falsename);

	push	DWORD PTR [esi+16]
	call	_free

; 226  :         _CSTD free((void*) _Truename);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 159  :     }

	ret	0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T1 = -144						; size = 4
$T2 = -140						; size = 52
$T3 = -88						; size = 44
$T4 = -44						; size = 44
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 149  :         const locale* _Ploc = nullptr) { // return locale category mask and construct standard facet

	sub	esp, 144				; 00000090H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Ppf$[esp+148]
	mov	DWORD PTR $T1[esp+152], 0
	push	esi
	mov	esi, DWORD PTR __Ploc$[esp+152]
	push	edi

; 150  :         if (_Ppf != nullptr && *_Ppf == nullptr) {

	test	ebp, ebp
	je	$LN6@Getcat
	cmp	DWORD PTR [ebp], 0
	jne	$LN6@Getcat

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	test	ebx, ebx
	je	$LN4@Getcat
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN9@Getcat
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN14@Getcat
$LN9@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN14@Getcat
	lea	eax, DWORD PTR [ecx+28]
$LN14@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	push	eax
	lea	ecx, DWORD PTR $T2[esp+164]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [ebx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 144  :         : locale::facet(_Refs) { // construct from specified locale

	mov	DWORD PTR [ebx], OFFSET ??_7?$numpunct@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 116  :         return localeconv();

	call	_localeconv

; 112  :         return ::_Getcvt();

	lea	eax, DWORD PTR $T3[esp+160]
	push	eax
	call	__Getcvt
	lea	eax, DWORD PTR $T4[esp+164]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 183  :         _Grouping  = nullptr;

	mov	DWORD PTR [ebx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 184  :         _Falsename = nullptr;

	mov	DWORD PTR [ebx+16], 0

; 185  :         _Truename  = nullptr;

	mov	DWORD PTR [ebx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	call	__Getcvt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	1
	call	_calloc
	add	esp, 16					; 00000010H

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	$LN85@Getcat

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 6

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	BYTE PTR [eax], 0

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	DWORD PTR [ebx+8], eax

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_05LAPONLG@false@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	SHORT $LN85@Getcat

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, esi
	npad	6
$LL45@Getcat:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [edx+esi-1], cl
	sub	edi, 1
	jne	SHORT $LL45@Getcat

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [ebx+16], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_04LOAJBDKD@true@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	SHORT $LN85@Getcat

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, esi
	npad	2
$LL53@Getcat:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [edx+esi-1], cl
	sub	edi, 1
	jne	SHORT $LL53@Getcat
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [ebx+20], eax

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	lea	eax, DWORD PTR [edi+1]

; 195  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);

	mov	WORD PTR [ebx+12], 11310		; 00002c2eH

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	eax, DWORD PTR $T1[esp+160]
	xor	ebx, ebx
$LN5@Getcat:
	mov	DWORD PTR [ebp], ebx
	test	al, 1
	je	SHORT $LN6@Getcat
	lea	ecx, DWORD PTR $T2[esp+160]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN6@Getcat:

; 154  :     }

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 4
	pop	ebx
	add	esp, 144				; 00000090H
	ret	0
$LN85@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 578  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN86@Getcat:
	int	3
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<char>::_Getcat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
$T1 = -44						; size = 44
$T2 = -44						; size = 44
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
__Isdef$ = 16						; size = 1
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	eax, DWORD PTR __Refs$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 143  :     numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)

	sub	esp, 44					; 0000002cH
	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [ebx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 144  :         : locale::facet(_Refs) { // construct from specified locale

	mov	DWORD PTR [ebx], OFFSET ??_7?$numpunct@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 116  :         return localeconv();

	call	_localeconv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 180  :         const lconv* _Ptr      = _Lobj._Getlconv();

	mov	ebp, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	lea	eax, DWORD PTR $T2[esp+60]
	push	eax
	call	__Getcvt
	lea	eax, DWORD PTR $T1[esp+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 183  :         _Grouping  = nullptr;

	mov	DWORD PTR [ebx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 184  :         _Falsename = nullptr;

	mov	DWORD PTR [ebx+16], 0

; 185  :         _Truename  = nullptr;

	mov	DWORD PTR [ebx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	call	__Getcvt
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	esi, OFFSET ??_C@_00CNPNBAHC@@
	cmp	BYTE PTR __Isdef$[esp+56], 0
	jne	SHORT $LN12@numpunct
	mov	esi, DWORD PTR [ebp+8]
$LN12@numpunct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, esi
	lea	ecx, DWORD PTR [edi+1]
	npad	3
$LL71@numpunct:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL71@numpunct
	sub	edi, ecx
	inc	edi

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
	call	_calloc
	mov	edx, eax
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	edx, edx
	je	$LN70@numpunct

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	test	edi, edi
	je	SHORT $LN21@numpunct
	mov	ecx, edx
	sub	ecx, esi
$LL22@numpunct:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL22@numpunct
$LN21@numpunct:

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	DWORD PTR [ebx+8], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_05LAPONLG@false@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	mov	edx, eax
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	edx, edx
	je	SHORT $LN70@numpunct

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	ecx, edx
	sub	ecx, esi
$LL31@numpunct:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL31@numpunct

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [ebx+16], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_04LOAJBDKD@true@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	mov	edx, eax
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	edx, edx
	je	SHORT $LN70@numpunct

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	ecx, edx
	sub	ecx, esi
$LL39@numpunct:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL39@numpunct
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	cmp	BYTE PTR __Isdef$[esp+56], 0
	mov	DWORD PTR [ebx+20], edx

; 191  :         _Guard._Target = nullptr;
; 192  : 
; 193  :         if (_Isdef) { // apply defaults for required facets

	je	SHORT $LN8@numpunct
	pop	edi

; 194  :             // _Grouping = _Maklocstr("", static_cast<char *>(nullptr), _Cvt);
; 195  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);
; 196  :             _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);

	mov	al, 44					; 0000002cH
	mov	BYTE PTR [ebx+12], 46			; 0000002eH

; 146  :     }

	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3514 :         if (_Target) {

	mov	BYTE PTR [ebx+13], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 146  :     }

	mov	eax, ebx
	pop	ebp
	pop	ebx
	add	esp, 44					; 0000002cH
	ret	12					; 0000000cH
$LN8@numpunct:

; 170  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	ecx, DWORD PTR [ebp]
	pop	edi

; 146  :     }

	pop	esi

; 170  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [ebx+12], cl

; 171  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	ecx, DWORD PTR [ebp+4]

; 146  :     }

	pop	ebp

; 171  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	al, BYTE PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3514 :         if (_Target) {

	mov	BYTE PTR [ebx+13], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 146  :     }

	mov	eax, ebx
	pop	ebx
	add	esp, 44					; 0000002cH
	ret	12					; 0000000cH
$LN70@numpunct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 578  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN72@numpunct:
	int	3
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<char>::numpunct<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx

; 130  :         return do_truename();

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[esp-4]
	call	DWORD PTR [edx+28]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 131  :     }

	ret	4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx

; 126  :         return do_falsename();

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[esp-4]
	call	DWORD PTR [edx+24]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 127  :     }

	ret	4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 122  :         return do_grouping();

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[esp-4]
	call	DWORD PTR [edx+20]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 123  :     }

	ret	4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 118  :         return do_thousands_sep();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	jmp	eax
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 114  :         return do_decimal_point();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	jmp	eax
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T1 = -152						; size = 4
__Lock$2 = -152						; size = 4
__Lock$3 = -148						; size = 4
__Loc$GSCopy$1$ = -144					; size = 4
$T4 = -140						; size = 52
$T5 = -88						; size = 44
$T6 = -44						; size = 44
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 434  : { // get facet reference from locale

	sub	esp, 152				; 00000098H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Loc$[esp+160]

; 435  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	lea	ecx, DWORD PTR __Lock$2[esp+164]
	push	edi
	xor	ebx, ebx
	mov	DWORD PTR __Loc$GSCopy$1$[esp+168], esi
	push	ebx
	mov	DWORD PTR $T1[esp+172], ebx
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	mov	edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id

; 436  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	ebp, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	test	edi, edi
	jne	SHORT $LN9@use_facet

; 100  :                 _BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$3[esp+172]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 101  :                 if (_Id == 0) {

	cmp	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, ebx ; std::numpunct<char>::id
	jne	SHORT $LN10@use_facet

; 102  :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, eax ; std::numpunct<char>::id
$LN10@use_facet:

; 103  :                 }
; 104  :                 _END_LOCK()

	lea	ecx, DWORD PTR __Lock$3[esp+168]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
$LN9@use_facet:

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN17@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	test	esi, esi
	jne	$LN135@use_facet
	jmp	SHORT $LN150@use_facet
$LN17@use_facet:

; 380  :     }
; 381  : 
; 382  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	esi, esi
$LN150@use_facet:

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [ecx+20], bl
	je	SHORT $LN15@use_facet

; 385  :             return _Facptr; // found facet or not transparent
; 386  :         } else { // look in current locale
; 387  :             locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 388  :             return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] // get from current locale

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN151@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 437  : 
; 438  :     const size_t _Id         = _Facet::id;
; 439  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 440  : 
; 441  :     if (_Pf == nullptr) {

	test	esi, esi
	jne	$LN135@use_facet
$LN151@use_facet:

; 442  :         if (_Psave != nullptr) {

	test	ebp, ebp
	je	SHORT $LN3@use_facet

; 443  :             _Pf = _Psave; // lazy facet already allocated

	mov	esi, ebp

; 444  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	jmp	$LN135@use_facet
$LN3@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	$LN24@use_facet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	ecx, DWORD PTR __Loc$GSCopy$1$[esp+168]
	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	jne	SHORT $LN29@use_facet
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN34@use_facet
$LN29@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN34@use_facet
	lea	eax, DWORD PTR [ecx+28]
$LN34@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	push	eax
	lea	ecx, DWORD PTR $T4[esp+172]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 144  :         : locale::facet(_Refs) { // construct from specified locale

	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 116  :         return localeconv();

	call	_localeconv

; 112  :         return ::_Getcvt();

	lea	eax, DWORD PTR $T5[esp+168]
	push	eax
	call	__Getcvt
	lea	eax, DWORD PTR $T6[esp+172]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 183  :         _Grouping  = nullptr;

	mov	DWORD PTR [esi+8], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 184  :         _Falsename = nullptr;

	mov	DWORD PTR [esi+16], ebx

; 185  :         _Truename  = nullptr;

	mov	DWORD PTR [esi+20], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	call	__Getcvt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	1
	call	_calloc
	add	esp, 16					; 00000010H

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	$LN152@use_facet

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	BYTE PTR [eax], bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	edi, OFFSET ??_C@_05LAPONLG@false@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	ebx, 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	DWORD PTR [esi+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	ebx
	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	$LN152@use_facet

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, edi
	npad	6
$LL65@use_facet:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+1]
	mov	BYTE PTR [edx+edi-1], cl
	sub	ebx, 1
	jne	SHORT $LL65@use_facet

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	ebx, 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [esi+16], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	edi, OFFSET ??_C@_04LOAJBDKD@true@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	SHORT $LN152@use_facet

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, edi
	npad	2
$LL73@use_facet:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+1]
	mov	BYTE PTR [edx+edi-1], cl
	sub	ebx, 1
	jne	SHORT $LL73@use_facet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [esi+20], eax

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	mov	ebx, 1

; 195  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);

	mov	WORD PTR [esi+12], 11310		; 00002c2eH

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	jmp	SHORT $LN25@use_facet
$LN24@use_facet:
	xor	esi, esi
$LN25@use_facet:
	test	bl, 1
	je	SHORT $LN26@use_facet
	lea	ecx, DWORD PTR $T4[esp+168]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN26@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 457  :             _Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 458  : #endif // defined(_M_CEE)
; 459  : 
; 460  :             _Pfmod->_Incref();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [edx+4]

; 461  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<char> >::_Psave
$LN135@use_facet:

; 462  :             _Pf                       = _Psave;
; 463  : 
; 464  :             (void) _Psave_guard.release();
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$2[esp+168]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 152				; 00000098H
	ret	0
$LN152@use_facet:

; 578  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN153@use_facet:
	int	3
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = ecx

; 583  :         return _Failed;

	mov	al, BYTE PTR [ecx]

; 584  :     }

	ret	0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 575  :         return *this;

	mov	eax, ecx

; 576  :     }

	ret	0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 571  :         return *this;

	mov	eax, ecx

; 572  :     }

	ret	0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 1
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = ecx

; 562  :     ostreambuf_iterator& operator=(_Elem _Right) { // store element and increment

	push	esi
	mov	esi, ecx

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN3@operator

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	test	eax, eax
	jle	SHORT $LN7@operator

; 251  :         --*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 252  :         return (*_IPnext)++;

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	al, BYTE PTR __Right$[esp]
	mov	BYTE PTR [edx], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	jmp	SHORT $LN8@operator
$LN7@operator:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR __Right$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	push	eax
	call	edx
$LN8@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	jne	SHORT $LN24@operator
$LN3@operator:

; 564  :             _Failed = true;

	mov	BYTE PTR [esi], 1
$LN24@operator:

; 565  :         }
; 566  : 
; 567  :         return *this;
; 568  :     }

	mov	eax, esi
	pop	esi
	ret	4
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 555  :         : _Failed(false), _Strbuf(_Sb) { // construct from stream buffer _Sb

	mov	eax, DWORD PTR __Sb$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 556  :     }

	mov	eax, ecx
	mov	BYTE PTR [ecx], 0
	ret	4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN10@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 1
__Count$ = 28						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1507 :     _OutIt __CLRCALL_OR_CDECL _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { // put _Count * _Ch to _Dest

	push	esi

; 1508 :         for (; 0 < _Count; --_Count, (void) ++_Dest) {

	mov	esi, DWORD PTR __Dest$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Count$[esp+4]
	test	edi, edi
	je	SHORT $LN3@Rep
	push	ebx
	mov	bl, BYTE PTR __Ch$[esp+8]
$LL4@Rep:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	test	esi, esi
	je	SHORT $LN12@Rep

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@Rep
	mov	ecx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [ecx]

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	test	eax, eax
	jle	SHORT $LN16@Rep

; 251  :         --*_IPcount;

	dec	eax
	mov	DWORD PTR [ecx], eax

; 252  :         return (*_IPnext)++;

	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	BYTE PTR [edx], bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	jmp	SHORT $LN17@Rep
$LN16@Rep:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	edx, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	push	eax
	call	edx
$LN17@Rep:

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	mov	esi, DWORD PTR __Dest$[esp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	jne	SHORT $LN2@Rep
$LN12@Rep:

; 564  :             _Failed = true;

	mov	BYTE PTR __Dest$[esp+8], 1
$LN2@Rep:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1508 :         for (; 0 < _Count; --_Count, (void) ++_Dest) {

	sub	edi, 1
	jne	SHORT $LL4@Rep
	pop	ebx
$LN3@Rep:

; 1509 :             *_Dest = _Ch;
; 1510 :         }
; 1511 : 
; 1512 :         return _Dest;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 1513 :     }

	ret	0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Ch$1$ = 28						; size = 1
__Count$ = 28						; size = 4
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1499 :         _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { // put [_Ptr, _Ptr + _Count) to _Dest

	push	esi

; 1500 :         for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {

	mov	esi, DWORD PTR __Dest$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Count$[esp+4]
	test	edi, edi
	je	SHORT $LN3@Put
	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp+8]
$LL4@Put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	test	esi, esi
	je	SHORT $LN12@Put

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	eax, DWORD PTR [esi+32]

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	mov	cl, BYTE PTR [ebx]
	mov	BYTE PTR __Ch$1$[esp+8], cl

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@Put
	mov	edx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [edx]

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	test	eax, eax
	jle	SHORT $LN16@Put

; 251  :         --*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 252  :         return (*_IPnext)++;

	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	al, BYTE PTR __Ch$1$[esp+8]
	mov	BYTE PTR [edx], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	jmp	SHORT $LN17@Put
$LN16@Put:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	ecx, esi
	push	eax
	call	edx
$LN17@Put:

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	mov	esi, DWORD PTR __Dest$[esp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	jne	SHORT $LN2@Put
$LN12@Put:

; 564  :             _Failed = true;

	mov	BYTE PTR __Dest$[esp+8], 1
$LN2@Put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1500 :         for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {

	inc	ebx
	sub	edi, 1
	jne	SHORT $LL4@Put
	pop	ebx
$LN3@Put:

; 1501 :             *_Dest = *_Ptr;
; 1502 :         }
; 1503 : 
; 1504 :         return _Dest;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 1505 :     }

	ret	0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
__Kseparator$1$ = -89					; size = 1
__Prefix$1$ = -88					; size = 4
__Pg$1$ = -84						; size = 4
__Ctype_fac$1$ = -84					; size = 4
__Count$GSCopy$2$ = -80					; size = 4
tv1357 = -80						; size = 4
$T1 = -80						; size = 8
$T2 = -80						; size = 8
$T3 = -80						; size = 8
__Iosbase$GSCopy$1$ = -72				; size = 4
__Old_capacity$1$ = -68					; size = 4
$T4 = -68						; size = 8
$T5 = -68						; size = 8
$T6 = -68						; size = 8
$T7 = -68						; size = 8
$T8 = -68						; size = 8
tv1366 = -60						; size = 4
___$ReturnUdt$GSCopy$1$ = -56				; size = 4
__Groupstring$ = -52					; size = 24
__Grouping$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1451 :         size_t _Count) const { // put formatted integer to _Dest

	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+92], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+88]
	mov	edx, DWORD PTR __Iosbase$[esp+88]
	push	ebx
	mov	ebx, DWORD PTR __Count$[esp+92]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+96], eax
	mov	DWORD PTR __Iosbase$GSCopy$1$[esp+96], edx
	push	ebp
	mov	ebp, DWORD PTR __Buf$[esp+96]
	push	esi
	push	edi

; 1452 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

	test	ebx, ebx
	je	SHORT $LN14@Iput
	mov	al, BYTE PTR [ebp]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN13@Iput
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN14@Iput
$LN13@Iput:
	mov	edi, 1
	jmp	SHORT $LN377@Iput
$LN14@Iput:
	xor	edi, edi
$LN377@Iput:

; 1453 :         if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1454 :             && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

	mov	eax, DWORD PTR [edx+20]
	and	eax, 3584				; 00000e00H
	mov	DWORD PTR __Prefix$1$[esp+108], edi
	cmp	eax, 2048				; 00000800H
	jne	SHORT $LN4@Iput
	lea	eax, DWORD PTR [edi+2]
	cmp	eax, ebx
	ja	SHORT $LN4@Iput
	cmp	BYTE PTR [edi+ebp], 48			; 00000030H
	jne	SHORT $LN4@Iput
	mov	cl, BYTE PTR [edi+ebp+1]
	cmp	cl, 120					; 00000078H
	je	SHORT $LN5@Iput
	cmp	cl, 88					; 00000058H
	jne	SHORT $LN4@Iput
$LN5@Iput:

; 1455 :             _Prefix += 2;

	mov	edi, eax
	mov	DWORD PTR __Prefix$1$[esp+108], edi
$LN4@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR [edx+48]
	mov	esi, DWORD PTR [eax+4]

; 272  :         _Ptr->_Incref();

	mov	ecx, esi
	mov	DWORD PTR $T3[esp+112], esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1458 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T3[esp+108]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$1$[esp+108], eax
	test	esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	je	SHORT $LN27@Iput

; 360  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN27@Iput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN27@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1459 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

	push	0
	push	ebx
	lea	ecx, DWORD PTR __Groupstring$[esp+116]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	mov	ecx, DWORD PTR __Ctype_fac$1$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1460 :         _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	lea	eax, DWORD PTR [ebx+ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebp
	call	DWORD PTR [edx+28]

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	edx, DWORD PTR __Iosbase$GSCopy$1$[esp+108]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[esp+112], ecx

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1462 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T2[esp+108]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	mov	ecx, DWORD PTR $T2[esp+116]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1462 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	add	esp, 4
	mov	ebp, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	test	ecx, ecx
	je	SHORT $LN51@Iput

; 360  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN51@Iput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN51@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 122  :         return do_grouping();

	mov	eax, DWORD PTR [ebp]
	lea	ecx, DWORD PTR __Grouping$[esp+108]
	push	ecx
	mov	ecx, ebp
	call	DWORD PTR [eax+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Grouping$[esp+128], 16	; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	esi, DWORD PTR __Grouping$[esp+108]

; 2024 :         if (_Large_string_engaged()) {

	cmovae	esi, DWORD PTR __Grouping$[esp+108]
	mov	DWORD PTR __Pg$1$[esp+108], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1465 :         if (*_Pg != CHAR_MAX && '\0' < *_Pg) { // grouping specified, add thousands separators

	mov	al, BYTE PTR [esi]
	cmp	al, 127					; 0000007fH
	je	$LN375@Iput
	test	al, al
	jle	$LN375@Iput

; 118  :         return do_thousands_sep();

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 1466 :             const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	BYTE PTR __Kseparator$1$[esp+108], al

; 1467 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && (size_t) *_Pg < _Count - _Prefix) { // insert thousands separator

	mov	al, BYTE PTR [esi]
	cmp	al, 127					; 0000007fH
	je	$LN375@Iput
	mov	ebp, DWORD PTR __Groupstring$[esp+108]
$LL2@Iput:
	test	al, al
	jle	$LN3@Iput
	movsx	ecx, al
	mov	eax, ebx
	sub	eax, edi
	cmp	ecx, eax
	jae	$LN3@Iput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2036 :         if (_Mysize < _Off) {

	mov	edi, DWORD PTR __Groupstring$[esp+124]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1468 :                 _Count -= *_Pg;

	sub	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2036 :         if (_Mysize < _Off) {

	cmp	edi, ebx
	jb	$LN369@Iput

; 2805 :         const size_type _Old_size = _My_data._Mysize;

	mov	ecx, DWORD PTR __Groupstring$[esp+128]
	mov	eax, ecx
	sub	eax, edi
	mov	DWORD PTR __Old_capacity$1$[esp+108], ecx

; 2806 :         if (_Count <= _My_data._Myres - _Old_size) {

	cmp	eax, 1
	jb	SHORT $LN71@Iput

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2807 :             _My_data._Mysize        = _Old_size + _Count;

	lea	eax, DWORD PTR [edi+1]

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	esi, DWORD PTR __Groupstring$[esp+108]

; 2807 :             _My_data._Mysize        = _Old_size + _Count;

	mov	DWORD PTR __Groupstring$[esp+124], eax

; 2015 :         if (_Large_string_engaged()) {

	cmovae	esi, ebp

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	sub	edi, ebx

; 2809 :             _Elem* const _Insert_at = _Old_ptr + _Off;

	add	esi, ebx

; 2810 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	edi

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	edi
	push	esi

; 2810 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	lea	eax, DWORD PTR [esi+1]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	eax
	call	_memmove

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Kseparator$1$[esp+120]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [esi], cl

; 2812 :             return *this;

	mov	ebp, DWORD PTR __Groupstring$[esp+108]
	jmp	$LN95@Iput
$LN71@Iput:

; 3813 :         const size_type _Old_size = _My_data._Mysize;

	mov	eax, 2147483647				; 7fffffffH
	sub	eax, edi

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	cmp	eax, 1
	jb	$LN370@Iput

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	esi, DWORD PTR [edi+1]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN116@Iput

; 3770 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN115@Iput
$LN116@Iput:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN117@Iput

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN115@Iput
$LN117@Iput:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN115@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	push	eax
	lea	ecx, DWORD PTR __Groupstring$[esp+112]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	ebp, eax

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR __Groupstring$[esp+128], esi
	lea	eax, DWORD PTR [edi+1]

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	sub	edi, ebx
	mov	DWORD PTR __Groupstring$[esp+124], eax
	movsx	eax, BYTE PTR __Kseparator$1$[esp+108]
	mov	DWORD PTR tv1366[esp+108], eax
	lea	esi, DWORD PTR [edi+1]

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	edi, DWORD PTR __Old_capacity$1$[esp+108]
	mov	DWORD PTR tv1357[esp+108], esi
	push	ebx
	cmp	edi, 16					; 00000010H
	jb	SHORT $LN94@Iput

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR __Groupstring$[esp+112]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ebp
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	cl, BYTE PTR tv1366[esp+120]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv1357[esp+120]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [ebx+esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	lea	eax, DWORD PTR [ebp+1]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	BYTE PTR [ebx+ebp], cl

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	eax, ebx
	push	eax
	call	_memcpy

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	inc	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edi, 4096				; 00001000H
	jb	SHORT $LN171@Iput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [esi-4]
	add	edi, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	$LN352@Iput

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, ecx
$LN171@Iput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edi
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3832 :         } else {

	jmp	SHORT $LN378@Iput
$LN94@Iput:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	lea	eax, DWORD PTR __Groupstring$[esp+112]
	push	eax
	push	ebp
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	cl, BYTE PTR tv1366[esp+120]
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR __Groupstring$[esp+120]
	add	eax, ebx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	BYTE PTR [ebx+ebp], cl

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	eax
	lea	eax, DWORD PTR [ebp+1]
	add	eax, ebx
	push	eax
	call	_memcpy
	add	esp, 24					; 00000018H
$LN378@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1470 :                 if ('\0' < _Pg[1]) {

	mov	DWORD PTR __Groupstring$[esp+108], ebp
$LN95@Iput:
	mov	esi, DWORD PTR __Pg$1$[esp+108]
	cmp	BYTE PTR [esi+1], 0
	lea	eax, DWORD PTR [esi+1]
	mov	edi, DWORD PTR __Prefix$1$[esp+108]
	cmovg	esi, eax
	mov	DWORD PTR __Pg$1$[esp+108], esi
	mov	al, BYTE PTR [esi]
	cmp	al, 127					; 0000007fH
	jne	$LL2@Iput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	jmp	SHORT $LN3@Iput
$LN375@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1467 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && (size_t) *_Pg < _Count - _Prefix) { // insert thousands separator

	mov	ebp, DWORD PTR __Groupstring$[esp+108]
$LN3@Iput:

; 1478 :             _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Count ? 0 : (size_t) _Iosbase.width() - _Count;

	mov	ecx, DWORD PTR __Iosbase$GSCopy$1$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3264 :         return _Get_data()._Mysize;

	mov	eax, DWORD PTR __Groupstring$[esp+124]
	mov	DWORD PTR __Count$GSCopy$2$[esp+108], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1478 :             _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Count ? 0 : (size_t) _Iosbase.width() - _Count;

	cmp	DWORD PTR [ecx+36], 0
	mov	esi, DWORD PTR [ecx+32]
	jl	SHORT $LN16@Iput
	jg	SHORT $LN374@Iput
	test	esi, esi
	je	SHORT $LN16@Iput
$LN374@Iput:
	cmp	esi, eax
	jbe	SHORT $LN16@Iput
	sub	esi, eax
	jmp	SHORT $LN17@Iput
$LN16@Iput:
	xor	esi, esi
$LN17@Iput:

; 1479 : 
; 1480 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [ecx+20]

; 1481 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

	mov	ebx, DWORD PTR _this$[esp+104]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN10@Iput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN373@Iput

; 1482 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	DWORD PTR __Fill$[esp+108]
	lea	eax, DWORD PTR $T8[esp+116]
	push	DWORD PTR __Dest$[esp+116]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	ebx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1483 :             _Fillcount = 0;

	xor	esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+152], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1484 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edi
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+132], edx
	mov	ecx, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+136]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1484 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T7[esp+148]
	mov	DWORD PTR __Dest$[esp+148], ecx
	push	eax
	push	ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 48					; 00000030H
	jmp	$LN11@Iput
$LN373@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1486 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1486 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[esp+116]
	lea	eax, DWORD PTR $T6[esp+120]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1487 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	DWORD PTR __Fill$[esp+132]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+136], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	DWORD PTR __Dest$[esp+144], eax
	lea	eax, DWORD PTR $T5[esp+144]
	push	ecx
	push	eax
	push	ebx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 48					; 00000030H

; 1488 :             _Fillcount = 0;

	xor	esi, esi

; 1489 :         } else {

	jmp	SHORT $LN11@Iput
$LN10@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1490 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1490 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[esp+116]
	lea	eax, DWORD PTR $T4[esp+120]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
$LN11@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3177 :         auto& _My_data = _Get_data();

	mov	edx, DWORD PTR [eax]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1493 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	ebp, DWORD PTR __Count$GSCopy$2$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3177 :         auto& _My_data = _Get_data();

	mov	DWORD PTR __Dest$[esp+104], edx
	mov	ecx, DWORD PTR [eax+4]

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1493 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	sub	ebp, edi
	push	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3181 :         return _My_data._Myptr()[_Off];

	add	eax, edi
	mov	DWORD PTR __Dest$[esp+112], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1493 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T1[esp+124]
	push	eax
	push	ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	edx, DWORD PTR __Iosbase$GSCopy$1$[esp+132]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1495 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	push	esi
	push	DWORD PTR __Fill$[esp+132]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+140]
	mov	DWORD PTR __Dest$[esp+136], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
	push	esi
	push	ebx
	mov	DWORD PTR __Dest$[esp+156], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR [edx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1495 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Grouping$[esp+176]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1495 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	add	esp, 48					; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN302@Iput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Grouping$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN301@Iput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN352@Iput
$LN301@Iput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN302@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Groupstring$[esp+128]

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR __Grouping$[esp+124], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR __Grouping$[esp+128], 15	; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR __Grouping$[esp+108], 0

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN356@Iput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN355@Iput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN352@Iput
$LN355@Iput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN356@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1496 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+108]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 92					; 0000005cH
	ret	0
$LN370@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN369@Iput:

; 2037 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN352@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN376@Iput:
	int	3
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1423 :         char* _Ptr = _Fmt;
; 1424 :         *_Ptr++    = '%';
; 1425 : 
; 1426 :         if (_Flags & ios_base::showpos) {

	mov	eax, DWORD PTR __Flags$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Fmt$[esp]
	push	edi
	mov	BYTE PTR [esi], 37			; 00000025H
	lea	ecx, DWORD PTR [esi+1]
	test	al, 32					; 00000020H
	je	SHORT $LN2@Ifmt

; 1427 :             *_Ptr++ = '+';

	mov	BYTE PTR [ecx], 43			; 0000002bH
	inc	ecx
$LN2@Ifmt:

; 1428 :         }
; 1429 : 
; 1430 :         if (_Flags & ios_base::showbase) {

	test	al, 8
	je	SHORT $LN3@Ifmt

; 1431 :             *_Ptr++ = '#';

	mov	BYTE PTR [ecx], 35			; 00000023H
	inc	ecx
$LN3@Ifmt:

; 1432 :         }
; 1433 : 
; 1434 :         if (_Spec[0] != 'L') {

	mov	edi, DWORD PTR __Spec$[esp+4]
	lea	edx, DWORD PTR [ecx+1]
	push	ebx
	mov	bl, BYTE PTR [edi]
	cmp	bl, 76					; 0000004cH
	je	SHORT $LN4@Ifmt

; 1435 :             *_Ptr++ = _Spec[0]; // qualifier

	mov	BYTE PTR [ecx], bl

; 1436 :         } else { // change L to I64

	jmp	SHORT $LN5@Ifmt
$LN4@Ifmt:

; 1437 :             *_Ptr++ = 'I';

	mov	BYTE PTR [ecx], 73			; 00000049H

; 1438 :             *_Ptr++ = '6';

	mov	WORD PTR [edx], 13366			; 00003436H

; 1439 :             *_Ptr++ = '4';

	add	edx, 2
$LN5@Ifmt:

; 1440 :         }
; 1441 : 
; 1442 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

	mov	ecx, eax
	and	ecx, 3584				; 00000e00H
	pop	ebx

; 1443 :         *_Ptr++                       = _Basefield == ios_base::oct ? 'o'

	cmp	ecx, 1024				; 00000400H
	jne	SHORT $LN9@Ifmt
	mov	al, 111					; 0000006fH
	mov	BYTE PTR [edx], al

; 1444 :                                               : _Basefield != ios_base::hex ? _Spec[1] // 'd' or 'u'
; 1445 :                                                                             : _Flags & ios_base::uppercase ? 'X' : 'x';
; 1446 :         *_Ptr = '\0';
; 1447 :         return _Fmt;

	mov	eax, esi
	pop	edi
	mov	BYTE PTR [edx+1], 0
	pop	esi

; 1448 :     }

	ret	0
$LN9@Ifmt:

; 1443 :         *_Ptr++                       = _Basefield == ios_base::oct ? 'o'

	cmp	ecx, 2048				; 00000800H
	je	SHORT $LN7@Ifmt
	mov	al, BYTE PTR [edi+1]
	mov	BYTE PTR [edx], al

; 1444 :                                               : _Basefield != ios_base::hex ? _Spec[1] // 'd' or 'u'
; 1445 :                                                                             : _Flags & ios_base::uppercase ? 'X' : 'x';
; 1446 :         *_Ptr = '\0';
; 1447 :         return _Fmt;

	mov	eax, esi
	pop	edi
	mov	BYTE PTR [edx+1], 0
	pop	esi

; 1448 :     }

	ret	0
$LN7@Ifmt:

; 1443 :         *_Ptr++                       = _Basefield == ios_base::oct ? 'o'

	shl	al, 3
	not	al
	and	al, 32					; 00000020H
	or	al, 88					; 00000058H
	mov	BYTE PTR [edx], al

; 1444 :                                               : _Basefield != ios_base::hex ? _Spec[1] // 'd' or 'u'
; 1445 :                                                                             : _Flags & ios_base::uppercase ? 'X' : 'x';
; 1446 :         *_Ptr = '\0';
; 1447 :         return _Fmt;

	mov	eax, esi
	pop	edi
	mov	BYTE PTR [edx+1], 0
	pop	esi

; 1448 :     }

	ret	0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
_TEXT	SEGMENT
__Kseparator$1$ = -89					; size = 1
__Prefix$1$ = -88					; size = 4
tv1440 = -84						; size = 4
$T1 = -84						; size = 8
$T2 = -84						; size = 8
$T3 = -84						; size = 8
$T4 = -84						; size = 8
$T5 = -84						; size = 8
$T6 = -84						; size = 8
$T7 = -84						; size = 8
$T8 = -84						; size = 8
__Dp$ = -76						; size = 2
__Iosbase$GSCopy$1$ = -72				; size = 4
tv1448 = -68						; size = 4
__Eoff$1$ = -68						; size = 4
__Pg$1$ = -64						; size = 4
__Ctype_fac$1$ = -64					; size = 4
__Old_capacity$1$ = -60					; size = 4
___$ReturnUdt$GSCopy$1$ = -56				; size = 4
__Groupstring$ = -52					; size = 24
__Grouping$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1361 :         size_t _Count) const { // put formatted floating-point to _Dest

	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+92], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+88]
	mov	edx, DWORD PTR __Iosbase$[esp+88]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Count$[esp+100]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+104], eax
	mov	DWORD PTR __Iosbase$GSCopy$1$[esp+104], edx
	push	edi
	mov	edi, DWORD PTR __Buf$[esp+104]

; 1362 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

	test	esi, esi
	je	SHORT $LN16@Fput
	mov	al, BYTE PTR [edi]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN15@Fput
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN16@Fput
$LN15@Fput:
	mov	ecx, 1
	jmp	SHORT $LN421@Fput
$LN16@Fput:
	xor	ecx, ecx
$LN421@Fput:

; 1363 :         const char* _Exps;
; 1364 :         if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat) {

	mov	eax, DWORD PTR [edx+20]
	and	eax, 12288				; 00003000H
	mov	DWORD PTR __Prefix$1$[esp+108], ecx
	cmp	eax, 12288				; 00003000H
	je	SHORT $LN4@Fput

; 1365 :             _Exps = "eE";

	mov	edx, OFFSET ??_C@_02MDKMJEGG@eE@

; 1366 :         } else { // correct for hexadecimal floating-point

	jmp	SHORT $LN6@Fput
$LN4@Fput:

; 1367 :             _Exps = "pP";
; 1368 :             if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1369 :                 && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

	lea	eax, DWORD PTR [ecx+2]
	mov	edx, OFFSET ??_C@_02OOPEBDOJ@pP@
	cmp	eax, esi
	ja	SHORT $LN6@Fput
	cmp	BYTE PTR [edi+ecx], 48			; 00000030H
	jne	SHORT $LN6@Fput
	mov	cl, BYTE PTR [edi+ecx+1]
	cmp	cl, 120					; 00000078H
	je	SHORT $LN7@Fput
	cmp	cl, 88					; 00000058H
	jne	SHORT $LN6@Fput
$LN7@Fput:

; 1370 :                 _Prefix += 2;

	mov	DWORD PTR __Prefix$1$[esp+108], eax
$LN6@Fput:

; 1371 :             }
; 1372 :         }
; 1373 :         const size_t _Eoff = _CSTD strcspn(&_Buf[0], _Exps); // find exponent

	push	edx
	push	edi
	call	_strcspn
	mov	DWORD PTR __Eoff$1$[esp+116], eax

; 1374 :         char _Dp[2]        = {"."};

	mov	eax, 46					; 0000002eH
	mov	WORD PTR __Dp$[esp+116], ax

; 1375 :         _Dp[0]             = _CSTD localeconv()->decimal_point[0];

	call	_localeconv
	mov	eax, DWORD PTR [eax]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR __Dp$[esp+116], al

; 1376 :         const size_t _Poff = _CSTD strcspn(&_Buf[0], &_Dp[0]); // find decimal point

	lea	eax, DWORD PTR __Dp$[esp+116]
	push	eax
	push	edi
	call	_strcspn
	mov	ebx, eax
	add	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[esp+108]
	mov	eax, DWORD PTR [eax+48]
	mov	ebp, DWORD PTR [eax+4]

; 272  :         _Ptr->_Incref();

	mov	ecx, ebp
	mov	DWORD PTR $T8[esp+112], ebp
	mov	eax, DWORD PTR [ebp]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1378 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T8[esp+108]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$1$[esp+108], eax
	test	ebp, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	je	SHORT $LN29@Fput

; 360  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN29@Fput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN29@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1379 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

	push	0
	push	esi
	lea	ecx, DWORD PTR __Groupstring$[esp+116]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	mov	ecx, DWORD PTR __Ctype_fac$1$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1380 :         _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	DWORD PTR [edx+28]

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	ecx, DWORD PTR __Iosbase$GSCopy$1$[esp+108]
	mov	eax, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T7[esp+112], ecx

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1382 :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T7[esp+108]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	mov	ecx, DWORD PTR $T7[esp+116]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1382 :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	add	esp, 4
	mov	edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	test	ecx, ecx
	je	SHORT $LN53@Fput

; 360  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN53@Fput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN53@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 122  :         return do_grouping();

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR __Grouping$[esp+108]
	push	ecx
	mov	ecx, edi
	call	DWORD PTR [eax+20]

; 118  :         return do_thousands_sep();

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 1383 :         const string _Grouping  = _Punct_fac.grouping();
; 1384 :         const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	BYTE PTR __Kseparator$1$[esp+108], al

; 1385 : 
; 1386 :         if (_Poff != _Count) {

	cmp	ebx, esi
	je	SHORT $LN422@Fput

; 114  :         return do_decimal_point();

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	mov	eax, DWORD PTR [eax+12]
	call	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1387 :             _Groupstring[_Poff] = _Punct_fac.decimal_point();

	mov	cl, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1390 :         size_t _Off     = _Poff == _Count ? _Eoff : _Poff;

	cmp	ebx, esi
	mov	BYTE PTR [eax+ebx], cl
$LN422@Fput:
	cmove	ebx, DWORD PTR __Eoff$1$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Grouping$[esp+108]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Grouping$[esp+128], 16	; 00000010H

; 2024 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Grouping$[esp+108]
	mov	DWORD PTR __Pg$1$[esp+108], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1392 :         while (*_Pg != CHAR_MAX && '\0' < *_Pg && (size_t) *_Pg < _Off - _Prefix) { // add thousands separator

	mov	al, BYTE PTR [eax]
	cmp	al, 127					; 0000007fH
	je	$LN419@Fput
	npad	10
$LL2@Fput:
	mov	edx, DWORD PTR __Prefix$1$[esp+108]
	test	al, al
	jle	$LN417@Fput
	movsx	ecx, al
	mov	eax, ebx
	sub	eax, edx
	cmp	ecx, eax
	jae	$LN417@Fput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2036 :         if (_Mysize < _Off) {

	mov	edi, DWORD PTR __Groupstring$[esp+124]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1393 :             _Groupstring.insert(_Off -= *_Pg, (size_t) 1, _Kseparator);

	sub	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2036 :         if (_Mysize < _Off) {

	cmp	edi, ebx
	jb	$LN411@Fput

; 2805 :         const size_type _Old_size = _My_data._Mysize;

	mov	esi, DWORD PTR __Groupstring$[esp+128]
	mov	eax, esi
	sub	eax, edi
	mov	DWORD PTR __Old_capacity$1$[esp+108], esi

; 2806 :         if (_Count <= _My_data._Myres - _Old_size) {

	cmp	eax, 1
	jb	SHORT $LN88@Fput

; 2807 :             _My_data._Mysize        = _Old_size + _Count;

	lea	eax, DWORD PTR [edi+1]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	esi, 16					; 00000010H

; 2807 :             _My_data._Mysize        = _Old_size + _Count;

	mov	DWORD PTR __Groupstring$[esp+124], eax

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	sub	edi, ebx

; 2810 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	edi

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	edi

; 2809 :             _Elem* const _Insert_at = _Old_ptr + _Off;

	lea	esi, DWORD PTR [eax+ebx]

; 2810 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	lea	eax, DWORD PTR [esi+1]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	esi
	push	eax
	call	_memmove

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Kseparator$1$[esp+120]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [esi], cl

; 2812 :             return *this;

	jmp	$LN112@Fput
$LN88@Fput:

; 3813 :         const size_type _Old_size = _My_data._Mysize;

	mov	eax, 2147483647				; 7fffffffH
	sub	eax, edi

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	cmp	eax, 1
	jb	$LN412@Fput

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	ebp, DWORD PTR [edi+1]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	ebp, 15					; 0000000fH
	cmp	ebp, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN133@Fput

; 3770 :             return _Max;

	mov	ebp, 2147483647				; 7fffffffH
	jmp	SHORT $LN132@Fput
$LN133@Fput:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, esi
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	jbe	SHORT $LN134@Fput

; 3775 :             return _Max;

	mov	ebp, 2147483647				; 7fffffffH
	jmp	SHORT $LN132@Fput
$LN134@Fput:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [esi+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	ebp, eax
	cmovb	ebp, eax
$LN132@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [ebp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN165@Fput

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	eax, ecx
	mov	ecx, -1
	cmovbe	eax, ecx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN394@Fput

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN164@Fput
$LN165@Fput:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN166@Fput

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 179  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN164@Fput
$LN166@Fput:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	esi, esi
$LN164@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3824 :         _My_data._Mysize      = _New_size;

	lea	eax, DWORD PTR [edi+1]

; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR __Groupstring$[esp+128], ebp

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	ebp, DWORD PTR __Old_capacity$1$[esp+108]
	sub	edi, ebx
	mov	DWORD PTR __Groupstring$[esp+124], eax
	inc	edi
	movsx	eax, BYTE PTR __Kseparator$1$[esp+108]
	mov	DWORD PTR tv1448[esp+108], eax
	mov	DWORD PTR tv1440[esp+108], edi
	push	ebx
	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN111@Fput

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR __Groupstring$[esp+112]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	esi
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	cl, BYTE PTR tv1448[esp+120]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv1440[esp+120]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [edi+ebx]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	lea	eax, DWORD PTR [ebx+1]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	BYTE PTR [esi+ebx], cl

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	eax, esi
	push	eax
	call	_memcpy

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	inc	ebp

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebp, 4096				; 00001000H
	jb	SHORT $LN214@Fput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [edi-4]
	add	ebp, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	$LN394@Fput

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, ecx
$LN214@Fput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ebp
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3832 :         } else {

	jmp	SHORT $LN423@Fput
$LN111@Fput:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	lea	eax, DWORD PTR __Groupstring$[esp+112]
	push	eax
	push	esi
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	cl, BYTE PTR tv1448[esp+120]
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR __Groupstring$[esp+120]
	add	eax, ebx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	BYTE PTR [esi+ebx], cl

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	eax
	lea	eax, DWORD PTR [ebx+1]
	add	eax, esi
	push	eax
	call	_memcpy
	add	esp, 24					; 00000018H
$LN423@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1394 :             if ('\0' < _Pg[1]) {

	mov	DWORD PTR __Groupstring$[esp+108], esi
$LN112@Fput:
	mov	ecx, DWORD PTR __Pg$1$[esp+108]
	cmp	BYTE PTR [ecx+1], 0
	lea	eax, DWORD PTR [ecx+1]
	cmovg	ecx, eax
	mov	DWORD PTR __Pg$1$[esp+108], ecx
	mov	al, BYTE PTR [ecx]
	cmp	al, 127					; 0000007fH
	jne	$LL2@Fput
$LN419@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3264 :         return _Get_data()._Mysize;

	mov	edx, DWORD PTR __Prefix$1$[esp+108]
$LN417@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1401 :             _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Count ? 0 : (size_t) _Iosbase.width() - _Count;

	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3264 :         return _Get_data()._Mysize;

	mov	ebx, DWORD PTR __Groupstring$[esp+124]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1401 :             _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Count ? 0 : (size_t) _Iosbase.width() - _Count;

	cmp	DWORD PTR [eax+36], 0
	mov	esi, DWORD PTR [eax+32]
	jl	SHORT $LN18@Fput
	jg	SHORT $LN416@Fput
	test	esi, esi
	je	SHORT $LN18@Fput
$LN416@Fput:
	cmp	esi, ebx
	jbe	SHORT $LN18@Fput
	sub	esi, ebx
	jmp	SHORT $LN19@Fput
$LN18@Fput:
	xor	esi, esi
$LN19@Fput:

; 1402 : 
; 1403 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [eax+20]

; 1404 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

	mov	ebp, DWORD PTR __Fill$[esp+104]
	and	eax, 448				; 000001c0H
	mov	edi, DWORD PTR _this$[esp+104]
	cmp	eax, 64					; 00000040H
	je	$LN12@Fput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN415@Fput

; 1405 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	ebp
	push	DWORD PTR __Dest$[esp+116]
	lea	eax, DWORD PTR $T6[esp+120]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	edi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1407 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	ebp, DWORD PTR __Prefix$1$[esp+132]
	xor	esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+152], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1407 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	ebp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+132], edx
	mov	ecx, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+136]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1407 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T5[esp+148]
	mov	DWORD PTR __Dest$[esp+148], ecx
	push	eax
	push	edi
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 48					; 00000030H
	jmp	$LN13@Fput
$LN415@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1409 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+112]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1409 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[esp+116]
	lea	eax, DWORD PTR $T4[esp+120]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	edi
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1410 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	ebp
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+136], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	DWORD PTR __Dest$[esp+144], eax
	lea	eax, DWORD PTR $T3[esp+144]
	push	ecx
	push	eax
	push	edi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 48					; 00000030H

; 1411 :             _Fillcount = 0;

	xor	esi, esi

; 1412 :         } else {

	jmp	SHORT $LN424@Fput
$LN12@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1413 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+112]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1413 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[esp+116]
	lea	eax, DWORD PTR $T2[esp+120]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	edi
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
$LN424@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3177 :         auto& _My_data = _Get_data();

	mov	ebp, DWORD PTR __Prefix$1$[esp+108]
$LN13@Fput:
	mov	edx, DWORD PTR [eax]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 3177 :         auto& _My_data = _Get_data();

	mov	DWORD PTR __Dest$[esp+104], edx
	mov	ecx, DWORD PTR [eax+4]

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1416 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	sub	ebx, ebp
	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3181 :         return _My_data._Myptr()[_Off];

	add	eax, ebp
	mov	DWORD PTR __Dest$[esp+112], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1416 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T1[esp+124]
	push	eax
	push	edi
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	edx, DWORD PTR __Iosbase$GSCopy$1$[esp+132]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1418 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	push	esi
	push	DWORD PTR __Fill$[esp+132]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+140]
	mov	DWORD PTR __Dest$[esp+136], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __Dest$[esp+156], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR [edx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1418 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Grouping$[esp+176]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1418 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	add	esp, 48					; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN344@Fput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Grouping$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN343@Fput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN394@Fput
$LN343@Fput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN344@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Groupstring$[esp+128]

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR __Grouping$[esp+124], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR __Grouping$[esp+128], 15	; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR __Grouping$[esp+108], 0

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN398@Fput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN397@Fput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN394@Fput
$LN397@Fput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN398@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1419 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+108]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 92					; 0000005cH
	ret	0
$LN412@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN411@Fput:

; 2037 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN394@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN420@Fput:
	int	3
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1326 :         char* _Ptr = _Fmt;
; 1327 :         *_Ptr++    = '%';
; 1328 : 
; 1329 :         if (_Flags & ios_base::showpos) {

	mov	edx, DWORD PTR __Flags$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Fmt$[esp]
	mov	BYTE PTR [esi], 37			; 00000025H
	lea	eax, DWORD PTR [esi+1]
	test	dl, 32					; 00000020H
	je	SHORT $LN2@Ffmt

; 1330 :             *_Ptr++ = '+';

	mov	BYTE PTR [eax], 43			; 0000002bH
	inc	eax
$LN2@Ffmt:

; 1331 :         }
; 1332 : 
; 1333 :         if (_Flags & ios_base::showpoint) {

	test	dl, 16					; 00000010H
	je	SHORT $LN3@Ffmt

; 1334 :             *_Ptr++ = '#';

	mov	BYTE PTR [eax], 35			; 00000023H
	inc	eax
$LN3@Ffmt:

; 1335 :         }
; 1336 : 
; 1337 :         *_Ptr++ = '.';
; 1338 :         *_Ptr++ = '*'; // for precision argument
; 1339 :         if (_Spec != '\0') {

	mov	cl, BYTE PTR __Spec$[esp]
	mov	WORD PTR [eax], 10798			; 00002a2eH
	add	eax, 2
	test	cl, cl
	je	SHORT $LN4@Ffmt

; 1340 :             *_Ptr++ = _Spec; // 'L' qualifier for long double only

	mov	BYTE PTR [eax], cl
	inc	eax
$LN4@Ffmt:

; 1341 :         }
; 1342 : 
; 1343 :         ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

	mov	ecx, edx
	and	ecx, 12288				; 00003000H

; 1344 :         if (_Flags & ios_base::uppercase) {

	test	dl, 4
	je	SHORT $LN5@Ffmt

; 1345 :             *_Ptr++ = _Ffl == ios_base::fixed

	cmp	ecx, 8192				; 00002000H
	je	SHORT $LN16@Ffmt
	cmp	ecx, 12288				; 00003000H
	jne	SHORT $LN8@Ffmt
	mov	cl, 65					; 00000041H

; 1351 :                           ? 'f'
; 1352 :                           : _Ffl == ios_base::hexfloat ? 'a' // added with TR1
; 1353 :                                                        : _Ffl == ios_base::scientific ? 'e' : 'g'; // specifier
; 1354 :         }
; 1355 : 
; 1356 :         *_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1357 :         return _Fmt;

	mov	eax, esi
	pop	esi

; 1358 :     }

	ret	0
$LN8@Ffmt:

; 1345 :             *_Ptr++ = _Ffl == ios_base::fixed

	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx*2+69]

; 1351 :                           ? 'f'
; 1352 :                           : _Ffl == ios_base::hexfloat ? 'a' // added with TR1
; 1353 :                                                        : _Ffl == ios_base::scientific ? 'e' : 'g'; // specifier
; 1354 :         }
; 1355 : 
; 1356 :         *_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1357 :         return _Fmt;

	mov	eax, esi
	pop	esi

; 1358 :     }

	ret	0
$LN5@Ffmt:

; 1346 :                           ? 'f'
; 1347 :                           : _Ffl == ios_base::hexfloat ? 'A' // added with TR1
; 1348 :                                                        : _Ffl == ios_base::scientific ? 'E' : 'G'; // specifier
; 1349 :         } else {
; 1350 :             *_Ptr++ = _Ffl == ios_base::fixed

	cmp	ecx, 8192				; 00002000H
	jne	SHORT $LN14@Ffmt
$LN16@Ffmt:

; 1351 :                           ? 'f'
; 1352 :                           : _Ffl == ios_base::hexfloat ? 'a' // added with TR1
; 1353 :                                                        : _Ffl == ios_base::scientific ? 'e' : 'g'; // specifier
; 1354 :         }
; 1355 : 
; 1356 :         *_Ptr = '\0';

	mov	cl, 102					; 00000066H
	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1357 :         return _Fmt;

	mov	eax, esi
	pop	esi

; 1358 :     }

	ret	0
$LN14@Ffmt:

; 1346 :                           ? 'f'
; 1347 :                           : _Ffl == ios_base::hexfloat ? 'A' // added with TR1
; 1348 :                                                        : _Ffl == ios_base::scientific ? 'E' : 'G'; // specifier
; 1349 :         } else {
; 1350 :             *_Ptr++ = _Ffl == ios_base::fixed

	cmp	ecx, 12288				; 00003000H
	jne	SHORT $LN12@Ffmt
	mov	cl, 97					; 00000061H

; 1351 :                           ? 'f'
; 1352 :                           : _Ffl == ios_base::hexfloat ? 'a' // added with TR1
; 1353 :                                                        : _Ffl == ios_base::scientific ? 'e' : 'g'; // specifier
; 1354 :         }
; 1355 : 
; 1356 :         *_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1357 :         return _Fmt;

	mov	eax, esi
	pop	esi

; 1358 :     }

	ret	0
$LN12@Ffmt:

; 1346 :                           ? 'f'
; 1347 :                           : _Ffl == ios_base::hexfloat ? 'A' // added with TR1
; 1348 :                                                        : _Ffl == ios_base::scientific ? 'E' : 'G'; // specifier
; 1349 :         } else {
; 1350 :             *_Ptr++ = _Ffl == ios_base::fixed

	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx*2+101]

; 1351 :                           ? 'f'
; 1352 :                           : _Ffl == ios_base::hexfloat ? 'a' // added with TR1
; 1353 :                                                        : _Ffl == ios_base::scientific ? 'e' : 'g'; // specifier
; 1354 :         }
; 1355 : 
; 1356 :         *_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1357 :         return _Fmt;

	mov	eax, esi
	pop	esi

; 1358 :     }

	ret	0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1316 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest

	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+68], eax
	mov	eax, DWORD PTR __Val$[esp+64]
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+68]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+72]
	push	edi

; 1317 :         char _Buf[2 * _MAX_INT_DIG];
; 1318 : 
; 1319 :         return _Iput(

	push	eax
	push	OFFSET ??_C@_02BBAHNLBA@?$CFp@
	lea	eax, DWORD PTR __Buf$[esp+88]
	mov	edi, ecx
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+100]
	push	eax
	push	DWORD PTR __Fill$[esp+100]
	push	esi
	push	DWORD PTR __Dest$[esp+112]
	push	DWORD PTR __Dest$[esp+112]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1320 :             _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
; 1321 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+128]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 68					; 00000044H
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
__Precision$ = -52					; size = 8
__Ptwo$1 = -48						; size = 4
___$ReturnUdt$GSCopy$1$ = -44				; size = 4
_this$GSCopy$1$ = -40					; size = 4
__Buf$ = -36						; size = 24
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1296 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest

	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+52], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+48]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Iosbase$[esp+56]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+60], eax
	mov	DWORD PTR _this$GSCopy$1$[esp+60], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR __Buf$[esp+76], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1299 :         bool _Isfixed         = (_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed;

	mov	eax, DWORD PTR [edi+20]

; 1300 :         streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); // desired precision

	mov	ecx, DWORD PTR [edi+28]
	and	eax, 12288				; 00003000H
	mov	esi, DWORD PTR [edi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR __Buf$[esp+80], 15		; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR __Buf$[esp+60], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1300 :         streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); // desired precision

	test	ecx, ecx
	jg	SHORT $LN4@do_put
	jl	SHORT $LN127@do_put
	test	esi, esi
	jne	SHORT $LN4@do_put
$LN127@do_put:
	cmp	eax, 8192				; 00002000H
	je	SHORT $LN4@do_put
	mov	esi, 6
	xor	ecx, ecx
$LN4@do_put:
	mov	DWORD PTR __Precision$[esp+64], ecx

; 1301 :         size_t _Bufsize       = (size_t) _Precision;

	mov	ecx, esi

; 1302 :         if (_Isfixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format

	cmp	eax, 8192				; 00002000H
	jne	SHORT $LN2@do_put
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 843  :         return fabs((double)_X);

	movsd	xmm1, QWORD PTR __Val$[esp+56]
	movaps	xmm0, xmm1
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1302 :         if (_Isfixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format

	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 864  :         return frexp((double)_X, _Y);

	lea	eax, DWORD PTR __Ptwo$1[esp+60]
	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	call	_frexp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1305 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	eax, DWORD PTR __Ptwo$1[esp+72]
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 864  :         return frexp((double)_X, _Y);

	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1305 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	cdq
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 864  :         return frexp((double)_X, _Y);

	fstp	ST(0)
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1305 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	xor	eax, edx
	sub	eax, edx
	imul	ecx, eax, 30103
	mov	eax, 351843721				; 14f8b589H
	imul	ecx
	sar	edx, 13					; 0000000dH
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	ecx, esi
$LN2@do_put:

; 1306 :         }
; 1307 : 
; 1308 :         _Buf.resize(_Bufsize + 50); // add fudge factor

	lea	eax, DWORD PTR [ecx+50]
	push	0
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+68]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1309 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	push	DWORD PTR [edi+20]
	lea	eax, DWORD PTR __Fmt$[esp+64]
	push	76					; 0000004cH
	push	eax
	push	DWORD PTR _this$GSCopy$1$[esp+72]
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Buf$[esp+96], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR __Buf$[esp+76]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1309 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	movsd	xmm0, QWORD PTR __Val$[esp+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	cmovae	ecx, DWORD PTR __Buf$[esp+76]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1309 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	add	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	esi
	push	eax
	push	DWORD PTR __Buf$[esp+92]
	push	ecx
	call	_sprintf_s
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Buf$[esp+104], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR __Buf$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1312 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	cmovae	ecx, DWORD PTR __Buf$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1312 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	push	eax
	push	ecx
	push	DWORD PTR __Fill$[esp+88]
	push	edi
	push	DWORD PTR __Dest$[esp+100]
	push	DWORD PTR __Dest$[esp+100]
	push	esi
	push	DWORD PTR _this$GSCopy$1$[esp+112]
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Buf$[esp+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1312 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	add	esp, 56					; 00000038H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN114@do_put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Buf$[esp+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN113@do_put

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN130@do_put
$LN113@do_put:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN114@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1313 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+60]
	mov	eax, esi
	pop	edi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 52					; 00000034H
	ret	28					; 0000001cH
$LN130@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN128@do_put:
	int	3
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
__Precision$ = -52					; size = 8
__Ptwo$1 = -48						; size = 4
___$ReturnUdt$GSCopy$1$ = -44				; size = 4
_this$GSCopy$1$ = -40					; size = 4
__Buf$ = -36						; size = 24
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1276 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+52], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+48]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Iosbase$[esp+56]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+60], eax
	mov	DWORD PTR _this$GSCopy$1$[esp+60], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR __Buf$[esp+76], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1279 :         bool _Isfixed         = (_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed;

	mov	eax, DWORD PTR [edi+20]

; 1280 :         streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); // desired precision

	mov	ecx, DWORD PTR [edi+28]
	and	eax, 12288				; 00003000H
	mov	esi, DWORD PTR [edi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR __Buf$[esp+80], 15		; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR __Buf$[esp+60], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1280 :         streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); // desired precision

	test	ecx, ecx
	jg	SHORT $LN4@do_put
	jl	SHORT $LN123@do_put
	test	esi, esi
	jne	SHORT $LN4@do_put
$LN123@do_put:
	cmp	eax, 8192				; 00002000H
	je	SHORT $LN4@do_put
	mov	esi, 6
	xor	ecx, ecx
$LN4@do_put:
	mov	DWORD PTR __Precision$[esp+64], ecx

; 1281 :         size_t _Bufsize       = (size_t) _Precision;

	mov	ecx, esi

; 1282 :         if (_Isfixed && 1e10 < _CSTD fabs(_Val)) { // f or F format

	cmp	eax, 8192				; 00002000H
	jne	SHORT $LN2@do_put
	movsd	xmm1, QWORD PTR __Val$[esp+56]
	movaps	xmm0, xmm1
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put

; 1283 :             int _Ptwo;
; 1284 :             (void) _CSTD frexp(_Val, &_Ptwo);

	lea	eax, DWORD PTR __Ptwo$1[esp+60]
	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	call	_frexp

; 1285 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	eax, DWORD PTR __Ptwo$1[esp+72]
	add	esp, 12					; 0000000cH
	cdq
	fstp	ST(0)
	xor	eax, edx
	sub	eax, edx
	imul	ecx, eax, 30103
	mov	eax, 351843721				; 14f8b589H
	imul	ecx
	sar	edx, 13					; 0000000dH
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	ecx, esi
$LN2@do_put:

; 1286 :         }
; 1287 : 
; 1288 :         _Buf.resize(_Bufsize + 50); // add fudge factor

	lea	eax, DWORD PTR [ecx+50]
	push	0
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+68]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1289 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	push	DWORD PTR [edi+20]
	lea	eax, DWORD PTR __Fmt$[esp+64]
	push	0
	push	eax
	push	DWORD PTR _this$GSCopy$1$[esp+72]
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Buf$[esp+96], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR __Buf$[esp+76]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1289 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	movsd	xmm0, QWORD PTR __Val$[esp+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	cmovae	ecx, DWORD PTR __Buf$[esp+76]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1289 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	add	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	esi
	push	eax
	push	DWORD PTR __Buf$[esp+92]
	push	ecx
	call	_sprintf_s
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Buf$[esp+104], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR __Buf$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1292 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	cmovae	ecx, DWORD PTR __Buf$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1292 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	push	eax
	push	ecx
	push	DWORD PTR __Fill$[esp+88]
	push	edi
	push	DWORD PTR __Dest$[esp+100]
	push	DWORD PTR __Dest$[esp+100]
	push	esi
	push	DWORD PTR _this$GSCopy$1$[esp+112]
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Buf$[esp+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1292 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	add	esp, 56					; 00000038H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN110@do_put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Buf$[esp+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN109@do_put

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN126@do_put
$LN109@do_put:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN110@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1293 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+60]
	mov	eax, esi
	pop	edi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 52					; 00000034H
	ret	28					; 0000001cH
$LN126@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN124@do_put:
	int	3
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 8
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1268 :         unsigned long long _Val) const { // put formatted unsigned long long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+76]

; 1269 :         char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1270 : 
; 1271 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+80]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+80]
	push	edi
	push	DWORD PTR __Val$[esp+88]
	mov	edi, ecx
	push	DWORD PTR __Val$[esp+88]
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02CLHGNPPK@Lu@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+100]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+112]
	push	eax
	push	DWORD PTR __Fill$[esp+112]
	push	esi
	push	DWORD PTR __Dest$[esp+124]
	push	DWORD PTR __Dest$[esp+124]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1272 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
; 1273 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+140]
	add	esp, 52					; 00000034H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 8
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1260 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+76]

; 1261 :         char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1262 : 
; 1263 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+80]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+80]
	push	edi
	push	DWORD PTR __Val$[esp+88]
	mov	edi, ecx
	push	DWORD PTR __Val$[esp+88]
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02HIKPPMOK@Ld@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+100]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+112]
	push	eax
	push	DWORD PTR __Fill$[esp+112]
	push	esi
	push	DWORD PTR __Dest$[esp+124]
	push	DWORD PTR __Dest$[esp+124]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1264 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
; 1265 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+140]
	add	esp, 52					; 00000034H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 6
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1252 :         unsigned long _Val) const { // put formatted unsigned long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+76]

; 1253 :         char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1254 : 
; 1255 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+80]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+80]
	push	edi
	push	DWORD PTR __Val$[esp+84]
	mov	edi, ecx
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02BDDLJJBK@lu@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+96]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+108]
	push	eax
	push	DWORD PTR __Fill$[esp+108]
	push	esi
	push	DWORD PTR __Dest$[esp+120]
	push	DWORD PTR __Dest$[esp+120]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1256 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
; 1257 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+136]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 6
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1244 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+76]

; 1245 :         char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1246 : 
; 1247 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+80]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+80]
	push	edi
	push	DWORD PTR __Val$[esp+84]
	mov	edi, ecx
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02EAOCLKAK@ld@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+96]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+108]
	push	eax
	push	DWORD PTR __Fill$[esp+108]
	push	esi
	push	DWORD PTR __Dest$[esp+120]
	push	DWORD PTR __Dest$[esp+120]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1248 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
; 1249 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+136]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
__Fill$GSCopy$ = -68					; size = 1
_this$GSCopy$1$ = -64					; size = 4
$T1 = -60						; size = 8
$T2 = -60						; size = 8
$T3 = -60						; size = 8
__Str$4 = -52						; size = 24
$T5 = -28						; size = 24
$T6 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1217 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { // put formatted bool to _Dest

	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+68], eax
	mov	al, BYTE PTR __Fill$[esp+64]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+72]
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR __Iosbase$[esp+76]
	mov	DWORD PTR _this$GSCopy$1$[esp+80], ebx
	mov	BYTE PTR __Fill$GSCopy$[esp+80], al

; 1218 :         if (!(_Iosbase.flags() & ios_base::boolalpha)) {

	test	DWORD PTR [edi+20], 16384		; 00004000H
	jne	SHORT $LN2@do_put

; 1219 :             return do_put(_Dest, _Iosbase, _Fill, (long) _Val);

	movzx	eax, BYTE PTR __Val$[esp+76]
	mov	edx, DWORD PTR [ebx]
	push	eax
	push	DWORD PTR __Fill$GSCopy$[esp+84]
	push	edi
	push	DWORD PTR __Dest$[esp+92]
	push	DWORD PTR __Dest$[esp+92]
	push	ebp
	call	DWORD PTR [edx+36]
	jmp	$LN130@do_put
$LN2@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR [edi+48]
	push	esi
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T3[esp+88], ecx

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1221 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T3[esp+84]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	mov	ecx, DWORD PTR $T3[esp+92]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1221 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	add	esp, 4
	mov	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	test	ecx, ecx
	je	SHORT $LN19@do_put

; 360  :             delete _Ptr->_Decref();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN19@do_put
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN19@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1223 :             if (_Val) {

	cmp	BYTE PTR __Val$[esp+80], 0
	lea	ecx, DWORD PTR $T6[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1223 :             if (_Val) {

	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR __Str$4[esp+104], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1223 :             if (_Val) {

	mov	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR __Str$4[esp+108], 15		; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR __Str$4[esp+88], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1223 :             if (_Val) {

	je	SHORT $LN4@do_put

; 130  :         return do_truename();

	call	DWORD PTR [eax+28]

; 1224 :                 _Str.assign(_Punct_fac.truename());
; 1225 :             } else {

	jmp	SHORT $LN146@do_put
$LN4@do_put:

; 126  :         return do_falsename();

	call	DWORD PTR [eax+24]
$LN146@do_put:

; 1226 :                 _Str.assign(_Punct_fac.falsename());
; 1227 :             }
; 1228 : 
; 1229 :             size_t _Fillcount = _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Str.size()

	lea	eax, DWORD PTR $T5[esp+84]
	push	eax
	lea	ecx, DWORD PTR __Str$4[esp+88]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T5[esp+84]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	DWORD PTR [edi+36], 0
	mov	esi, DWORD PTR [edi+32]
	mov	eax, DWORD PTR __Str$4[esp+100]
	jl	SHORT $LN8@do_put
	jg	SHORT $LN143@do_put
	test	esi, esi
	je	SHORT $LN8@do_put
$LN143@do_put:
	cmp	esi, eax
	jbe	SHORT $LN8@do_put
	sub	esi, eax
	jmp	SHORT $LN9@do_put
$LN8@do_put:
	xor	esi, esi
$LN9@do_put:

; 1230 :                                     ? 0
; 1231 :                                     : (size_t) _Iosbase.width() - _Str.size();
; 1232 : 
; 1233 :             if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill

	mov	eax, DWORD PTR [edi+20]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN144@do_put

; 1234 :                 _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	DWORD PTR __Fill$GSCopy$[esp+88]
	lea	eax, DWORD PTR $T2[esp+92]
	push	DWORD PTR __Dest$[esp+92]
	push	DWORD PTR __Dest$[esp+92]
	push	eax
	push	ebx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H

; 1235 :                 _Fillcount = 0;

	xor	esi, esi
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+80], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[esp+84], edx
	jmp	SHORT $LN6@do_put
$LN144@do_put:

; 1230 :                                     ? 0
; 1231 :                                     : (size_t) _Iosbase.width() - _Str.size();
; 1232 : 
; 1233 :             if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill

	mov	edx, DWORD PTR __Dest$[esp+84]
	mov	ecx, DWORD PTR __Dest$[esp+80]
$LN6@do_put:

; 1237 :             _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field

	push	DWORD PTR __Str$4[esp+100]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Str$4[esp+108], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Str$4[esp+88]

; 2024 :         if (_Large_string_engaged()) {

	mov	ebx, DWORD PTR __Str$4[esp+88]
	cmovae	eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1237 :             _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field

	push	eax
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T1[esp+100]
	push	eax
	push	DWORD PTR _this$GSCopy$1$[esp+104]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1239 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	push	esi
	push	DWORD PTR __Fill$GSCopy$[esp+112]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+112], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
	push	ebp
	push	DWORD PTR _this$GSCopy$1$[esp+128]
	mov	DWORD PTR __Dest$[esp+132], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [edi+32], 0
	mov	DWORD PTR [edi+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1239 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	eax, DWORD PTR __Str$4[esp+152]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1239 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	add	esp, 48					; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	pop	esi
	cmp	eax, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN130@do_put

; 3872 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 3873 :             auto& _Al          = _Getal();
; 3874 :             _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ebx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN129@do_put

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ebx, DWORD PTR [ebx-4]
	add	ecx, 35					; 00000023H
	sub	eax, ebx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN148@do_put
$LN129@do_put:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN130@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1241 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+80]
	mov	eax, ebp
	pop	edi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 68					; 00000044H
	ret	24					; 00000018H
$LN148@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN145@do_put:
	int	3
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1192 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

	push	DWORD PTR __Val$[esp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Val$[esp]
	push	DWORD PTR __Fill$[esp+4]
	push	DWORD PTR __Iosbase$[esp+8]
	push	DWORD PTR __Dest$[esp+16]
	push	DWORD PTR __Dest$[esp+16]
	push	DWORD PTR ___$ReturnUdt$[esp+20]
	call	DWORD PTR [eax+28]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1193 :     }

	ret	28					; 0000001cH
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1187 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

	push	DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Fill$[esp]
	push	DWORD PTR __Iosbase$[esp+4]
	push	DWORD PTR __Dest$[esp+12]
	push	DWORD PTR __Dest$[esp+12]
	push	DWORD PTR ___$ReturnUdt$[esp+16]
	call	DWORD PTR [eax+32]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1188 :     }

	ret	24					; 00000018H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	eax, DWORD PTR __Refs$[esp-4]
	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1170 :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	ret	8
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 1158 :     }

	ret	4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1155 :     }

	ret	0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
$T2 = -52						; size = 52
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 1143 :         const locale* _Ploc = nullptr) { // return locale category mask and construct standard facet

	sub	esp, 56					; 00000038H
	push	ebx
	push	edi

; 1144 :         if (_Ppf != nullptr && *_Ppf == nullptr) {

	mov	edi, DWORD PTR __Ppf$[esp+60]
	xor	ebx, ebx
	mov	DWORD PTR $T1[esp+64], ebx
	test	edi, edi
	je	SHORT $LN24@Getcat
	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN24@Getcat

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	push	esi
	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN4@Getcat
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	ecx, DWORD PTR __Ploc$[esp+64]
	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	jne	SHORT $LN9@Getcat
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN14@Getcat
$LN9@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN14@Getcat
	lea	eax, DWORD PTR [ecx+28]
$LN14@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	push	eax
	lea	ecx, DWORD PTR $T2[esp+72]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	mov	ebx, 1

; 1168 :         : locale::facet(_Refs) { // construct from specified locale

	mov	DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	esi, esi
$LN5@Getcat:
	mov	DWORD PTR [edi], esi
	pop	esi
	test	bl, 1
	je	SHORT $LN24@Getcat
	lea	ecx, DWORD PTR $T2[esp+64]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN24@Getcat:

; 1146 :         }
; 1147 : 
; 1148 :         return _X_NUMERIC;
; 1149 :     }

	pop	edi
	mov	eax, 4
	pop	ebx
	add	esp, 56					; 00000038H
	ret	0
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Lock$1 = -60						; size = 4
$T2 = -56						; size = 4
__Lock$3 = -56						; size = 4
$T4 = -52						; size = 52
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 434  : { // get facet reference from locale

	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	ebx, ebx

; 435  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	lea	ecx, DWORD PTR __Lock$3[esp+76]
	push	ebx
	mov	DWORD PTR $T2[esp+80], ebx
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	mov	edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id

; 436  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	ebp, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	test	edi, edi
	jne	SHORT $LN9@use_facet

; 100  :                 _BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$1[esp+80]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 101  :                 if (_Id == 0) {

	cmp	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, ebx ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	jne	SHORT $LN10@use_facet

; 102  :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN10@use_facet:

; 103  :                 }
; 104  :                 _END_LOCK()

	lea	ecx, DWORD PTR __Lock$1[esp+76]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN9@use_facet:

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	ecx, DWORD PTR __Loc$[esp+72]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN17@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	test	esi, esi
	jne	$LN84@use_facet
	jmp	SHORT $LN87@use_facet
$LN17@use_facet:

; 380  :     }
; 381  : 
; 382  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	esi, esi
$LN87@use_facet:

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [ecx+20], bl
	je	SHORT $LN15@use_facet

; 385  :             return _Facptr; // found facet or not transparent
; 386  :         } else { // look in current locale
; 387  :             locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 388  :             return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] // get from current locale

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN88@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 437  : 
; 438  :     const size_t _Id         = _Facet::id;
; 439  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 440  : 
; 441  :     if (_Pf == nullptr) {

	test	esi, esi
	jne	$LN84@use_facet
$LN88@use_facet:

; 442  :         if (_Psave != nullptr) {

	test	ebp, ebp
	je	SHORT $LN3@use_facet

; 462  :             _Pf                       = _Psave;
; 463  : 
; 464  :             (void) _Psave_guard.release();
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[esp+76]
	mov	esi, ebp
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

	add	esp, 60					; 0000003cH
	ret	0
$LN3@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN24@use_facet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	eax, DWORD PTR __Loc$[esp+72]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN29@use_facet
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN34@use_facet
$LN29@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN34@use_facet
	lea	eax, DWORD PTR [ecx+28]
$LN34@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	push	eax
	lea	ecx, DWORD PTR $T4[esp+80]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	mov	ebx, 1

; 1168 :         : locale::facet(_Refs) { // construct from specified locale

	mov	DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	jmp	SHORT $LN25@use_facet
$LN24@use_facet:
	xor	esi, esi
$LN25@use_facet:
	test	bl, 1
	je	SHORT $LN26@use_facet
	lea	ecx, DWORD PTR $T4[esp+76]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN26@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 457  :             _Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 458  : #endif // defined(_M_CEE)
; 459  : 
; 460  :             _Pfmod->_Incref();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [edx+4]

; 461  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
$LN84@use_facet:

; 462  :             _Pf                       = _Psave;
; 463  : 
; 464  :             (void) _Psave_guard.release();
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[esp+76]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

	add	esp, 60					; 0000003cH
	ret	0
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 120  :             return _Ok;

	mov	al, BYTE PTR [ecx+4]

; 121  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 104  :         __CLR_OR_THIS_CALL ~sentry() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 105  : #if _HAS_EXCEPTIONS
; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN2@sentry

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN2@sentry:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	ecx, DWORD PTR [esi]
	pop	esi
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+8]
$LN5@sentry:

; 108  :             }
; 109  : #else // _HAS_EXCEPTIONS
; 110  :             this->_Myostr._Osfx();
; 111  : #endif // _HAS_EXCEPTIONS
; 112  :         }

	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ok$1 = -8						; size = 8
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr)

	sub	esp, 8
	push	ebx
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR __Ostr$[esp+12]

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	DWORD PTR [ebx], edi

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+edi+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edi]
$LN5@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	eax, DWORD PTR [edx+4]

; 321  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+edi+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	jne	SHORT $LN45@sentry
	push	esi
	mov	esi, DWORD PTR [eax+edi+60]
	test	esi, esi
	je	SHORT $LN55@sentry
	cmp	esi, edi
	je	SHORT $LN55@sentry

; 508  :         if (_Myios::rdbuf() != nullptr) { // buffer exists, flush it

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+56], 0
	je	SHORT $LN55@sentry

; 509  :             const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$1[esp+24]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 511  :             if (_Ok && _Myios::rdbuf()->pubsync() == -1) {

	cmp	BYTE PTR __Ok$1[esp+24], 0
	je	SHORT $LN23@sentry
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 121  :         return sync();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+52]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 511  :             if (_Ok && _Myios::rdbuf()->pubsync() == -1) {

	cmp	eax, -1
	jne	SHORT $LN23@sentry

; 512  :                 _Myios::setstate(ios_base::badbit); // sync failed

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 512  :                 _Myios::setstate(ios_base::badbit); // sync failed

	mov	ecx, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	mov	eax, DWORD PTR [ecx+esi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 512  :                 _Myios::setstate(ios_base::badbit); // sync failed

	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	or	eax, 4
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN23@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN42@sentry

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, DWORD PTR __Ok$1[esp+20]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN42@sentry:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	ecx, DWORD PTR __Ok$1[esp+20]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN55@sentry

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN55@sentry:
	pop	esi
$LN45@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 321  :         return rdstate() == ios_base::goodbit;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+edi+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 95   :         }

	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 321  :         return rdstate() == ios_base::goodbit;

	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 94   :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	BYTE PTR [ebx+4], al

; 95   :         }

	mov	eax, ebx
	pop	ebx
	add	esp, 8
	ret	4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 78   :             }
; 79   :         }

	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	edx, DWORD PTR __Ostr$[esp-4]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 72   :             }
; 73   :         }

	mov	eax, esi
	pop	esi
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1528 :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1528 :     }

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	ret	8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 295  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[esp-4]

; 296  : }

	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1528 :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1528 :     }

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -40						; size = 8
__Pad$ = -32						; size = 8
__Count$1$ = -24					; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 696  :     const char* _Val) { // insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 697  :     using _Elem = char;
; 698  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 699  : 
; 700  :     ios_base::iostate _State = ios_base::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	edx, DWORD PTR __Val$[ebp]
	lea	ecx, DWORD PTR [edx+1]
$LL83@operator:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL83@operator
	sub	edx, ecx
	mov	DWORD PTR __Count$1$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 389  :         return _Wide;

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+ecx+32]
	mov	edi, DWORD PTR [eax+ecx+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 702  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN85@operator
	test	esi, esi
	je	SHORT $LN17@operator
	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN85@operator
	cmp	esi, edx
	jbe	SHORT $LN17@operator
$LN85@operator:
	sub	esi, edx
	sbb	edi, ebx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	edi, DWORD PTR __Pad$[ebp+4]
	mov	esi, DWORD PTR __Pad$[ebp]
$LN18@operator:

; 703  :     const typename _Myos::sentry _Ok(_Ostr);

	push	ecx
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 704  : 
; 705  :     if (!_Ok) {

	cmp	BYTE PTR __Ok$[ebp+4], bl
	jne	SHORT $LN8@operator

; 706  :         _State |= ios_base::badbit;

	mov	ebx, 4

; 707  :     } else { // state okay, insert

	jmp	$LN96@operator
$LN8@operator:

; 708  :         _TRY_IO_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 709  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 352  :         return _Fmtfl;

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+edx+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 709  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN79@operator
	npad	1
$LL4@operator:

; 710  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	edi, edi
	jl	SHORT $LN3@operator
	jg	SHORT $LN86@operator
	test	esi, esi
	je	SHORT $LN3@operator
$LN86@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]

; 97   :         return _Fillch;

	mov	al, BYTE PTR [eax+edx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 711  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	push	eax
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 711  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	je	SHORT $LN87@operator

; 710  :             for (; 0 < _Pad; --_Pad) { // pad on left

	add	esi, -1
	mov	DWORD PTR __Pad$[ebp], esi
	adc	edi, -1
	mov	DWORD PTR __Pad$[ebp+4], edi
	mov	edx, DWORD PTR __Ostr$[ebp]
	jmp	SHORT $LL4@operator
$LN3@operator:

; 718  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	mov	ecx, DWORD PTR [edx]
$LN79@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 718  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	push	0
	push	DWORD PTR __Count$1$[ebp]
	push	DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+edx+56]
	call	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
	cmp	eax, DWORD PTR __Count$1$[ebp]
	jne	SHORT $LN87@operator
	test	edx, edx
	jne	SHORT $LN87@operator
$LL89@operator:

; 719  :             _State |= ios_base::badbit;
; 720  :         }
; 721  : 
; 722  :         if (_State == ios_base::goodbit) {
; 723  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	edi, edi
	jl	SHORT $LN6@operator
	jg	SHORT $LN88@operator
	test	esi, esi
	je	SHORT $LN6@operator
$LN88@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]

; 97   :         return _Fillch;

	mov	al, BYTE PTR [eax+edx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 724  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	push	eax
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 724  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	je	SHORT $LN87@operator

; 719  :             _State |= ios_base::badbit;
; 720  :         }
; 721  : 
; 722  :         if (_State == ios_base::goodbit) {
; 723  :             for (; 0 < _Pad; --_Pad) { // pad on right

	add	esi, -1
	mov	DWORD PTR __Pad$[ebp], esi
	adc	edi, -1
	mov	DWORD PTR __Pad$[ebp+4], edi
	jmp	SHORT $LL89@operator
$LN87@operator:

; 725  :                     _State |= ios_base::badbit; // insertion failed, quit
; 726  :                     break;
; 727  :                 }
; 728  :             }
; 729  :         }
; 730  : 
; 731  :         _Ostr.width(0);

	mov	ebx, 4
	mov	DWORD PTR __State$[ebp], ebx
$LN6@operator:
	mov	esi, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [eax+esi+32], 0
	mov	DWORD PTR [eax+esi+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN21@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 732  :         _CATCH_IO_(ios_base, _Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	push	1
	push	4
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN22@operator
	ret	0
$LN22@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	ebx, DWORD PTR __State$[ebp]
$LN96@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 733  :     }
; 734  : 
; 735  :     _Ostr.setstate(_State);

	mov	esi, DWORD PTR __Ostr$[ebp]
$LN21@operator:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 50   :         clear(rdstate() | _State, _Reraise);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, ebx

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	0
	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	mov	edi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN64@operator

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, edi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN64@operator:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+edi+56]
	test	ecx, ecx
	je	SHORT $LN90@operator

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN90@operator:

; 736  :     return _Ostr;
; 737  : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
__Ok$1 = -8						; size = 8
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 507  :     basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 508  :         if (_Myios::rdbuf() != nullptr) { // buffer exists, flush it

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+56], 0
	je	SHORT $LN56@flush

; 509  :             const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$1[esp+16]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 511  :             if (_Ok && _Myios::rdbuf()->pubsync() == -1) {

	cmp	BYTE PTR __Ok$1[esp+16], 0
	je	SHORT $LN3@flush
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 121  :         return sync();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+52]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 511  :             if (_Ok && _Myios::rdbuf()->pubsync() == -1) {

	cmp	eax, -1
	jne	SHORT $LN3@flush

; 512  :                 _Myios::setstate(ios_base::badbit); // sync failed

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 512  :                 _Myios::setstate(ios_base::badbit); // sync failed

	mov	ecx, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	mov	eax, DWORD PTR [ecx+esi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 512  :                 _Myios::setstate(ios_base::badbit); // sync failed

	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	or	eax, 4
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN3@flush:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN46@flush

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, DWORD PTR __Ok$1[esp+12]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN46@flush:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	ecx, DWORD PTR __Ok$1[esp+12]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN56@flush

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN56@flush:

; 513  :             }
; 514  :         }
; 515  :         return *this;
; 516  :     }

	mov	eax, esi
	pop	esi
	add	esp, 8
	ret	0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
$T2 = -40						; size = 8
$T3 = -36						; size = 4
__State$ = -32						; size = 4
_this$ = -28						; size = 4
$T4 = -24						; size = 8
__Nput_fac$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T5 = 8							; size = 8
__Val$ = 8						; size = 8
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 323  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(long long _Val) { // insert a long long

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 324  :         ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __State$[ebp], edi

; 325  :         const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 326  : 
; 327  :         if (_Ok) { // state okay, use facet to insert

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN8@operator

; 328  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 399  :         return *_Ploc;

	mov	eax, DWORD PTR [eax+esi+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR $T4[ebp+4], ecx

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 328  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	mov	edx, eax
	mov	DWORD PTR __Nput_fac$1$[ebp], edx
	mov	ecx, DWORD PTR $T3[ebp]
	test	ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	je	SHORT $LN19@operator

; 360  :             delete _Ptr->_Decref();

	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	call	edx
	test	eax, eax
	je	SHORT $LN49@operator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	1
	mov	ecx, eax
	call	edx
$LN49@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 330  :             _TRY_IO_BEGIN

	mov	edx, DWORD PTR __Nput_fac$1$[ebp]
$LN19@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 97   :         return _Fillch;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR [eax+esi]
	mov	al, BYTE PTR [ecx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 555  :         : _Failed(false), _Strbuf(_Sb) { // construct from stream buffer _Sb

	mov	BYTE PTR $T2[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 331  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {

	push	DWORD PTR __Val$[ebp+4]
	push	DWORD PTR __Val$[ebp]
	push	eax
	push	ecx
	push	DWORD PTR [ecx+56]
	push	DWORD PTR $T2[ebp]
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, edx
	call	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 583  :         return _Failed;

	mov	al, BYTE PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 331  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {

	mov	ecx, 4
	test	al, al
	cmovne	edi, ecx
	mov	DWORD PTR __State$[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN8@operator
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$0:

; 332  :                 _State |= ios_base::badbit;
; 333  :             }
; 334  :             _CATCH_IO_END

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	push	1
	push	4
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN9@operator
	ret	0
$LN9@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN8@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 335  :         }
; 336  : 
; 337  :         _Myios::setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 50   :         clear(rdstate() | _State, _Reraise);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, edi

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	0
	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	mov	edi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN38@operator

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, edi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN38@operator:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edi+56]
	test	ecx, ecx
	je	SHORT $LN47@operator

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN47@operator:

; 338  :         return *this;
; 339  :     }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
$T2 = -40						; size = 8
$T3 = -40						; size = 8
$T4 = -36						; size = 4
__State$ = -32						; size = 4
_this$ = -28						; size = 4
$T5 = -24						; size = 8
__Nput_fac$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 269  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(unsigned int _Val) { // insert an unsigned int

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 270  :         ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __State$[ebp], edi

; 271  :         const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 272  : 
; 273  :         if (_Ok) { // state okay, use facet to insert

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN8@operator

; 274  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 399  :         return *_Ploc;

	mov	eax, DWORD PTR [eax+esi+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR $T5[ebp+4], ecx

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 274  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	mov	edx, eax
	mov	DWORD PTR __Nput_fac$1$[ebp], edx
	mov	ecx, DWORD PTR $T4[ebp]
	test	ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	je	SHORT $LN19@operator

; 360  :             delete _Ptr->_Decref();

	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	call	edx
	test	eax, eax
	je	SHORT $LN49@operator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	1
	mov	ecx, eax
	call	edx
$LN49@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 276  :             _TRY_IO_BEGIN

	mov	edx, DWORD PTR __Nput_fac$1$[ebp]
$LN19@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 97   :         return _Fillch;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR [eax+esi]
	mov	al, BYTE PTR [ecx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 555  :         : _Failed(false), _Strbuf(_Sb) { // construct from stream buffer _Sb

	mov	BYTE PTR $T3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 277  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long) _Val).failed()) {

	push	DWORD PTR __Val$[ebp]
	push	eax
	push	ecx
	push	DWORD PTR [ecx+56]
	push	DWORD PTR $T3[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, edx
	call	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 583  :         return _Failed;

	mov	al, BYTE PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 277  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long) _Val).failed()) {

	mov	ecx, 4
	test	al, al
	cmovne	edi, ecx
	mov	DWORD PTR __State$[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN8@operator
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$0:

; 278  :                 _State |= ios_base::badbit;
; 279  :             }
; 280  :             _CATCH_IO_END

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	push	1
	push	4
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN9@operator
	ret	0
$LN9@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN8@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 281  :         }
; 282  : 
; 283  :         _Myios::setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 50   :         clear(rdstate() | _State, _Reraise);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, edi

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	0
	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	mov	edi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN38@operator

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, edi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN38@operator:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edi+56]
	test	ecx, ecx
	je	SHORT $LN47@operator

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN47@operator:

; 284  :         return *this;
; 285  :     }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 142  :     void __CLR_OR_THIS_CALL _Osfx() { // perform any wrapup

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 143  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]

; 321  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+esi+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 144  :         if (this->good() && this->flags() & ios_base::unitbuf) {

	jne	SHORT $LN9@Osfx
	test	BYTE PTR [eax+esi+20], 2
	je	SHORT $LN9@Osfx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 121  :         return sync();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+52]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 145  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

	cmp	eax, -1
	jne	SHORT $LN9@Osfx

; 146  :                 _Myios::setstate(ios_base::badbit);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	push	0
	push	4
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
$LN9@Osfx:

; 151  :     }

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 147  :             }
; 148  :         }
; 149  :         _CATCH_ALL
; 150  :         _CATCH_END

	mov	eax, $LN9@Osfx
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 97   :         return _Fillch;

	mov	al, BYTE PTR [ecx+64]

; 98   :     }

	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [ecx+56]

; 78   :     }

	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 67   :         return _Tiestr;

	mov	eax, DWORD PTR [ecx+60]

; 68   :     }

	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 50   :         clear(rdstate() | _State, _Reraise);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, DWORD PTR __State$[esp-4]

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	DWORD PTR __Reraise$[esp-4]
	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear

; 51   :     }

	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	mov	edx, DWORD PTR __State$[esp-4]
	push	DWORD PTR __Reraise$[esp-4]
	or	edx, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	edx, DWORD PTR __State$[esp]
	push	edx
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear

; 40   :     }

	ret	8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,10000000>,void>, COMDAT

; 365  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 366  : 
; 367  :         using _ToRep = typename _To::rep;
; 368  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 369  : 
; 370  :         constexpr bool _Num_is_one = _CF::num == 1;
; 371  :         constexpr bool _Den_is_one = _CF::den == 1;
; 372  :         return _Num_is_one && _Den_is_one

	mov	eax, DWORD PTR __Dur$[esp-4]
	push	0
	push	10000					; 00002710H
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	__alldiv
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], edx

; 373  :                    ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 374  :                    : !_Num_is_one && _Den_is_one
; 375  :                          ? static_cast<_To>(
; 376  :                                static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)))
; 377  :                          : _Num_is_one && !_Den_is_one
; 378  :                                ? static_cast<_To>(
; 379  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)))
; 380  :                                : static_cast<_To>(
; 381  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 382  :                                                          / static_cast<_CR>(_CF::den)));
; 383  :     }

	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0JIJGIA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,10000000>,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> >,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT

; 188  :             return _MyDur;

	mov	ecx, DWORD PTR __Left$[esp-4]
	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	sbb	ecx, DWORD PTR [eax+4]

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 475  :         return _Left.time_since_epoch() - _Right.time_since_epoch();
; 476  :     }

	ret	0
??$?GUsystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@01@ABV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> >,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
;	COMDAT ??$erase@H@@YAXAAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_vec$ = 8						; size = 4
??$erase@H@@YAXAAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; erase<int>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1627 :         return _Get_data()._Mylast;

	mov	edx, DWORD PTR _vec$[esp-4]

; 1335 :         return _Myfirst() == _Mylast();

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	cmp	ecx, eax
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 84   :   while(!vec.empty())

	je	SHORT $LN3@erase
	npad	3
$LL2@erase:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1201 :         --_Mylast();

	add	eax, -4					; fffffffcH
	mov	DWORD PTR [edx+4], eax

; 1335 :         return _Myfirst() == _Mylast();

	mov	ecx, DWORD PTR [edx]
	cmp	ecx, eax
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 84   :   while(!vec.empty())

	jne	SHORT $LL2@erase
$LN3@erase:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	sub	eax, ecx
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 87   :   cerr << vec.size();

	mov	ecx, OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	sar	eax, 2
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 87   :   cerr << vec.size();

	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 88   : }

	ret	0
??$erase@H@@YAXAAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; erase<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
;	COMDAT ??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@X@thread@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Fx$ = 8						; size = 4
_<_Ax_0>$ = 12						; size = 4
??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@X@thread@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::thread::thread<void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,void>, COMDAT
; _this$ = ecx

; 52   :     explicit thread(_Fn&& _Fx, _Args&&... _Ax) { // construct with _Fx(_Ax...)

	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 52   :     explicit thread(_Fn&& _Fx, _Args&&... _Ax) { // construct with _Fx(_Ax...)

	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	edx, DWORD PTR _<_Ax_0>$[esp+4]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Fx$[esp+4]
	mov	DWORD PTR [eax+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	jmp	SHORT $LN12@thread
$LN11@thread:
	xor	eax, eax
$LN12@thread:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 56   :         _Thr._Hnd =

	lea	edi, DWORD PTR [esi+4]
	push	edi
	push	0
	push	eax
	push	OFFSET ??$_Invoke@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,0,1>
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

	test	eax, eax
	je	SHORT $LN92@thread

; 61   :         } else { // ownership transferred to the thread
; 62   :             (void) _Decay_copied.release();
; 63   :         }
; 64   :     }

	pop	edi
	mov	eax, esi
	pop	esi
	ret	8
$LN92@thread:

; 59   :             _Thr._Id = 0;

	push	6
	mov	DWORD PTR [edi], 0

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN90@thread:
	int	3
??$?0A6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@X@thread@std@@QAE@A6AXAAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::thread::thread<void (__cdecl&)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
;	COMDAT ??$InsertionSort@H@@YAXAAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_vec$ = 8						; size = 4
??$InsertionSort@H@@YAXAAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; InsertionSort<int>, COMDAT

; 109  : {

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1627 :         return _Get_data()._Mylast;

	mov	esi, DWORD PTR _vec$[esp]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 109  : {

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	edi, DWORD PTR [esi+4]
	mov	eax, edi
	mov	edx, DWORD PTR [esi]
	sub	eax, edx
	sar	eax, 2
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 110  :   for (int i=1;i<vec.size();i++) {

	cmp	eax, 1
	jbe	SHORT $LN3@InsertionS
	push	ebx
	push	ebp
	xor	ebx, ebx
	mov	ebp, 4
$LL4@InsertionS:

; 111  :       auto k = vec[i];

	mov	edi, DWORD PTR [edx+ebp]

; 112  :       auto j = i-1;

	mov	eax, ebx

; 113  :       while (j >= 0 && vec[j] > k) {

	test	ebx, ebx
	js	SHORT $LN84@InsertionS
	npad	7
$LL5@InsertionS:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	ecx, DWORD PTR [esi]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 113  :       while (j >= 0 && vec[j] > k) {

	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	edx, edi
	jle	SHORT $LN84@InsertionS

; 114  :         vec[j+1] = vec[j];

	mov	DWORD PTR [ecx+eax*4+4], edx

; 115  :         j = j-1;

	sub	eax, 1
	jns	SHORT $LL5@InsertionS
$LN84@InsertionS:

; 116  :       }
; 117  :       vec[j+1] = k;

	mov	ecx, DWORD PTR [esi]
	inc	ebx
	add	ebp, 4
	mov	DWORD PTR [ecx+eax*4+4], edi
	lea	eax, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, edi
	mov	edx, DWORD PTR [esi]
	sub	ecx, edx
	sar	ecx, 2
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 110  :   for (int i=1;i<vec.size();i++) {

	cmp	eax, ecx
	jb	SHORT $LL4@InsertionS
	pop	ebp
	pop	ebx
$LN3@InsertionS:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	sub	edi, edx
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 120  :     	cerr << vec.size();

	mov	ecx, OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	sar	edi, 2
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 120  :     	cerr << vec.size();

	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	pop	edi
	pop	esi

; 121  : }

	ret	0
??$InsertionSort@H@@YAXAAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; InsertionSort<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
;	COMDAT ??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@X@thread@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Fx$ = 8						; size = 4
_<_Ax_0>$ = 12						; size = 4
_<_Ax_1>$ = 16						; size = 4
??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@X@thread@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::thread::thread<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,void>, COMDAT
; _this$ = ecx

; 52   :     explicit thread(_Fn&& _Fx, _Args&&... _Ax) { // construct with _Fx(_Ax...)

	push	ebx
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 52   :     explicit thread(_Fn&& _Fx, _Args&&... _Ax) { // construct with _Fx(_Ax...)

	mov	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN13@thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	edx, DWORD PTR _<_Ax_1>$[esp+8]
	mov	eax, DWORD PTR __Fx$[esp+8]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR _<_Ax_0>$[esp+8]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	jmp	SHORT $LN14@thread
$LN13@thread:
	xor	esi, esi
$LN14@thread:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 56   :         _Thr._Hnd =

	lea	ebx, DWORD PTR [edi+4]
	push	ebx
	push	0
	push	esi
	push	OFFSET ??$_Invoke@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00$01@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,0,1,2>
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

	test	eax, eax
	je	SHORT $LN110@thread

; 61   :         } else { // ownership transferred to the thread
; 62   :             (void) _Decay_copied.release();
; 63   :         }
; 64   :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	12					; 0000000cH
$LN110@thread:

; 59   :             _Thr._Id = 0;

	push	6
	mov	DWORD PTR [ebx], 0

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN108@thread:
	int	3
??$?0A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@X@thread@std@@QAE@A6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@AAV?$vector@HV?$allocator@H@std@@@1@@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::thread::thread<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
;	COMDAT ??$insert@H@@YAXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
_rs$ = 8						; size = 32
_vec$ = 40						; size = 4
??$insert@H@@YAXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; insert<int>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR _rs$[esp]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 68   : {

	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	edi, DWORD PTR _vec$[esp+4]
	mov	esi, DWORD PTR [eax]

; 208  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, eax
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 69   :   for (auto i = rs.begin();i!=rs.end();i++)

	je	SHORT $LN156@insert
	mov	ecx, DWORD PTR [edi+4]
$LL4@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 161  :         return this->_Ptr->_Myval;

	lea	eax, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1357 :         return _Myend() != _Mylast();

	cmp	DWORD PTR [edi+8], ecx

; 637  :         if (_Has_unused_capacity()) {

	je	SHORT $LN63@insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 625  :         ++_Mylast();

	add	DWORD PTR [edi+4], 4

; 638  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN160@insert
$LN63@insert:

; 639  :         }
; 640  : 
; 641  :         _Ty& _Result = *_Emplace_reallocate(_Mylast(), _STD forward<_Valty>(_Val)...);

	push	eax
	push	ecx
	mov	ecx, edi
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
$LN160@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 175  :         this->_Ptr = this->_Ptr->_Next;

	mov	esi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, ecx

; 208  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR _rs$[esp+8]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 69   :   for (auto i = rs.begin();i!=rs.end();i++)

	jne	SHORT $LL4@insert
	jmp	SHORT $LN3@insert
$LN156@insert:
	mov	eax, DWORD PTR [edi+4]
$LN3@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	sub	eax, DWORD PTR [edi]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 72   :   cerr << vec.size();

	mov	ecx, OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	sar	eax, 2
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 72   :   cerr << vec.size();

	push	eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	pop	edi
	lea	ecx, DWORD PTR _rs$[esp]
	pop	esi
	jmp	??1?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ
??$insert@H@@YAXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; insert<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??B?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEAAV?$vector@HV?$allocator@H@std@@@1@XZ
_TEXT	SEGMENT
??B?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEAAV?$vector@HV?$allocator@H@std@@@1@XZ PROC ; std::reference_wrapper<std::vector<int,std::allocator<int> > >::operator std::vector<int,std::allocator<int> > &, COMDAT
; _this$ = ecx

; 1692 :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 1693 :     }

	ret	0
??B?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEAAV?$vector@HV?$allocator@H@std@@@1@XZ ENDP ; std::reference_wrapper<std::vector<int,std::allocator<int> > >::operator std::vector<int,std::allocator<int> > &
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$ref@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA?AV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$ref@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA?AV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::ref<std::vector<int,std::allocator<int> > >, COMDAT

; 1688 :         _Ptr      = _STD addressof(_Ref);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1717 :     return reference_wrapper<_Ty>(_Val);
; 1718 : }

	ret	0
??$ref@V?$vector@HV?$allocator@H@std@@@std@@@std@@YA?AV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@0@AAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::ref<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
;	COMDAT ??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@X@thread@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z
_TEXT	SEGMENT
__Fx$ = 8						; size = 4
_<_Ax_0>$ = 12						; size = 4
_<_Ax_1>$ = 16						; size = 4
_<_Ax_2>$ = 20						; size = 4
??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@X@thread@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z PROC ; std::thread::thread<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,void>, COMDAT
; _this$ = ecx

; 52   :     explicit thread(_Fn&& _Fx, _Args&&... _Ax) { // construct with _Fx(_Ax...)

	push	ebx
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 52   :     explicit thread(_Fn&& _Fx, _Args&&... _Ax) { // construct with _Fx(_Ax...)

	mov	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN15@thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	edx, DWORD PTR _<_Ax_2>$[esp+8]
	mov	eax, DWORD PTR _<_Ax_0>$[esp+8]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR _<_Ax_1>$[esp+8]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [esi+4], ecx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Fx$[esp+8]
	mov	DWORD PTR [esi+12], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	jmp	SHORT $LN16@thread
$LN15@thread:
	xor	esi, esi
$LN16@thread:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 56   :         _Thr._Hnd =

	lea	ebx, DWORD PTR [edi+4]
	push	ebx
	push	0
	push	esi
	push	OFFSET ??$_Invoke@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@$0A@$00$01$02@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,0,1,2,3>
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

	test	eax, eax
	je	SHORT $LN130@thread

; 61   :         } else { // ownership transferred to the thread
; 62   :             (void) _Decay_copied.release();
; 63   :         }
; 64   :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	16					; 00000010H
$LN130@thread:

; 59   :             _Thr._Id = 0;

	push	6
	mov	DWORD PTR [ebx], 0

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN128@thread:
	int	3
??$?0A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@V?$reference_wrapper@H@1@V31@X@thread@std@@QAE@A6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@HH@Z$$QAV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@1@$$QAV?$reference_wrapper@H@1@3@Z ENDP ; std::thread::thread<void (__cdecl&)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int>,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
;	COMDAT ??$generateRandom@H@@YAXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z
_TEXT	SEGMENT
_rs$GSCopy$1$ = -5060					; size = 4
_rando$ = -5056						; size = 4
_i$1$ = -5052						; size = 4
$T1 = -5052						; size = 1
$T2 = -5052						; size = 1
_tmp$1$ = -5048						; size = 4
__Rng$3 = -5044						; size = 12
__Rng$4 = -5032						; size = 12
$T5 = -5020						; size = 8
$T6 = -5012						; size = 8
_dr$ = -5004						; size = 5000
__$ArrayPad$ = -4					; size = 4
_rs$ = 8						; size = 4
_MAX$ = 12						; size = 4
_N$ = 16						; size = 4
??$generateRandom@H@@YAXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z PROC ; generateRandom<int>, COMDAT

; 29   : {

	mov	eax, 5060				; 000013c4H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+5060], eax
	push	ebp
	mov	ebp, DWORD PTR _rs$[esp+5060]
	push	edi
	mov	edi, DWORD PTR _MAX$[esp+5064]
	mov	DWORD PTR _rs$GSCopy$1$[esp+5068], ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 5113 :         return _Random_device();

	call	?_Random_device@std@@YAIXZ		; std::_Random_device

; 1090 :         : _Dxval(_Dxarg) { // construct with specified seed

	mov	DWORD PTR _dr$[esp+10064], -1
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 29   : {

	mov	edx, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1101 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

	mov	DWORD PTR _dr$[esp+5072], eax
$LL24@generateRa:

; 1102 :         for (int _Ix = 1; _Ix < _Nx; ++_Ix) {
; 1103 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	ecx, eax
	shr	ecx, 30					; 0000001eH
	xor	ecx, eax
	imul	eax, ecx, 1812433253
	add	eax, edx
	mov	DWORD PTR _dr$[esp+edx*4+5072], eax
	inc	edx
	cmp	edx, 624				; 00000270H
	jl	SHORT $LL24@generateRa
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 35   :   for (int i=0;i<N;i++) {

	cmp	DWORD PTR _N$[esp+5064], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1106 :         this->_Idx = _Nx;

	mov	DWORD PTR _dr$[esp+5068], 624		; 00000270H
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 33   :   int rando = 0;

	mov	DWORD PTR _rando$[esp+5068], 0

; 35   :   for (int i=0;i<N;i++) {

	jle	$LN3@generateRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	lea	eax, DWORD PTR _dr$[esp+5068]
	mov	DWORD PTR __Rng$3[esp+5072], 32		; 00000020H
	push	ebx
	mov	DWORD PTR __Rng$3[esp+5072], eax
	mov	DWORD PTR __Rng$3[esp+5080], -1
	push	esi
	npad	7
$LL4@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1881 :         if (_Umax - _Umin == _Uty(-1)) {

	cmp	edi, -1
	jne	SHORT $LN37@generateRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3304 :             _Ret |= _Get_bits();

	lea	ecx, DWORD PTR __Rng$3[esp+5076]
	call	?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1882 :             _Uret = static_cast<_Uty>(_Rng._Get_all_bits());

	mov	edx, eax

; 1883 :         } else {

	jmp	SHORT $LN68@generateRa
$LN37@generateRa:

; 1884 :             _Uret = static_cast<_Uty>(_Rng(static_cast<_Uty>(_Umax - _Umin + 1)));

	lea	ebp, DWORD PTR [edi+1]
$LL67@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3279 :             _Udiff _Ret  = 0; // random bits

	xor	esi, esi

; 3280 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

	xor	eax, eax

; 3281 : 
; 3282 :             while (_Mask < _Udiff(_Index - 1)) { // need more random bits

	test	edi, edi
	je	SHORT $LN71@generateRa

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	lea	ecx, DWORD PTR _dr$[esp+5076]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
	mov	esi, eax

; 3288 :                 _Mask |= _Bmask;

	or	eax, -1
$LN71@generateRa:

; 3289 :             }
; 3290 : 
; 3291 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3292 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

	xor	edx, edx
	div	ebp
	mov	ecx, eax
	mov	ebx, edx
	xor	edx, edx
	mov	eax, esi
	div	ebp
	cmp	eax, ecx
	jb	SHORT $LN654@generateRa
	cmp	ebx, edi
	jne	SHORT $LL67@generateRa
$LN654@generateRa:

; 3293 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, esi
	xor	edx, edx
	div	ebp
	mov	ebp, DWORD PTR _rs$GSCopy$1$[esp+5076]
$LN68@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1887 :         return _Ty(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	eax, DWORD PTR [edx-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 860  :         return _Unchecked_iterator(_Myhead(), nullptr);

	mov	esi, DWORD PTR [ebp+4]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 36   :     rando = ud(dr);

	cmp	eax, -2147483648			; 80000000H
	lea	ecx, DWORD PTR [eax-2147483648]
	lea	edx, DWORD PTR [eax-2147483648]
	cmovae	edx, ecx
	movzx	eax, dl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	eax, -2128831035			; 811c9dc5H
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 36   :     rando = ud(dr);

	mov	DWORD PTR _rando$[esp+5076], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1937 :         _Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	mov	eax, edx
	shr	eax, 8
	movzx	eax, al
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 36   :     rando = ud(dr);

	mov	DWORD PTR _tmp$1$[esp+5076], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	ecx, eax

; 1937 :         _Val *= _FNV_prime;

	mov	eax, edx
	imul	ecx, ecx, 16777619
	shr	eax, 16					; 00000010H
	movzx	eax, al
	xor	ecx, eax
	mov	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	edx, DWORD PTR [ebp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1937 :         _Val *= _FNV_prime;

	imul	ecx, ecx, 16777619
	shr	eax, 24					; 00000018H
	xor	ecx, eax
	imul	eax, ecx, 16777619
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1153 :         return _Traitsobj(_Keyval) & _Mask;

	and	eax, DWORD PTR [ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	lea	ecx, DWORD PTR [eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1114 :         return _Vec_lo(_Bucket);

	mov	ebx, DWORD PTR [ecx+edx]
	mov	eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	add	edx, ecx
	npad	1
$LL94@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 521  :         return _List._Unchecked_end();

	cmp	ebx, esi

; 1122 :         if (_Vec_lo(_Bucket) == _Unchecked_end()) {

	jne	SHORT $LN135@generateRa

; 1123 :             return _Unchecked_end();

	mov	ecx, esi
	jmp	SHORT $LN136@generateRa
$LN135@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	ecx, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1126 :             return ++_Ans;

	mov	ecx, DWORD PTR [ecx]
$LN136@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 767  :         for (_Unchecked_iterator _Where = _Begin(_Bucket); _Where != _End(_Bucket); ++_Where) {

	mov	ecx, DWORD PTR _tmp$1$[esp+5076]
	je	SHORT $LN93@generateRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 88   :         return _Left == _Right;

	cmp	DWORD PTR [eax+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 768  :             if (!_Traitsobj(_Traits::_Kfn(*_Where), _Keyval)) {

	je	SHORT $LN91@generateRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LL94@generateRa
$LN93@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 505  :         return _List.end();

	mov	eax, esi
$LN91@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 208  :         return this->_Ptr == _Right._Ptr;

	cmp	eax, esi
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 39   :     if (f != rs.end()) { // found a duplicate

	je	$LN8@generateRa

; 40   :        int tmp = rando;
; 41   : 
; 42   :        for (int i = 0;i<MAX;i++) {

	xor	eax, eax
	mov	DWORD PTR _i$1$[esp+5076], eax
	test	edi, edi
	jle	$LN2@generateRa
$LL7@generateRa:

; 43   :          if (i != tmp) {

	cmp	eax, ecx
	je	$LN5@generateRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$4[esp+5080], 32		; 00000020H
	lea	eax, DWORD PTR _dr$[esp+5076]
	mov	DWORD PTR __Rng$4[esp+5076], eax
	mov	DWORD PTR __Rng$4[esp+5084], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1881 :         if (_Umax - _Umin == _Uty(-1)) {

	cmp	edi, -1
	jne	SHORT $LN325@generateRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3304 :             _Ret |= _Get_bits();

	lea	ecx, DWORD PTR __Rng$4[esp+5076]
	call	?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1882 :             _Uret = static_cast<_Uty>(_Rng._Get_all_bits());

	mov	edx, eax

; 1883 :         } else {

	jmp	SHORT $LN356@generateRa
$LN325@generateRa:

; 1884 :             _Uret = static_cast<_Uty>(_Rng(static_cast<_Uty>(_Umax - _Umin + 1)));

	lea	ebp, DWORD PTR [edi+1]
	npad	5
$LL355@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3279 :             _Udiff _Ret  = 0; // random bits

	xor	ecx, ecx

; 3280 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

	xor	eax, eax

; 3281 : 
; 3282 :             while (_Mask < _Udiff(_Index - 1)) { // need more random bits

	test	edi, edi
	je	SHORT $LN359@generateRa

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	lea	ecx, DWORD PTR _dr$[esp+5076]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
	mov	ecx, eax

; 3288 :                 _Mask |= _Bmask;

	or	eax, -1
$LN359@generateRa:

; 3289 :             }
; 3290 : 
; 3291 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3292 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

	xor	edx, edx
	div	ebp
	mov	esi, eax
	mov	ebx, edx
	xor	edx, edx
	mov	eax, ecx
	div	ebp
	cmp	eax, esi
	jb	SHORT $LN657@generateRa
	cmp	ebx, edi
	jne	SHORT $LL355@generateRa
$LN657@generateRa:

; 3293 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, ecx
	xor	edx, edx
	div	ebp
	mov	ebp, DWORD PTR _rs$GSCopy$1$[esp+5076]
$LN356@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1887 :         return _Ty(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	eax, DWORD PTR [edx-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 860  :         return _Unchecked_iterator(_Myhead(), nullptr);

	mov	esi, DWORD PTR _rs$GSCopy$1$[esp+5076]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 44   :            rando = ud(dr);

	cmp	eax, -2147483648			; 80000000H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	edx, DWORD PTR [ebp+12]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 44   :            rando = ud(dr);

	lea	ecx, DWORD PTR [eax-2147483648]
	lea	ebx, DWORD PTR [eax-2147483648]
	cmovae	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 860  :         return _Unchecked_iterator(_Myhead(), nullptr);

	mov	esi, DWORD PTR [esi+4]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 44   :            rando = ud(dr);

	movzx	eax, bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	eax, -2128831035			; 811c9dc5H
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 44   :            rando = ud(dr);

	mov	DWORD PTR _rando$[esp+5076], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1937 :         _Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	mov	eax, ebx
	shr	eax, 8
	movzx	eax, al
	xor	ecx, eax
	mov	eax, ebx
	imul	ecx, ecx, 16777619
	shr	eax, 16					; 00000010H
	movzx	eax, al
	xor	ecx, eax
	mov	eax, ebx
	imul	ecx, ecx, 16777619
	shr	eax, 24					; 00000018H
	xor	ecx, eax
	imul	eax, ecx, 16777619
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1153 :         return _Traitsobj(_Keyval) & _Mask;

	and	eax, DWORD PTR [ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	lea	ecx, DWORD PTR [eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1114 :         return _Vec_lo(_Bucket);

	mov	ebp, DWORD PTR [ecx+edx]
	mov	eax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	add	edx, ecx
	npad	6
$LL382@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 521  :         return _List._Unchecked_end();

	cmp	ebp, esi

; 1122 :         if (_Vec_lo(_Bucket) == _Unchecked_end()) {

	jne	SHORT $LN423@generateRa

; 1123 :             return _Unchecked_end();

	mov	ecx, esi
	jmp	SHORT $LN424@generateRa
$LN423@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	ecx, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1126 :             return ++_Ans;

	mov	ecx, DWORD PTR [ecx]
$LN424@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 767  :         for (_Unchecked_iterator _Where = _Begin(_Bucket); _Where != _End(_Bucket); ++_Where) {

	je	SHORT $LN381@generateRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 88   :         return _Left == _Right;

	cmp	DWORD PTR [eax+8], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 768  :             if (!_Traitsobj(_Traits::_Kfn(*_Where), _Keyval)) {

	je	SHORT $LN385@generateRa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LL382@generateRa
$LN385@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 769  :                 return _Traitsobj(_Keyval, _Traits::_Kfn(*_Where)) ? end() : _Make_iter(_Where);

	mov	ebp, DWORD PTR _rs$GSCopy$1$[esp+5076]
	mov	esi, DWORD PTR [ebp+4]
	jmp	SHORT $LN379@generateRa
$LN381@generateRa:
	mov	ebp, DWORD PTR _rs$GSCopy$1$[esp+5076]

; 505  :         return _List.end();

	mov	eax, esi
$LN379@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 208  :         return this->_Ptr == _Right._Ptr;

	cmp	eax, esi
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 46   :            if (f == rs.end()) {

	je	SHORT $LN659@generateRa
	mov	eax, DWORD PTR _i$1$[esp+5076]
	mov	ecx, DWORD PTR _tmp$1$[esp+5076]
$LN5@generateRa:

; 40   :        int tmp = rando;
; 41   : 
; 42   :        for (int i = 0;i<MAX;i++) {

	inc	eax
	mov	DWORD PTR _i$1$[esp+5076], eax
	cmp	eax, edi
	jl	$LL7@generateRa
	jmp	SHORT $LN2@generateRa
$LN659@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	DWORD PTR $T2[esp+5076]
	lea	eax, DWORD PTR _rando$[esp+5080]
	push	eax
	lea	eax, DWORD PTR $T5[esp+5084]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 53   :     } else {

	jmp	SHORT $LN716@generateRa
$LN8@generateRa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	DWORD PTR $T1[esp+5076]
	lea	eax, DWORD PTR _rando$[esp+5080]
	push	eax
	lea	eax, DWORD PTR $T6[esp+5084]
$LN716@generateRa:
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 35   :   for (int i=0;i<N;i++) {

	push	eax
	mov	ecx, ebp
	call	??$_Insert_unverified@$$CBHU_Not_a_node_tag@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QBHU_Not_a_node_tag@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int const ,std::_Not_a_node_tag>
$LN2@generateRa:
	sub	DWORD PTR _N$[esp+5072], 1
	jne	$LL4@generateRa
	pop	esi
	pop	ebx
$LN3@generateRa:

; 54   :        rs.insert(rando);
; 55   :     }
; 56   : 
; 57   :   }
; 58   :   	cerr << rs.size();

	push	DWORD PTR [ebp+8]
	mov	ecx, OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 59   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+5068]
	pop	edi
	pop	ebp
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 5060				; 000013c4H
	ret	0
??$generateRandom@H@@YAXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z ENDP ; generateRandom<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??B?$reference_wrapper@H@std@@QBEAAHXZ
_TEXT	SEGMENT
??B?$reference_wrapper@H@std@@QBEAAHXZ PROC		; std::reference_wrapper<int>::operator int &, COMDAT
; _this$ = ecx

; 1692 :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 1693 :     }

	ret	0
??B?$reference_wrapper@H@std@@QBEAAHXZ ENDP		; std::reference_wrapper<int>::operator int &
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$ref@H@std@@YA?AV?$reference_wrapper@H@0@AAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$ref@H@std@@YA?AV?$reference_wrapper@H@0@AAH@Z PROC	; std::ref<int>, COMDAT

; 1688 :         _Ptr      = _STD addressof(_Ref);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1717 :     return reference_wrapper<_Ty>(_Val);
; 1718 : }

	ret	0
??$ref@H@std@@YA?AV?$reference_wrapper@H@0@AAH@Z ENDP	; std::ref<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??B?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@QBEAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@XZ
_TEXT	SEGMENT
??B?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@QBEAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@XZ PROC ; std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >::operator std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &, COMDAT
; _this$ = ecx

; 1692 :         return *_Ptr;

	mov	eax, DWORD PTR [ecx]

; 1693 :     }

	ret	0
??B?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@QBEAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@1@XZ ENDP ; std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >::operator std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$ref@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YA?AV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$ref@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YA?AV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@@Z PROC ; std::ref<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >, COMDAT

; 1688 :         _Ptr      = _STD addressof(_Ref);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1717 :     return reference_wrapper<_Ty>(_Val);
; 1718 : }

	ret	0
??$ref@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@std@@YA?AV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@0@AAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@0@@Z ENDP ; std::ref<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1541 :         return *this;

	mov	eax, ecx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [ecx], 0

; 319  :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myend@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ
_TEXT	SEGMENT
?_Myend@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ PROC ; std::vector<int,std::allocator<int> >::_Myend, COMDAT
; _this$ = ecx

; 1635 :         return _Get_data()._Myend;

	lea	eax, DWORD PTR [ecx+8]

; 1636 :     }

	ret	0
?_Myend@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myend@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ
_TEXT	SEGMENT
?_Myend@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ PROC ; std::vector<int,std::allocator<int> >::_Myend, COMDAT
; _this$ = ecx

; 1631 :         return _Get_data()._Myend;

	lea	eax, DWORD PTR [ecx+8]

; 1632 :     }

	ret	0
?_Myend@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Mylast@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ
_TEXT	SEGMENT
?_Mylast@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ PROC ; std::vector<int,std::allocator<int> >::_Mylast, COMDAT
; _this$ = ecx

; 1627 :         return _Get_data()._Mylast;

	lea	eax, DWORD PTR [ecx+4]

; 1628 :     }

	ret	0
?_Mylast@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Mylast@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ
_TEXT	SEGMENT
?_Mylast@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ PROC ; std::vector<int,std::allocator<int> >::_Mylast, COMDAT
; _this$ = ecx

; 1623 :         return _Get_data()._Mylast;

	lea	eax, DWORD PTR [ecx+4]

; 1624 :     }

	ret	0
?_Mylast@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ
_TEXT	SEGMENT
?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ PROC ; std::vector<int,std::allocator<int> >::_Myfirst, COMDAT
; _this$ = ecx

; 1619 :         return _Get_data()._Myfirst;

	mov	eax, ecx

; 1620 :     }

	ret	0
?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ
_TEXT	SEGMENT
?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ PROC ; std::vector<int,std::allocator<int> >::_Myfirst, COMDAT
; _this$ = ecx

; 1615 :         return _Get_data()._Myfirst;

	mov	eax, ecx

; 1616 :     }

	ret	0
?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Get_data@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Get_data, COMDAT
; _this$ = ecx

; 1601 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1602 :     }

	ret	0
?_Get_data@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Get_data@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Get_data, COMDAT
; _this$ = ecx

; 1597 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1598 :     }

	ret	0
?_Get_data@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1593 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1594 :     }

	ret	0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1589 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1590 :     }

	ret	0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Orphan_all@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ PROC ; std::vector<int,std::allocator<int> >::_Orphan_all, COMDAT
; _this$ = ecx

; 1581 :         _Get_data()._Orphan_all();
; 1582 :     }

	ret	0
?_Orphan_all@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ENDP ; std::vector<int,std::allocator<int> >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1545 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1546 :         _Lockit _Lock(_LOCK_DEBUG);
; 1547 : 
; 1548 :         const_iterator** _Pnext = reinterpret_cast<const_iterator**>(_Getpfirst());
; 1549 : 
; 1550 :         if (_Pnext) {
; 1551 :             while (*_Pnext) {
; 1552 :                 if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr) { // skip the iterator
; 1553 :                     _Pnext = reinterpret_cast<const_iterator**>((*_Pnext)->_Getpnext());
; 1554 :                 } else { // orphan the iterator
; 1555 :                     (*_Pnext)->_Clrcont();
; 1556 :                     *_Pnext = *reinterpret_cast<const_iterator**>((*_Pnext)->_Getpnext());
; 1557 :                 }
; 1558 :             }
; 1559 :         }
; 1560 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1561 :         (void) _First;
; 1562 :         (void) _Last;
; 1563 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1564 :     }

	ret	8
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1537 :         _Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN3@Xlength:
	int	3
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1522 :     void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1523 :         _Orphan_all();
; 1524 :         auto& _My_data    = _Get_data();
; 1525 :         const auto _First = _My_data._Myfirst;

	mov	eax, DWORD PTR [esi]

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN2@Tidy

; 1527 :             _Destroy(_First, _My_data._Mylast);
; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	edx, DWORD PTR [esi+8]
	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	edx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN42@Tidy

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN39@Tidy

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN42@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1530 :             _My_data._Myfirst = pointer();

	mov	DWORD PTR [esi], 0

; 1531 :             _My_data._Mylast  = pointer();

	mov	DWORD PTR [esi+4], 0

; 1532 :             _My_data._Myend   = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1534 :     }

	pop	esi
	ret	0
$LN39@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN46@Tidy:
	int	3
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z PROC ; std::vector<int,std::allocator<int> >::_Change_array, COMDAT
; _this$ = ecx

; 1509 :         const size_type _Newcapacity) { // orphan all iterators, discard old array, acquire new array

	push	esi
	mov	esi, ecx

; 1510 :         _Orphan_all();
; 1511 : 
; 1512 :         if (_Myfirst() != pointer()) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN77@Change_arr

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	edx, DWORD PTR [esi+8]
	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	edx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN76@Change_arr

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN73@Change_arr

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN76@Change_arr:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN77@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1517 :         _Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1518 :         _Mylast()  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1519 :         _Myend()   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1520 :     }

	ret	12					; 0000000cH
$LN73@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN98@Change_arr:
	int	3
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ENDP ; std::vector<int,std::allocator<int> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z PROC ; std::vector<int,std::allocator<int> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	edx, DWORD PTR [ecx+8]

; 1473 :         const size_type _Oldcapacity = capacity();
; 1474 : 
; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	eax, 1073741823				; 3fffffffH

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	sub	edx, DWORD PTR [ecx]
	sar	edx, 2

; 1473 :         const size_type _Oldcapacity = capacity();
; 1474 : 
; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	ja	SHORT $LN31@Calculate_

; 1476 :             return _Newsize; // geometric growth would overflow
; 1477 :         }
; 1478 : 
; 1479 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1480 : 
; 1481 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp-4]
	jae	SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1482 :             return _Newsize; // geometric growth would be insufficient

	mov	eax, DWORD PTR __Newsize$[esp-4]
$LN1@Calculate_:

; 1483 :         }
; 1484 : 
; 1485 :         return _Geometric; // geometric growth is sufficient
; 1486 :     }

	ret	4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1468 :         _Destroy_range(_First, _Last, _Getal());
; 1469 :     }

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	eax, ecx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[esp+4]
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1465 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	eax, ecx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[esp+4]
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1454 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Umove@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1447 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1447 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, eax

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 1767 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1448 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	edi
	pop	esi

; 1449 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 1362 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1363 :         _STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1364 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1365 : 
; 1366 :         return _Myfirst()[_Pos];

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1367 :     }

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Has_unused_capacity@?$vector@HV?$allocator@H@std@@@std@@ABE_NXZ
_TEXT	SEGMENT
?_Has_unused_capacity@?$vector@HV?$allocator@H@std@@@std@@ABE_NXZ PROC ; std::vector<int,std::allocator<int> >::_Has_unused_capacity, COMDAT
; _this$ = ecx

; 1357 :         return _Myend() != _Mylast();

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [ecx+4]
	setne	al

; 1358 :     }

	ret	0
?_Has_unused_capacity@?$vector@HV?$allocator@H@std@@@std@@ABE_NXZ ENDP ; std::vector<int,std::allocator<int> >::_Has_unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1349 :     }

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 1343 :         return _Min_value(

	mov	eax, 1073741823				; 3fffffffH

; 1344 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1345 :     }

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1340 :     }

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ PROC	; std::vector<int,std::allocator<int> >::empty, COMDAT
; _this$ = ecx

; 1335 :         return _Myfirst() == _Mylast();

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al

; 1336 :     }

	ret	0
?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ ENDP	; std::vector<int,std::allocator<int> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC ; std::vector<int,std::allocator<int> >::pop_back, COMDAT
; _this$ = ecx

; 1195 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1196 :         _STL_VERIFY(!empty(), "vector empty before pop");
; 1197 :         _Orphan_range(_Mylast() - 1, _Mylast());
; 1198 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 
; 1200 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast() - 1));
; 1201 :         --_Mylast();

	add	DWORD PTR [ecx+4], -4			; fffffffcH

; 1202 :     }

	ret	0
?pop_back@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP ; std::vector<int,std::allocator<int> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 1357 :         return _Myend() != _Mylast();

	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [ecx+8], edx

; 637  :         if (_Has_unused_capacity()) {

	je	SHORT $LN4@push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 625  :         ++_Mylast();

	add	DWORD PTR [ecx+4], 4

; 650  :         emplace_back(_Val);
; 651  :     }

	ret	4
$LN4@push_back:

; 641  :         _Ty& _Result = *_Emplace_reallocate(_Mylast(), _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>

; 650  :         emplace_back(_Val);
; 651  :     }

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 609  :     ~vector() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 1525 :         const auto _First = _My_data._Myfirst;

	mov	eax, DWORD PTR [esi]

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN4@vector

; 1527 :             _Destroy(_First, _My_data._Mylast);
; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	edx, DWORD PTR [esi+8]
	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	edx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN44@vector

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN41@vector

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN44@vector:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1530 :             _My_data._Myfirst = pointer();

	mov	DWORD PTR [esi], 0

; 1531 :             _My_data._Mylast  = pointer();

	mov	DWORD PTR [esi+4], 0

; 1532 :             _My_data._Myend   = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 615  :     }

	ret	0
$LN41@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN49@vector:
	int	3
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [ecx], 0

; 372  :         : _Mypair(_Zero_then_variadic_args_t()) { // construct empty vector
; 373  :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 374  :     }

	mov	eax, ecx

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 372  :         : _Mypair(_Zero_then_variadic_args_t()) { // construct empty vector
; 373  :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 374  :     }

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@XZ PROC ; std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >::~unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >, COMDAT
; _this$ = ecx
	jmp	??1?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ
??1?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@XZ ENDP ; std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >::~unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
;	COMDAT ??0?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -8						; size = 8
$T3 = -8						; size = 4
__Rightnode$1$ = 8					; size = 4
$T4 = 8							; size = 1
__Right$ = 8						; size = 4
??0?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@ABV01@@Z PROC ; std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >, COMDAT
; _this$ = ecx

; 100  :                               _Right._Getal())) { // construct set by copying _Right

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 252  :         : _Traitsobj(_Right._Traitsobj), _List(static_cast<allocator_type>(_Al)),

	mov	edi, DWORD PTR __Right$[esp+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set

; 100  :                               _Right._Getal())) { // construct set by copying _Right

	mov	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 252  :         : _Traitsobj(_Right._Traitsobj), _List(static_cast<allocator_type>(_Al)),

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ebx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 521  :         return _List._Unchecked_end();

	mov	DWORD PTR $T3[esp+24], eax

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	lea	ecx, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1528 :         _My_data._Myhead = _Newhead;

	mov	DWORD PTR [ebx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	lea	eax, DWORD PTR $T4[esp+20]
	push	eax
	lea	eax, DWORD PTR $T3[esp+28]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [edi+16]
	sub	eax, DWORD PTR [edi+12]
	sar	eax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 253  :           _Vec(_Right._Vec.size(), _Unchecked_end(), static_cast<_Aliter>(_Al)), _Mask(_Right._Mask),

	push	eax
	call	??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@IABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [ebx+24], eax

; 254  :           _Maxidx(_Right._Maxidx) { // construct hash table by copying _Right

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [ebx+28], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 856  :         return _Unchecked_const_iterator(_Myhead()->_Next, nullptr);

	mov	edi, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 701  :         auto _UFirst      = _Get_unwrapped(_First);

	mov	esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	je	SHORT $LN146@unordered_
$LL147@unordered_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+8], 357913941		; 15555555H
	je	SHORT $LN378@unordered_

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Rightnode$1$[esp+24], eax

; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	ebp, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [esi+8]

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR __Rightnode$1$[esp+20]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	inc	DWORD PTR [ebx+8]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	mov	DWORD PTR [ebp], eax

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	mov	eax, DWORD PTR [eax]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 161  :         return this->_Ptr->_Myval;

	add	eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1032 :         auto _Result = _Insert_unverified(_STD move(_Val), _STD move(_Pnode));

	push	eax
	lea	eax, DWORD PTR $T2[esp+32]
	push	eax
	call	??$_Insert_unverified@HV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@$$QAHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	esi, DWORD PTR [esi]

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 703  :         for (; _UFirst != _ULast; ++_UFirst) {

	jne	SHORT $LL147@unordered_
$LN146@unordered_:
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set

; 101  :     }

	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	add	esp, 8
	ret	4
$LN378@unordered_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN384@unordered_:
	int	3
??0?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@ABV01@@Z ENDP ; std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
;	COMDAT ??0?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@XZ PROC ; std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >, COMDAT
; _this$ = ecx

; 91   :     unordered_set() : _Mybase(key_compare(), allocator_type()) { // construct empty set from defaults

	push	esi
	push	edi
	mov	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set

; 40   :     _Uset_traits(const _Tr& _Traits = _Tr()) : _Tr(_Traits) { // construct with specified comparator

	mov	DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new

; 179  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax

; 49   :         return ::operator new(_Bytes);

	push	64					; 00000040H

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [esi], esi
	mov	DWORD PTR [esi+4], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1528 :         _My_data._Myhead = _Newhead;

	mov	DWORD PTR [edi+4], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	mov	DWORD PTR [edi+12], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [edi+20], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 131  :     _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	DWORD PTR [eax+16], esi
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax+24], esi
	mov	DWORD PTR [eax+28], esi
	mov	DWORD PTR [eax+32], esi
	mov	DWORD PTR [eax+36], esi
	mov	DWORD PTR [eax+40], esi
	mov	DWORD PTR [eax+44], esi
	mov	DWORD PTR [eax+48], esi
	mov	DWORD PTR [eax+52], esi
	mov	DWORD PTR [eax+56], esi
	mov	DWORD PTR [eax+60], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set

; 92   :     }

	mov	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 389  :             _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);

	mov	DWORD PTR [edi+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 243  :           _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) { // construct empty hash table

	mov	DWORD PTR [edi+24], 7
	mov	DWORD PTR [edi+28], 8

; 244  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [edi], 1065353216		; 3f800000H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set

; 92   :     }

	pop	edi
	pop	esi
	ret	0
??0?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@QAE@XZ ENDP ; std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??1?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::~_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1525 :         const auto _First = _My_data._Myfirst;

	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+12]

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN6@Hash

; 1527 :             _Destroy(_First, _My_data._Mylast);
; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	edx, DWORD PTR [edi+20]
	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	edx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN46@Hash

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN43@Hash

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN46@Hash:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1530 :             _My_data._Myfirst = pointer();

	mov	DWORD PTR [edi+12], 0

; 1531 :             _My_data._Mylast  = pointer();

	mov	DWORD PTR [edi+16], 0

; 1532 :             _My_data._Myend   = pointer();

	mov	DWORD PTR [edi+20], 0
$LN6@Hash:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1137 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	ecx, DWORD PTR [edi+4]

; 341  :         _Head->_Prev->_Next = nullptr;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], 0

; 342  : 
; 343  :         auto _Pnode = _Head->_Next;

	mov	eax, DWORD PTR [ecx]

; 344  :         for (_Nodeptr _Pnext; _Pnode != nullptr; _Pnode = _Pnext) {

	test	eax, eax
	je	SHORT $LN68@Hash
	push	esi
	npad	2
$LL69@Hash:

; 345  :             _Pnext = _Pnode->_Next;

	mov	esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 344  :         for (_Nodeptr _Pnext; _Pnode != nullptr; _Pnode = _Pnext) {

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL69@Hash
	pop	esi
$LN68@Hash:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	DWORD PTR [edi+4]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	pop	edi
	ret	0
$LN43@Hash:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN141@Hash:
	int	3
??1?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::~_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1541 :         return *this;

	mov	eax, ecx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >, COMDAT
; _this$ = ecx

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [ecx], 0

; 319  :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myend@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Myend@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myend, COMDAT
; _this$ = ecx

; 1635 :         return _Get_data()._Myend;

	lea	eax, DWORD PTR [ecx+8]

; 1636 :     }

	ret	0
?_Myend@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myend@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Myend@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myend, COMDAT
; _this$ = ecx

; 1631 :         return _Get_data()._Myend;

	lea	eax, DWORD PTR [ecx+8]

; 1632 :     }

	ret	0
?_Myend@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Mylast@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Mylast@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Mylast, COMDAT
; _this$ = ecx

; 1627 :         return _Get_data()._Mylast;

	lea	eax, DWORD PTR [ecx+4]

; 1628 :     }

	ret	0
?_Mylast@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Mylast@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Mylast@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Mylast, COMDAT
; _this$ = ecx

; 1623 :         return _Get_data()._Mylast;

	lea	eax, DWORD PTR [ecx+4]

; 1624 :     }

	ret	0
?_Mylast@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myfirst@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myfirst, COMDAT
; _this$ = ecx

; 1619 :         return _Get_data()._Myfirst;

	mov	eax, ecx

; 1620 :     }

	ret	0
?_Myfirst@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myfirst@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myfirst, COMDAT
; _this$ = ecx

; 1615 :         return _Get_data()._Myfirst;

	mov	eax, ecx

; 1616 :     }

	ret	0
?_Myfirst@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Get_data@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Get_data, COMDAT
; _this$ = ecx

; 1601 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1602 :     }

	ret	0
?_Get_data@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Get_data@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Get_data, COMDAT
; _this$ = ecx

; 1597 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1598 :     }

	ret	0
?_Get_data@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Getal@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Getal, COMDAT
; _this$ = ecx

; 1593 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1594 :     }

	ret	0
?_Getal@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Getal@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Getal, COMDAT
; _this$ = ecx

; 1589 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1590 :     }

	ret	0
?_Getal@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Orphan_all@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 1581 :         _Get_data()._Orphan_all();
; 1582 :     }

	ret	0
?_Orphan_all@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Xlength, COMDAT

; 1537 :         _Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Tidy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Tidy, COMDAT
; _this$ = ecx

; 1522 :     void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1523 :         _Orphan_all();
; 1524 :         auto& _My_data    = _Get_data();
; 1525 :         const auto _First = _My_data._Myfirst;

	mov	eax, DWORD PTR [esi]

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN2@Tidy

; 1527 :             _Destroy(_First, _My_data._Mylast);
; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	edx, DWORD PTR [esi+8]
	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	edx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN42@Tidy

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN39@Tidy

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN42@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1530 :             _My_data._Myfirst = pointer();

	mov	DWORD PTR [esi], 0

; 1531 :             _My_data._Mylast  = pointer();

	mov	DWORD PTR [esi+4], 0

; 1532 :             _My_data._Myend   = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1534 :     }

	pop	esi
	ret	0
$LN39@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN46@Tidy:
	int	3
?_Tidy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Change_array@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@II@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Change_array, COMDAT
; _this$ = ecx

; 1509 :         const size_type _Newcapacity) { // orphan all iterators, discard old array, acquire new array

	push	esi
	mov	esi, ecx

; 1510 :         _Orphan_all();
; 1511 : 
; 1512 :         if (_Myfirst() != pointer()) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN77@Change_arr

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	edx, DWORD PTR [esi+8]
	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	edx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN76@Change_arr

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN73@Change_arr

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN76@Change_arr:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN77@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1517 :         _Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1518 :         _Mylast()  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1519 :         _Myend()   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1520 :     }

	ret	12					; 0000000cH
$LN73@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN98@Change_arr:
	int	3
?_Change_array@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@II@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1498 :     void _Buy_nonzero(const size_type _Newcapacity) { // allocate array with _Newcapacity elements

	push	esi
	push	edi

; 1499 :                                                       // pre: *this is _Tidy
; 1500 :                                                       // pre: _Newcapacity != 0
; 1501 :         if (_Newcapacity > max_size()) {

	mov	edi, DWORD PTR __Newcapacity$[esp+4]
	mov	esi, ecx
	cmp	edi, 1073741823				; 3fffffffH
	ja	SHORT $LN28@Buy_nonzer

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	push	edi
	call	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocate
	mov	DWORD PTR [esi], eax

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;

	mov	DWORD PTR [esi+4], eax

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	eax, DWORD PTR [eax+edi*4]
	pop	edi
	mov	DWORD PTR [esi+8], eax

; 1503 :         }
; 1504 : 
; 1505 :         _Buy_raw(_Newcapacity);
; 1506 :     }

	pop	esi
	ret	4
$LN28@Buy_nonzer:

; 1502 :             _Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Xlength
$LN26@Buy_nonzer:
	int	3
?_Buy_nonzero@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Buy_raw@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Buy_raw, COMDAT
; _this$ = ecx

; 1489 :     void _Buy_raw(const size_type _Newcapacity) { // allocate array with _Newcapacity elements

	push	esi

; 1490 :                                                   // pre: *this is _Tidy
; 1491 :                                                   // pre: _Newcapacity is in (0, max_size()]
; 1492 :         auto& _My_data    = _Get_data();
; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	mov	esi, DWORD PTR __Newcapacity$[esp]
	push	edi
	push	esi
	mov	edi, ecx
	call	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocate
	mov	DWORD PTR [edi], eax

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;

	mov	DWORD PTR [edi+4], eax

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1496 :     }

	ret	4
?_Buy_raw@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEII@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	edx, DWORD PTR [ecx+8]

; 1473 :         const size_type _Oldcapacity = capacity();
; 1474 : 
; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	eax, 1073741823				; 3fffffffH

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	sub	edx, DWORD PTR [ecx]
	sar	edx, 2

; 1473 :         const size_type _Oldcapacity = capacity();
; 1474 : 
; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	ja	SHORT $LN31@Calculate_

; 1476 :             return _Newsize; // geometric growth would overflow
; 1477 :         }
; 1478 : 
; 1479 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1480 : 
; 1481 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp-4]
	jae	SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1482 :             return _Newsize; // geometric growth would be insufficient

	mov	eax, DWORD PTR __Newsize$[esp-4]
$LN1@Calculate_:

; 1483 :         }
; 1484 : 
; 1485 :         return _Geometric; // geometric growth is sufficient
; 1486 :     }

	ret	4
?_Calculate_growth@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@ABEII@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Destroy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@0@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Destroy, COMDAT
; _this$ = ecx

; 1468 :         _Destroy_range(_First, _Last, _Getal());
; 1469 :     }

	ret	8
?_Destroy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@0@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Umove_if_noexcept, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 223  :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
	xor	edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1462 :         pointer _Dest) { // move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 223  :     auto _UFirst      = _Get_unwrapped(_First);

	mov	esi, DWORD PTR __Last$[esp]
	sub	esi, eax
	add	esi, 3
	shr	esi, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1462 :         pointer _Dest) { // move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 223  :     auto _UFirst      = _Get_unwrapped(_First);

	xor	edi, edi
	cmp	eax, DWORD PTR __Last$[esp+4]
	cmova	esi, edi

; 232  :         for (; _UFirst != _ULast; ++_UFirst) {

	test	esi, esi
	je	SHORT $LN11@Umove_if_n

; 131  :     _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edi, DWORD PTR __Dest$[esp+4]
	sub	edi, eax
$LL12@Umove_if_n:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 223  :     auto _UFirst      = _Get_unwrapped(_First);

	lea	eax, DWORD PTR [eax+4]

; 232  :         for (; _UFirst != _ULast; ++_UFirst) {

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [edi+eax-4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 232  :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, esi
	jne	SHORT $LL12@Umove_if_n
$LN11@Umove_if_n:
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1465 :     }

	pop	esi
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 223  :     auto _UFirst      = _Get_unwrapped(_First);

	mov	eax, DWORD PTR __First$[esp-4]
	xor	edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1452 :         pointer _First, pointer _Last, pointer _Dest, true_type) { // move [_First, _Last) to raw _Dest, using allocator

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 223  :     auto _UFirst      = _Get_unwrapped(_First);

	mov	esi, DWORD PTR __Last$[esp]
	sub	esi, eax
	add	esi, 3
	shr	esi, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1452 :         pointer _First, pointer _Last, pointer _Dest, true_type) { // move [_First, _Last) to raw _Dest, using allocator

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 223  :     auto _UFirst      = _Get_unwrapped(_First);

	xor	edi, edi
	cmp	eax, DWORD PTR __Last$[esp+4]
	cmova	esi, edi

; 232  :         for (; _UFirst != _ULast; ++_UFirst) {

	test	esi, esi
	je	SHORT $LN9@Umove_if_n

; 131  :     _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	edi, DWORD PTR __Dest$[esp+4]
	sub	edi, eax
$LL10@Umove_if_n:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 223  :     auto _UFirst      = _Get_unwrapped(_First);

	lea	eax, DWORD PTR [eax+4]

; 232  :         for (; _UFirst != _ULast; ++_UFirst) {

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [edi+eax-4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 232  :         for (; _UFirst != _ULast; ++_UFirst) {

	cmp	edx, esi
	jne	SHORT $LL10@Umove_if_n
$LN9@Umove_if_n:
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1454 :     }

	pop	esi
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Ufill@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@PAV32@IABV32@@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Ufill, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 299  :     return _Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	mov	edx, DWORD PTR __Count$[esp-4]

; 131  :     _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	eax, DWORD PTR __Dest$[esp-4]

; 281  :     for (; 0 < _Count; --_Count) {

	test	edx, edx
	je	SHORT $LN11@Ufill
	push	esi
	mov	esi, DWORD PTR __Val$[esp]
$LL12@Ufill:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 143  :         ++_Last;

	add	eax, 4

; 281  :     for (; 0 < _Count; --_Count) {

	sub	edx, 1
	jne	SHORT $LL12@Ufill
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1434 :         return _Uninitialized_fill_n(_Dest, _Count, _Val, _Getal());

	pop	esi
$LN11@Ufill:

; 1435 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@I@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::operator[], COMDAT
; _this$ = ecx

; 1362 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1363 :         _STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1364 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1365 : 
; 1366 :         return _Myfirst()[_Pos];

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1367 :     }

	ret	4
??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@I@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?capacity@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::capacity, COMDAT
; _this$ = ecx

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1349 :     }

	ret	0
?capacity@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?max_size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::max_size, COMDAT
; _this$ = ecx

; 1343 :         return _Min_value(

	mov	eax, 1073741823				; 3fffffffH

; 1344 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1345 :     }

	ret	0
?max_size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::size, COMDAT
; _this$ = ecx

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1340 :     }

	ret	0
?size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?reserve@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::reserve, COMDAT
; _this$ = ecx

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1175 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	mov	edx, DWORD PTR __Newcapacity$[esp-4]

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	sar	eax, 2

; 1175 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	edx, eax
	jbe	SHORT $LN2@reserve

; 1176 :             if (_Newcapacity > max_size()) {

	cmp	edx, 1073741823				; 3fffffffH
	ja	SHORT $LN33@reserve

; 1178 :             }
; 1179 : 
; 1180 :             _Reallocate_exactly(_Newcapacity);

	mov	DWORD PTR __Newcapacity$[esp-4], edx
	jmp	?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Reallocate_exactly
$LN2@reserve:

; 1181 :         }
; 1182 :     }

	ret	4
$LN33@reserve:

; 1177 :                 _Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Xlength
$LN31@reserve:
	int	3
?reserve@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Clear_and_reserve_geometric@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Clear_and_reserve_geometric, COMDAT
; _this$ = ecx

; 1152 :     void _Clear_and_reserve_geometric(const size_type _Newsize) { // pre: _Newsize != 0

	push	esi
	push	edi

; 1153 :                                                                   // pre: All iterators are orphaned
; 1154 :         if (_Newsize > max_size()) {

	mov	edi, DWORD PTR __Newsize$[esp+4]
	mov	esi, ecx
	cmp	edi, 1073741823				; 3fffffffH
	ja	$LN94@Clear_and_

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	edx, DWORD PTR [esi+8]

; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	eax, 1073741823				; 3fffffffH

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	ecx, DWORD PTR [esi]
	sub	edx, ecx
	sar	edx, 2
	push	ebx

; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	ebx, edx
	shr	ebx, 1
	sub	eax, ebx
	cmp	edx, eax
	ja	SHORT $LN19@Clear_and_

; 1476 :             return _Newsize; // geometric growth would overflow
; 1477 :         }
; 1478 : 
; 1479 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ebx+edx]

; 1480 : 
; 1481 :         if (_Geometric < _Newsize) {

	cmp	eax, edi
	cmovb	eax, edi
	mov	edi, eax
$LN19@Clear_and_:

; 1156 :         }
; 1157 : 
; 1158 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1159 :         auto& _My_data               = _Get_data();
; 1160 :         if (_My_data._Myfirst != pointer()) { // destroy and deallocate old array

	test	ecx, ecx
	je	SHORT $LN3@Clear_and_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	shl	edx, 2

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN77@Clear_and_

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ebx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ecx, ebx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN74@Clear_and_

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ecx, ebx
$LN77@Clear_and_:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1164 :             _My_data._Myfirst = pointer();

	mov	DWORD PTR [esi], 0

; 1165 :             _My_data._Mylast  = pointer();

	mov	DWORD PTR [esi+4], 0

; 1166 :             _My_data._Myend   = pointer();

	mov	DWORD PTR [esi+8], 0
$LN3@Clear_and_:

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	push	edi
	mov	ecx, esi
	call	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocate
	mov	DWORD PTR [esi], eax

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;

	mov	DWORD PTR [esi+4], eax
	pop	ebx

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	eax, DWORD PTR [eax+edi*4]
	pop	edi
	mov	DWORD PTR [esi+8], eax

; 1167 :         }
; 1168 : 
; 1169 :         _Buy_raw(_Newcapacity);
; 1170 :     }

	pop	esi
	ret	4
$LN74@Clear_and_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN95@Clear_and_:
$LN94@Clear_and_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1155 :             _Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Xlength
$LN92@Clear_and_:
	int	3
?_Clear_and_reserve_geometric@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newvec$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1137 :             _Newcapacity) { // set capacity to _Newcapacity (without geometric growth), provide strong guarantee

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, DWORD PTR [esi]
	sar	ebx, 2

; 1138 :         const size_type _Size = size();
; 1139 : 
; 1140 :         const pointer _Newvec = _Getal().allocate(_Newcapacity);

	push	DWORD PTR __Newcapacity$[ebp]
	call	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocate
	mov	edi, eax
	mov	DWORD PTR __Newvec$[ebp], edi

; 1141 : 
; 1142 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1143 :         _Umove_if_noexcept(_Myfirst(), _Mylast(), _Newvec);

	push	edi
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	mov	ecx, esi
	call	?_Umove_if_noexcept@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Umove_if_noexcept
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1512 :         if (_Myfirst() != pointer()) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN114@Reallocate

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	ecx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN113@Reallocate

; 107  :     _Bytes += _Non_user_size;

	add	ecx, 35					; 00000023H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN110@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN113@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN114@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1517 :         _Myfirst() = _Newvec;

	mov	DWORD PTR [esi], edi

; 1518 :         _Mylast()  = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [esi+4], eax

; 1519 :         _Myend()   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi+8], eax

; 1150 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z$0:

; 1144 :         _CATCH_ALL
; 1145 :         _Getal().deallocate(_Newvec, _Newcapacity);

	push	DWORD PTR __Newcapacity$[ebp]
	push	DWORD PTR __Newvec$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEAAV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::deallocate

; 1146 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN110@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN137@Reallocate:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Reallocate_exactly
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?assign@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ptr_container$1$ = 12					; size = 4
__Val$ = 12						; size = 4
?assign@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::assign, COMDAT
; _this$ = ecx

; 945  :     void assign(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty& _Val) { // assign _Newsize * _Val

	push	ebx
	push	esi

; 946  :         _Orphan_all();
; 947  : 
; 948  :         size_type _Oldsize = size();
; 949  : 
; 950  :         if (_Newsize > _Oldsize) {

	mov	esi, DWORD PTR __Newsize$[esp+4]
	push	edi
	mov	edi, ecx

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, eax
	mov	ecx, DWORD PTR [edi]
	sub	ebx, ecx
	sar	ebx, 2

; 946  :         _Orphan_all();
; 947  : 
; 948  :         size_type _Oldsize = size();
; 949  : 
; 950  :         if (_Newsize > _Oldsize) {

	cmp	esi, ebx
	jbe	$LN2@assign

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	edx, DWORD PTR [edi+8]
	sub	edx, ecx
	sar	edx, 2
	push	ebp

; 951  :             if (_Newsize > capacity()) { // reallocate

	mov	ebp, DWORD PTR __Val$[esp+12]
	cmp	esi, edx
	jbe	$LN4@assign

; 1154 :         if (_Newsize > max_size()) {

	cmp	esi, 1073741823				; 3fffffffH
	ja	$LN230@assign

; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	ebx, edx
	mov	eax, 1073741823				; 3fffffffH
	shr	ebx, 1
	sub	eax, ebx
	cmp	edx, eax
	jbe	SHORT $LN60@assign

; 1476 :             return _Newsize; // geometric growth would overflow

	mov	ebx, esi
	jmp	SHORT $LN61@assign
$LN60@assign:

; 1477 :         }
; 1478 : 
; 1479 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	ebx, edx

; 1480 : 
; 1481 :         if (_Geometric < _Newsize) {

	cmp	ebx, esi
	cmovb	ebx, esi
$LN61@assign:

; 1160 :         if (_My_data._Myfirst != pointer()) { // destroy and deallocate old array

	test	ecx, ecx
	je	SHORT $LN45@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	shl	edx, 2

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN119@assign

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ecx, eax
	mov	DWORD PTR __Ptr_container$1$[esp+12], eax

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, 31					; 0000001fH
	ja	$LN116@assign

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr_container$1$[esp+12]
$LN119@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1164 :             _My_data._Myfirst = pointer();

	mov	DWORD PTR [edi], 0

; 1165 :             _My_data._Mylast  = pointer();

	mov	DWORD PTR [edi+4], 0

; 1166 :             _My_data._Myend   = pointer();

	mov	DWORD PTR [edi+8], 0
$LN45@assign:

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	push	ebx
	mov	ecx, edi
	call	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocate
	mov	edx, eax
	mov	DWORD PTR [edi], edx

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;

	mov	DWORD PTR [edi+4], edx

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	ecx, DWORD PTR [edx+ebx*4]

; 952  :                 _Clear_and_reserve_geometric(_Newsize);
; 953  :                 _Oldsize = 0;

	xor	ebx, ebx

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	mov	DWORD PTR [edi+8], ecx

; 954  :             } else {

	jmp	SHORT $LN5@assign
$LN4@assign:

; 955  :                 _Fill_unchecked(_Myfirst(), _Mylast(), _Val);

	push	ebp
	push	eax
	push	ecx
	call	??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z ; std::_Fill_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
	mov	edx, DWORD PTR [edi+4]
	add	esp, 12					; 0000000cH
$LN5@assign:

; 958  :             _Mylast() = _Ufill(_Mylast(), _Newsize - _Oldsize, _Val);

	sub	esi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 281  :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN162@assign
	npad	4
$LL163@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 143  :         ++_Last;

	add	edx, 4

; 281  :     for (; 0 < _Count; --_Count) {

	sub	esi, 1
	jne	SHORT $LL163@assign
$LN162@assign:
	pop	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 958  :             _Mylast() = _Ufill(_Mylast(), _Newsize - _Oldsize, _Val);

	mov	DWORD PTR [edi+4], edx
	pop	edi

; 965  :     }

	pop	esi
	pop	ebx
	ret	8
$LN2@assign:

; 959  :         } else {
; 960  :             const pointer _Newlast = _Myfirst() + _Newsize;
; 961  :             _Fill_unchecked(_Myfirst(), _Newlast, _Val);

	push	DWORD PTR __Val$[esp+8]
	lea	esi, DWORD PTR [ecx+esi*4]
	push	esi
	push	ecx
	call	??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z ; std::_Fill_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
	add	esp, 12					; 0000000cH

; 962  :             _Destroy(_Newlast, _Mylast());
; 963  :             _Mylast() = _Newlast;

	mov	DWORD PTR [edi+4], esi
	pop	edi

; 965  :     }

	pop	esi
	pop	ebx
	ret	8
$LN230@assign:

; 1155 :             _Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Xlength
$LN231@assign:
$LN116@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN232@assign:
$LN228@assign:
	int	3
?assign@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??1?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::~vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >, COMDAT
; _this$ = ecx

; 609  :     ~vector() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 1525 :         const auto _First = _My_data._Myfirst;

	mov	eax, DWORD PTR [esi]

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN4@vector

; 1527 :             _Destroy(_First, _My_data._Mylast);
; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	edx, DWORD PTR [esi+8]
	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	edx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN44@vector

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN41@vector

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN44@vector:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1530 :             _My_data._Myfirst = pointer();

	mov	DWORD PTR [esi], 0

; 1531 :             _My_data._Mylast  = pointer();

	mov	DWORD PTR [esi+4], 0

; 1532 :             _My_data._Myend   = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 615  :     }

	ret	0
$LN41@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN49@vector:
	int	3
??1?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::~vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@IABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
__Al$ = 16						; size = 4
??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@IABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >, COMDAT
; _this$ = ecx

; 402  :     vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())

	push	esi

; 386  :         if (_Count != 0) {

	mov	esi, DWORD PTR __Count$[esp]

; 402  :     vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())

	push	edi
	mov	edi, ecx

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0

; 386  :         if (_Count != 0) {

	test	esi, esi
	je	SHORT $LN90@vector

; 1501 :         if (_Newcapacity > max_size()) {

	cmp	esi, 1073741823				; 3fffffffH
	ja	SHORT $LN101@vector

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	push	esi
	call	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocate
	mov	DWORD PTR [edi], eax

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;

	mov	DWORD PTR [edi+4], eax

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	ecx, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edi+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 281  :     for (; 0 < _Count; --_Count) {

	test	esi, esi
	je	SHORT $LN60@vector
	mov	edx, DWORD PTR __Val$[esp+4]
$LL61@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 143  :         ++_Last;

	add	eax, 4

; 281  :     for (; 0 < _Count; --_Count) {

	sub	esi, 1
	jne	SHORT $LL61@vector
$LN60@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 389  :             _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);

	mov	DWORD PTR [edi+4], eax
$LN90@vector:

; 403  :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Count * _Val, optional allocator
; 404  :         _Construct_n_copies_of_ty(_Count, _Val);
; 405  :     }

	mov	eax, edi
	pop	edi
	pop	esi
	ret	12					; 0000000cH
$LN101@vector:

; 1502 :             _Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Xlength
$LN99@vector:
	int	3
??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@QAE@IABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@ABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@1@@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::max_size, COMDAT

; 828  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 1073741823				; 3fffffffH

; 829  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocate, COMDAT
; _this$ = ecx

; 25   :     size_t _Result                 = _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax*4]

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN4@allocate

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	or	ecx, -1

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN27@allocate
$LN4@allocate:
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN7@allocate
$LN27@allocate:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 93   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN16@allocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN7@allocate:

; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN8@allocate

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN8@allocate:

; 182  :     return nullptr;

	xor	eax, eax

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN16@allocate:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	__invalid_parameter_noinfo_noreturn
$LN28@allocate:
	int	3
?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::deallocate, COMDAT
; _this$ = ecx

; 924  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Ptr$[esp-4]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 926  :     }

	ret	8
$LN12@deallocate:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Getal@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Getal, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1559 :         return _Mypair._Get_first();

	lea	eax, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1248 :     }

	ret	0
?_Getal@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABMXZ
_TEXT	SEGMENT
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABMXZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Max_bucket_size, COMDAT
; _this$ = ecx

; 1239 :         return _Traitsobj._Get_max_bucket_size();

	mov	eax, ecx

; 1240 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABMXZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAMXZ
_TEXT	SEGMENT
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAMXZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Max_bucket_size, COMDAT
; _this$ = ecx

; 1235 :         return _Traitsobj._Get_max_bucket_size();

	mov	eax, ecx

; 1236 :     }

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAMXZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xbit_ops.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xbit_ops.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xbit_ops.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xbit_ops.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Forced_rehash@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__Ptr_container$1$ = -16				; size = 4
__Oldsize$1$ = -12					; size = 4
__Buckets$2$ = -8					; size = 4
$T3 = -8						; size = 8
tv1007 = 8						; size = 4
__Newcapacity$1$ = 8					; size = 4
$T4 = 8							; size = 4
__Buckets$ = 8						; size = 4
?_Forced_rehash@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXI@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Forced_rehash, COMDAT
; _this$ = ecx

; 1188 :     void _Forced_rehash(size_type _Buckets) {

	sub	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xbit_ops.h

; 40   :     _BitScanReverse(&_Result, _Value);

	mov	eax, 536870911				; 1fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1196 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	edx, 1
	push	ebx
	mov	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xbit_ops.h

; 40   :     _BitScanReverse(&_Result, _Value);

	bsr	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1196 :         const auto _Max_storage_buckets               = static_cast<size_type>(1) << _Max_storage_buckets_log2;

	mov	eax, edx
	shl	eax, cl

; 1197 :         if (_Buckets > _Max_storage_buckets) {

	mov	ecx, DWORD PTR __Buckets$[esp+16]
	cmp	ecx, eax
	ja	$LN368@Forced_reh
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xbit_ops.h

; 49   :     return 1 + _Floor_of_log_2(_Value - 1);

	lea	eax, DWORD PTR [ecx-1]

; 22   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	eax, edx

; 40   :     _BitScanReverse(&_Result, _Value);

	bsr	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	eax, DWORD PTR [ebx+20]
	push	ebp
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xbit_ops.h

; 49   :     return 1 + _Floor_of_log_2(_Value - 1);

	lea	ecx, DWORD PTR [ecx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1205 :         _Buckets = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	shl	edx, cl

; 1206 : 
; 1207 :         _STL_INTERNAL_CHECK(_Vec.capacity() <= 2 * _Buckets);
; 1208 :         _Vec.reserve(2 * _Buckets); // avoid curdling _Vec if exception occurs; this could have better perf

	lea	edi, DWORD PTR [ebx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	ecx, DWORD PTR [edi]
	sub	eax, ecx
	sar	eax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1205 :         _Buckets = static_cast<size_type>(1) << _Ceiling_of_log_2(static_cast<size_t>(_Buckets));

	mov	DWORD PTR __Buckets$2$[esp+32], edx

; 1206 : 
; 1207 :         _STL_INTERNAL_CHECK(_Vec.capacity() <= 2 * _Buckets);
; 1208 :         _Vec.reserve(2 * _Buckets); // avoid curdling _Vec if exception occurs; this could have better perf

	lea	ebp, DWORD PTR [edx+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1175 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

	cmp	ebp, eax
	jbe	SHORT $LN28@Forced_reh

; 1176 :             if (_Newcapacity > max_size()) {

	cmp	ebp, 1073741823				; 3fffffffH
	ja	$LN362@Forced_reh

; 1177 :                 _Xlength();
; 1178 :             }
; 1179 : 
; 1180 :             _Reallocate_exactly(_Newcapacity);

	push	ebp
	mov	ecx, edi
	call	?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Reallocate_exactly
	mov	ecx, DWORD PTR [edi]
$LN28@Forced_reh:

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 521  :         return _List._Unchecked_end();

	mov	esi, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	sub	eax, ecx
	sar	eax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 521  :         return _List._Unchecked_end();

	mov	DWORD PTR $T4[esp+28], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	DWORD PTR __Oldsize$1$[esp+32], eax

; 950  :         if (_Newsize > _Oldsize) {

	cmp	ebp, eax
	jbe	$LN75@Forced_reh

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	edx, DWORD PTR [edi+8]
	sub	edx, ecx
	sar	edx, 2

; 951  :             if (_Newsize > capacity()) { // reallocate

	cmp	ebp, edx
	jbe	$LN77@Forced_reh

; 1154 :         if (_Newsize > max_size()) {

	cmp	ebp, 1073741823				; 3fffffffH
	ja	$LN362@Forced_reh

; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	eax, edx
	shr	eax, 1
	mov	DWORD PTR tv1007[esp+28], eax
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, DWORD PTR tv1007[esp+28]
	cmp	edx, eax
	jbe	SHORT $LN133@Forced_reh

; 1476 :             return _Newsize; // geometric growth would overflow

	mov	DWORD PTR __Newcapacity$1$[esp+28], ebp
	jmp	SHORT $LN134@Forced_reh
$LN133@Forced_reh:

; 1477 :         }
; 1478 : 
; 1479 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	mov	eax, DWORD PTR tv1007[esp+28]
	add	eax, edx

; 1480 : 
; 1481 :         if (_Geometric < _Newsize) {

	cmp	eax, ebp
	cmovb	eax, ebp
	mov	DWORD PTR __Newcapacity$1$[esp+28], eax
$LN134@Forced_reh:

; 1160 :         if (_My_data._Myfirst != pointer()) { // destroy and deallocate old array

	test	ecx, ecx
	je	SHORT $LN118@Forced_reh
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	shl	edx, 2

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN192@Forced_reh

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ecx, eax
	mov	DWORD PTR __Ptr_container$1$[esp+32], eax

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [ecx-4]
	cmp	eax, 31					; 0000001fH
	ja	$LN189@Forced_reh

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr_container$1$[esp+32]
$LN192@Forced_reh:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1164 :             _My_data._Myfirst = pointer();

	mov	DWORD PTR [edi], 0

; 1165 :             _My_data._Mylast  = pointer();

	mov	DWORD PTR [edi+4], 0

; 1166 :             _My_data._Myend   = pointer();

	mov	DWORD PTR [edi+8], 0
$LN118@Forced_reh:

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	push	DWORD PTR __Newcapacity$1$[esp+28]
	mov	ecx, edi
	call	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >::allocate
	mov	edx, eax
	mov	DWORD PTR $T2[esp+32], eax

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;
; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$1$[esp+28]
	mov	DWORD PTR [edi], edx
	mov	DWORD PTR [edi+4], edx
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edi+8], eax

; 953  :                 _Oldsize = 0;

	xor	eax, eax

; 954  :             } else {

	jmp	SHORT $LN78@Forced_reh
$LN77@Forced_reh:

; 955  :                 _Fill_unchecked(_Myfirst(), _Mylast(), _Val);

	lea	eax, DWORD PTR $T4[esp+28]
	push	eax
	push	DWORD PTR [edi+4]
	push	ecx
	call	??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z ; std::_Fill_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
	mov	edx, DWORD PTR [edi+4]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR __Oldsize$1$[esp+32]
	mov	DWORD PTR $T2[esp+32], edx
$LN78@Forced_reh:

; 956  :             }
; 957  : 
; 958  :             _Mylast() = _Ufill(_Mylast(), _Newsize - _Oldsize, _Val);

	sub	ebp, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 281  :     for (; 0 < _Count; --_Count) {

	je	SHORT $LN236@Forced_reh
	mov	edi, edx
	mov	ecx, ebp
	mov	eax, esi
	lea	edx, DWORD PTR [edx+ebp*4]
	rep stosd
	mov	DWORD PTR $T2[esp+32], edx
	lea	edi, DWORD PTR [ebx+12]
$LN236@Forced_reh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 959  :         } else {

	mov	esi, DWORD PTR $T2[esp+32]
	jmp	SHORT $LN76@Forced_reh
$LN75@Forced_reh:

; 960  :             const pointer _Newlast = _Myfirst() + _Newsize;
; 961  :             _Fill_unchecked(_Myfirst(), _Newlast, _Val);

	lea	eax, DWORD PTR $T4[esp+28]
	push	eax
	lea	esi, DWORD PTR [ecx+ebp*4]
	push	esi
	push	ecx
	call	??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z ; std::_Fill_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
	add	esp, 12					; 0000000cH
$LN76@Forced_reh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1210 :         _Mask   = _Buckets - 1;

	mov	DWORD PTR [edi+4], esi
	mov	ecx, DWORD PTR __Buckets$2$[esp+32]

; 1211 :         _Maxidx = _Buckets;

	mov	DWORD PTR [ebx+28], ecx
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR [ebx+24], eax

; 521  :         return _List._Unchecked_end();

	mov	edi, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	DWORD PTR [edi], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1218 :         if (_First != _Last) {

	je	SHORT $LN363@Forced_reh
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 61   :         _Ptr = _Ptr->_Prev;

	mov	edi, DWORD PTR [edi+4]
$LL2@Forced_reh:

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	esi, DWORD PTR [ebx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1222 :                 _Insert_unverified(*_First, _First);

	mov	ecx, ebx
	mov	esi, DWORD PTR [esi]
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 42   :         return _Ptr->_Myval;

	lea	eax, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1222 :                 _Insert_unverified(*_First, _First);

	push	eax
	lea	eax, DWORD PTR $T3[esp+40]
	push	eax
	call	??$_Insert_unverified@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@std@@_N@1@ABHV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Insert_unverified<int const &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1223 :                 if (_Done) {

	jne	SHORT $LL2@Forced_reh
$LN363@Forced_reh:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1232 :     }

	add	esp, 16					; 00000010H
	ret	4
$LN368@Forced_reh:

; 1198 :             _Xlength_error("invalid hash bucket count");

	push	OFFSET ??_C@_0BK@OGNNAFAB@invalid?5hash?5bucket?5count@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN362@Forced_reh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1155 :             _Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0>,std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<int> >,std::_Iterator_base0> > >::_Xlength
$LN369@Forced_reh:
$LN189@Forced_reh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN370@Forced_reh:
$LN366@Forced_reh:
	int	3
?_Forced_rehash@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXI@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Forced_rehash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Check_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
tv243 = -8						; size = 8
tv237 = -8						; size = 8
?_Check_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Check_size, COMDAT
; _this$ = ecx

; 1178 :     void _Check_size() { // grow table as needed

	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 643  :         return static_cast<float>(size()) / static_cast<float>(bucket_count());

	mov	eax, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+28]

; 1179 :         if (max_load_factor() < load_factor()) { // rehash to bigger table

	movss	xmm3, DWORD PTR [edi]
	movd	xmm0, eax

; 643  :         return static_cast<float>(size()) / static_cast<float>(bucket_count());

	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, esi
	shr	eax, 31					; 0000001fH
	cvtpd2ps xmm2, xmm0
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	movaps	xmm1, xmm2
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0

; 1179 :         if (max_load_factor() < load_factor()) { // rehash to bigger table

	comiss	xmm1, xmm3
	jbe	SHORT $LN2@Check_size

; 1158 :         return static_cast<size_type>(_CSTD ceilf(size() / max_load_factor()));

	divss	xmm2, xmm3
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 644  :             return (float)ceil(_X);

	sub	esp, 8
	cvtps2pd xmm0, xmm2
	movsd	QWORD PTR tv243[esp+24], xmm0
	fld	QWORD PTR tv243[esp+24]
	fstp	QWORD PTR [esp]
	call	_ceil
	fstp	QWORD PTR tv237[esp+24]
	movsd	xmm0, QWORD PTR tv237[esp+24]
	add	esp, 8
	cvtpd2ps xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1158 :         return static_cast<size_type>(_CSTD ceilf(size() / max_load_factor()));

	call	__ftoui3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 8
	cmp	eax, ecx
	cmova	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1164 :         if (_Old_buckets >= _Req_buckets) {

	cmp	esi, ecx
	jae	SHORT $LN28@Check_size

; 1165 :             // we already have enough buckets so there's no need to change the count
; 1166 :             return _Old_buckets;
; 1167 :         }
; 1168 : 
; 1169 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	esi, 512				; 00000200H
	jae	SHORT $LN30@Check_size
	shl	esi, 3
	cmp	esi, ecx
	jae	SHORT $LN28@Check_size
$LN30@Check_size:

; 1170 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1171 :             return _Old_buckets * 8;
; 1172 :         }
; 1173 : 
; 1174 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1175 :         return _Req_buckets;

	mov	esi, ecx
$LN28@Check_size:

; 1180 :             _Forced_rehash(_Desired_grow_bucket_count());

	push	esi
	mov	ecx, edi
	call	?_Forced_rehash@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXI@Z ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Forced_rehash
$LN2@Check_size:

; 1181 :         }
; 1182 :     }

	pop	edi
	pop	esi
	add	esp, 8
	ret	0
?_Check_size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Check_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIXZ
_TEXT	SEGMENT
tv190 = -8						; size = 8
tv184 = -8						; size = 8
?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIXZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Desired_grow_bucket_count, COMDAT
; _this$ = ecx

; 1161 :     _NODISCARD size_type _Desired_grow_bucket_count() const noexcept {

	sub	esp, 8

; 1158 :         return static_cast<size_type>(_CSTD ceilf(size() / max_load_factor()));

	mov	eax, DWORD PTR [ecx+8]

; 1161 :     _NODISCARD size_type _Desired_grow_bucket_count() const noexcept {

	push	esi

; 572  :         return _Maxidx;

	mov	esi, DWORD PTR [ecx+28]
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 644  :             return (float)ceil(_X);

	sub	esp, 8
	movd	xmm0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1158 :         return static_cast<size_type>(_CSTD ceilf(size() / max_load_factor()));

	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm0, DWORD PTR [ecx]
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 644  :             return (float)ceil(_X);

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv190[esp+20], xmm0
	fld	QWORD PTR tv190[esp+20]
	fstp	QWORD PTR [esp]
	call	_ceil
	fstp	QWORD PTR tv184[esp+20]
	movsd	xmm0, QWORD PTR tv184[esp+20]
	add	esp, 8
	cvtpd2ps xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1158 :         return static_cast<size_type>(_CSTD ceilf(size() / max_load_factor()));

	call	__ftoui3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	ecx, 8
	cmp	eax, ecx
	cmova	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1164 :         if (_Old_buckets >= _Req_buckets) {

	cmp	esi, ecx
	jb	SHORT $LN2@Desired_gr

; 1165 :             // we already have enough buckets so there's no need to change the count
; 1166 :             return _Old_buckets;

	mov	eax, esi
	pop	esi

; 1176 :     }

	add	esp, 8
	ret	0
$LN2@Desired_gr:

; 1167 :         }
; 1168 : 
; 1169 :         if (_Old_buckets < 512 && _Old_buckets * 8 >= _Req_buckets) {

	cmp	esi, 512				; 00000200H
	jae	SHORT $LN3@Desired_gr
	lea	eax, DWORD PTR [esi*8]
	cmp	eax, ecx
	jae	SHORT $LN1@Desired_gr
$LN3@Desired_gr:

; 1170 :             // if we are changing the bucket count and have less than 512 buckets, use 8x more buckets
; 1171 :             return _Old_buckets * 8;
; 1172 :         }
; 1173 : 
; 1174 :         // power of 2 invariant means this will result in at least 2*_Old_buckets after round up in _Forced_rehash
; 1175 :         return _Req_buckets;

	mov	eax, ecx
$LN1@Desired_gr:
	pop	esi

; 1176 :     }

	add	esp, 8
	ret	0
?_Desired_grow_bucket_count@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIXZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Desired_grow_bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIXZ
_TEXT	SEGMENT
tv94 = -8						; size = 8
tv84 = -8						; size = 8
?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIXZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Min_load_factor_buckets, COMDAT
; _this$ = ecx

; 1156 :     _NODISCARD size_type _Min_load_factor_buckets() const noexcept {

	sub	esp, 8

; 1158 :         return static_cast<size_type>(_CSTD ceilf(size() / max_load_factor()));

	mov	eax, DWORD PTR [ecx+8]
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 644  :             return (float)ceil(_X);

	sub	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1158 :         return static_cast<size_type>(_CSTD ceilf(size() / max_load_factor()));

	cvtsi2sd xmm0, eax
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm0, DWORD PTR [ecx]
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 644  :             return (float)ceil(_X);

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv94[esp+16], xmm0
	fld	QWORD PTR tv94[esp+16]
	fstp	QWORD PTR [esp]
	call	_ceil
	fstp	QWORD PTR tv84[esp+16]
	movsd	xmm0, QWORD PTR tv84[esp+16]
	cvtpd2ps xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1159 :     }

	add	esp, 16					; 00000010H

; 1158 :         return static_cast<size_type>(_CSTD ceilf(size() / max_load_factor()));

	jmp	__ftoui3
?_Min_load_factor_buckets@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIXZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Min_load_factor_buckets
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Hashval@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Hashval@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIABH@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hashval, COMDAT
; _this$ = ecx

; 1152 :     size_type _Hashval(const key_type& _Keyval) const { // return hash value, masked to current table size

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	esi, DWORD PTR __Keyval$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1152 :     size_type _Hashval(const key_type& _Keyval) const { // return hash value, masked to current table size

	push	edi
	mov	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [esi]
	xor	eax, -2128831035			; 811c9dc5H

; 1937 :         _Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [esi+1]
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+2]
	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+3]
	imul	ecx, edx, 16777619
	xor	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1153 :         return _Traitsobj(_Keyval) & _Mask;

	mov	eax, DWORD PTR [edi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1937 :         _Val *= _FNV_prime;

	imul	ecx, ecx, 16777619
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1153 :         return _Traitsobj(_Keyval) & _Mask;

	pop	edi
	pop	esi
	and	eax, ecx

; 1154 :     }

	ret	4
?_Hashval@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEIABH@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hashval
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Erase_bucket@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@I@Z
_TEXT	SEGMENT
__Plist_arg$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_Erase_bucket@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Erase_bucket, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	eax, DWORD PTR __Bucket$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1138 :     void _Erase_bucket(iterator _Plist_arg, size_type _Bucket) { // fix iterators before erasing _Plist before _Where

	push	esi
	mov	esi, ecx
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	lea	edi, DWORD PTR [eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Plist_arg$[esp+4]
	mov	edx, DWORD PTR [esi+12]
	add	edx, edi
	mov	ecx, DWORD PTR [edx]
	cmp	DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1140 :         if (_Vec_hi(_Bucket) == _Plist) {

	jne	SHORT $LN2@Erase_buck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1141 :             if (_Vec_lo(_Bucket) == _Plist) { // make bucket empty

	jne	SHORT $LN4@Erase_buck

; 1142 :                 _Vec_lo(_Bucket) = _Unchecked_end();

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], eax

; 1143 :                 _Vec_hi(_Bucket) = _Unchecked_end();

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+ecx+4], eax
	pop	edi

; 1149 :         }
; 1150 :     }

	pop	esi
	ret	8
$LN4@Erase_buck:

; 1144 :             } else {
; 1145 :                 _Vec_hi(_Bucket) = --_Plist; // move end back one element

	mov	eax, DWORD PTR [eax+4]
	pop	edi
	mov	DWORD PTR [edx+4], eax

; 1149 :         }
; 1150 :     }

	pop	esi
	ret	8
$LN2@Erase_buck:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1147 :         } else if (_Vec_lo(_Bucket) == _Plist) {

	jne	SHORT $LN6@Erase_buck

; 1148 :             _Vec_lo(_Bucket) = ++_Plist; // move beginning up one element

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN6@Erase_buck:

; 1149 :         }
; 1150 :     }

	pop	edi
	pop	esi
	ret	8
?_Erase_bucket@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Erase_bucket
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_End@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_End@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_End, COMDAT
; _this$ = ecx

; 521  :         return _List._Unchecked_end();

	mov	edx, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Bucket$[esp-4]
	cmp	DWORD PTR [ecx+eax*8], edx
	lea	eax, DWORD PTR [ecx+eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1122 :         if (_Vec_lo(_Bucket) == _Unchecked_end()) {

	jne	SHORT $LN2@End

; 521  :         return _List._Unchecked_end();

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 1127 :         }
; 1128 :     }

	ret	8
$LN2@End:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1126 :             return ++_Ans;

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1127 :         }
; 1128 :     }

	ret	8
?_End@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_End
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_Begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Begin, COMDAT
; _this$ = ecx

; 1114 :         return _Vec_lo(_Bucket);

	mov	eax, DWORD PTR __Bucket$[esp-4]
	mov	ecx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 1115 :     }

	ret	8
?_Begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Vec_hi@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Vec_hi@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Vec_hi, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	eax, DWORD PTR __Bucket$[esp-4]
	mov	ecx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [eax*8+4]
	add	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1107 :     }

	ret	4
?_Vec_hi@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Vec_hi
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Vec_lo@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Vec_lo@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Vec_lo, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Bucket$[esp-4]
	lea	eax, DWORD PTR [ecx+eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1099 :     }

	ret	4
?_Vec_lo@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Vec_lo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXU_Not_a_node_tag@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXU_Not_a_node_tag@2@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Destroy_if_node, COMDAT
; _this$ = ecx

; 884  :     }

	ret	4
?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXU_Not_a_node_tag@2@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Destroy_if_node
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Destroy_if_node, COMDAT
; _this$ = ecx

; 879  :     void _Destroy_if_node(_Unchecked_iterator _Plist) { // node exists, destroy it

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1060 :         auto _Pnode = _Where._Ptr;

	mov	esi, DWORD PTR __Plist$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1062 :         _Pnode->_Prev->_Next = _Pnode->_Next;

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx], eax

; 1063 :         _Pnode->_Next->_Prev = _Pnode->_Prev;

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+4], eax

; 1064 :         --_Mysize();

	dec	DWORD PTR [ecx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 881  :     }

	ret	4
?_Destroy_if_node@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Destroy_if_node
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?lower_bound@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@ABH@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::lower_bound, COMDAT
; _this$ = ecx

; 765  :         const key_type& _Keyval) { // find leftmost not less than _Keyval in mutable hash table

	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	ebx, DWORD PTR __Keyval$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 765  :         const key_type& _Keyval) { // find leftmost not less than _Keyval in mutable hash table

	push	ebp
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 765  :         const key_type& _Keyval) { // find leftmost not less than _Keyval in mutable hash table

	mov	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	eax, -2128831035			; 811c9dc5H

; 1937 :         _Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	esi, DWORD PTR [edi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	edx, eax
	movzx	eax, BYTE PTR [ebx+2]

; 1937 :         _Val *= _FNV_prime;

	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [ebx+3]
	imul	ecx, edx, 16777619
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 860  :         return _Unchecked_iterator(_Myhead(), nullptr);

	mov	edx, DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	ecx, eax

; 1937 :         _Val *= _FNV_prime;

	imul	eax, ecx, 16777619
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1153 :         return _Traitsobj(_Keyval) & _Mask;

	mov	ecx, DWORD PTR [edi+24]
	and	ecx, eax

; 1114 :         return _Vec_lo(_Bucket);

	mov	ebp, DWORD PTR [esi+ecx*8]
	mov	eax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	lea	esi, DWORD PTR [esi+ecx*8]
	npad	1
$LL4@lower_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 521  :         return _List._Unchecked_end();

	cmp	ebp, edx

; 1122 :         if (_Vec_lo(_Bucket) == _Unchecked_end()) {

	jne	SHORT $LN45@lower_boun

; 1123 :             return _Unchecked_end();

	mov	ecx, edx
	jmp	SHORT $LN46@lower_boun
$LN45@lower_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	ecx, DWORD PTR [esi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1126 :             return ++_Ans;

	mov	ecx, DWORD PTR [ecx]
$LN46@lower_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 767  :         for (_Unchecked_iterator _Where = _Begin(_Bucket); _Where != _End(_Bucket); ++_Where) {

	je	SHORT $LN3@lower_boun
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 88   :         return _Left == _Right;

	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 768  :             if (!_Traitsobj(_Traits::_Kfn(*_Where), _Keyval)) {

	je	SHORT $LN7@lower_boun
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LL4@lower_boun
$LN7@lower_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 769  :                 return _Traitsobj(_Keyval, _Traits::_Kfn(*_Where)) ? end() : _Make_iter(_Where);

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi

; 770  :             }
; 771  :         }
; 772  : 
; 773  :         return end();
; 774  :     }

	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebx
	ret	8
$LN3@lower_boun:

; 505  :         return _List.end();

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi

; 770  :             }
; 771  :         }
; 772  : 
; 773  :         return end();
; 774  :     }

	pop	esi
	pop	ebp

; 505  :         return _List.end();

	mov	DWORD PTR [eax], edx

; 770  :             }
; 771  :         }
; 772  : 
; 773  :         return end();
; 774  :     }

	pop	ebx
	ret	8
?lower_bound@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@ABH@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?find@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@ABH@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::find, COMDAT
; _this$ = ecx

; 750  :     _NODISCARD iterator find(const key_type& _Keyval) { // find an element in mutable hash table that matches _Keyval

	push	ebx
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	edi, DWORD PTR __Keyval$[esp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 750  :     _NODISCARD iterator find(const key_type& _Keyval) { // find an element in mutable hash table that matches _Keyval

	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [edi]
	xor	eax, -2128831035			; 811c9dc5H

; 1937 :         _Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [edi+1]
	xor	edx, eax
	movzx	eax, BYTE PTR [edi+2]
	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [edi+3]
	imul	ecx, edx, 16777619
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	mov	edx, DWORD PTR [esi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	xor	ecx, eax

; 1937 :         _Val *= _FNV_prime;

	imul	eax, ecx, 16777619
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1153 :         return _Traitsobj(_Keyval) & _Mask;

	mov	ecx, DWORD PTR [esi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 860  :         return _Unchecked_iterator(_Myhead(), nullptr);

	mov	esi, DWORD PTR [esi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1153 :         return _Traitsobj(_Keyval) & _Mask;

	and	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	lea	eax, DWORD PTR [ecx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1114 :         return _Vec_lo(_Bucket);

	mov	ebx, DWORD PTR [eax+edx]
	mov	ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1366 :         return _Myfirst()[_Pos];

	add	edx, eax
$LL6@find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 521  :         return _List._Unchecked_end();

	cmp	ebx, esi

; 1122 :         if (_Vec_lo(_Bucket) == _Unchecked_end()) {

	jne	SHORT $LN47@find

; 1123 :             return _Unchecked_end();

	mov	eax, esi
	jmp	SHORT $LN48@find
$LN47@find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	eax, DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1126 :             return ++_Ans;

	mov	eax, DWORD PTR [eax]
$LN48@find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 767  :         for (_Unchecked_iterator _Where = _Begin(_Bucket); _Where != _End(_Bucket); ++_Where) {

	je	SHORT $LN5@find
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 88   :         return _Left == _Right;

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 768  :             if (!_Traitsobj(_Traits::_Kfn(*_Where), _Keyval)) {

	je	SHORT $LN9@find
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 50   :         _Ptr = _Ptr->_Next;

	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LL6@find
$LN9@find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 751  :         return lower_bound(_Keyval);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi

; 752  :     }

	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx
	ret	8
$LN5@find:

; 751  :         return lower_bound(_Keyval);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], esi

; 752  :     }

	pop	esi
	pop	ebx
	ret	8
?find@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@ABH@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?erase@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Plist$ = 12						; size = 4
?erase@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V32@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::erase, COMDAT
; _this$ = ecx

; 717  :     iterator erase(const_iterator _Plist) { // erase element at _Plist

	push	ebx
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	edi, DWORD PTR __Plist$[esp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 717  :     iterator erase(const_iterator _Plist) { // erase element at _Plist

	mov	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [edi+8]
	xor	eax, -2128831035			; 811c9dc5H

; 1937 :         _Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [edi+9]
	xor	edx, eax
	movzx	eax, BYTE PTR [edi+10]
	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [edi+11]
	imul	ecx, edx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1153 :         return _Traitsobj(_Keyval) & _Mask;

	mov	ecx, DWORD PTR [ebx+24]
	and	ecx, eax

; 1106 :         return _Vec[2 * _Bucket + 1];

	lea	edx, DWORD PTR [ecx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	mov	ecx, DWORD PTR [ebx+12]
	add	ecx, edx
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [ecx+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1140 :         if (_Vec_hi(_Bucket) == _Plist) {

	jne	SHORT $LN49@erase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1141 :             if (_Vec_lo(_Bucket) == _Plist) { // make bucket empty

	jne	SHORT $LN51@erase

; 1142 :                 _Vec_lo(_Bucket) = _Unchecked_end();

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx], eax

; 1143 :                 _Vec_hi(_Bucket) = _Unchecked_end();

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edx+ecx+4], eax

; 1144 :             } else {

	jmp	SHORT $LN268@erase
$LN51@erase:

; 1145 :                 _Vec_hi(_Bucket) = --_Plist; // move end back one element

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+4], eax

; 1147 :         } else if (_Vec_lo(_Bucket) == _Plist) {

	jmp	SHORT $LN268@erase
$LN49@erase:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 72   :         return _Ptr == _Right._Ptr;

	cmp	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 1147 :         } else if (_Vec_lo(_Bucket) == _Plist) {

	jne	SHORT $LN53@erase

; 1148 :             _Vec_lo(_Bucket) = ++_Plist; // move beginning up one element

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN268@erase:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 175  :         this->_Ptr = this->_Ptr->_Next;

	mov	edi, DWORD PTR __Plist$[esp+8]
$LN53@erase:

; 1062 :         _Pnode->_Prev->_Next = _Pnode->_Next;

	mov	eax, DWORD PTR [edi+4]

; 175  :         this->_Ptr = this->_Ptr->_Next;

	mov	esi, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1062 :         _Pnode->_Prev->_Next = _Pnode->_Next;

	mov	DWORD PTR [eax], esi

; 1063 :         _Pnode->_Next->_Prev = _Pnode->_Prev;

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+4], eax

; 1064 :         --_Mysize();

	dec	DWORD PTR [ebx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 721  :         return _List.erase(_Plist);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 721  :         return _List.erase(_Plist);

	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 722  :     }

	ret	8
?erase@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V32@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEMXZ
_TEXT	SEGMENT
?max_load_factor@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEMXZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::max_load_factor, COMDAT
; _this$ = ecx

; 647  :         return _Max_bucket_size();

	fld	DWORD PTR [ecx]

; 648  :     }

	ret	0
?max_load_factor@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEMXZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?load_factor@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEMXZ
_TEXT	SEGMENT
tv80 = -4						; size = 4
?load_factor@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEMXZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::load_factor, COMDAT
; _this$ = ecx

; 642  :     _NODISCARD float load_factor() const noexcept { // return elements per bucket

	push	ecx

; 643  :         return static_cast<float>(size()) / static_cast<float>(bucket_count());

	mov	eax, DWORD PTR [ecx+8]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR [ecx+28]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR tv80[esp+4], xmm1
	fld	DWORD PTR tv80[esp+4]

; 644  :     }

	pop	ecx
	ret	0
?load_factor@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEMXZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::load_factor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::bucket_count, COMDAT
; _this$ = ecx

; 572  :         return _Maxidx;

	mov	eax, DWORD PTR [ecx+28]

; 573  :     }

	ret	0
?bucket_count@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::size, COMDAT
; _this$ = ecx

; 545  :         return _List.size();

	mov	eax, DWORD PTR [ecx+8]

; 546  :     }

	ret	0
?size@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Make_iter@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V32@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 533  :         return _List._Make_iter(_Where);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 534  :     }

	ret	8
?_Make_iter@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V32@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Make_iter@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 529  :         return _List._Make_iter(_Where);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 530  :     }

	ret	8
?_Make_iter@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_end, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 526  :     }

	ret	4
?_Unchecked_end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 521  :         return _List._Unchecked_end();

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 522  :     }

	ret	4
?_Unchecked_end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_begin, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 856  :         return _Unchecked_const_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ecx+4]

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 518  :     }

	ret	4
?_Unchecked_begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_begin, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 513  :         return _List._Unchecked_begin();

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 514  :     }

	ret	4
?_Unchecked_begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::end, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 510  :     }

	ret	4
?end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::end, COMDAT
; _this$ = ecx

; 505  :         return _List.end();

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 506  :     }

	ret	4
?end@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::begin, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 840  :         return const_iterator(_Myhead()->_Next, _STD addressof(_Get_data()));

	mov	eax, DWORD PTR [ecx+4]

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 502  :     }

	ret	4
?begin@?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??0?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@H@1@@Z PROC ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set

; 40   :     _Uset_traits(const _Tr& _Traits = _Tr()) : _Tr(_Traits) { // construct with specified comparator

	mov	eax, DWORD PTR __Parg$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 243  :           _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) { // construct empty hash table

	push	esi
	push	edi
	mov	edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set

; 40   :     _Uset_traits(const _Tr& _Traits = _Tr()) : _Tr(_Traits) { // construct with specified comparator

	mov	eax, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set

; 40   :     _Uset_traits(const _Tr& _Traits = _Tr()) : _Tr(_Traits) { // construct with specified comparator

	mov	DWORD PTR [edi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new

; 179  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax

; 49   :         return ::operator new(_Bytes);

	push	64					; 00000040H

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [esi], esi
	mov	DWORD PTR [esi+4], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1528 :         _My_data._Myhead = _Newhead;

	mov	DWORD PTR [edi+4], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	mov	DWORD PTR [edi+12], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR [edi+20], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 131  :     _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	DWORD PTR [eax+16], esi
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax+24], esi
	mov	DWORD PTR [eax+28], esi
	mov	DWORD PTR [eax+32], esi
	mov	DWORD PTR [eax+36], esi
	mov	DWORD PTR [eax+40], esi
	mov	DWORD PTR [eax+44], esi
	mov	DWORD PTR [eax+48], esi
	mov	DWORD PTR [eax+52], esi
	mov	DWORD PTR [eax+56], esi
	mov	DWORD PTR [eax+60], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 248  :     }

	mov	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 389  :             _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);

	mov	DWORD PTR [edi+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 243  :           _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) { // construct empty hash table

	mov	DWORD PTR [edi+24], 7
	mov	DWORD PTR [edi+28], 8

; 244  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [edi], 1065353216		; 3f800000H

; 248  :     }

	pop	edi
	pop	esi
	ret	8
??0?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@ABV?$allocator@H@1@@Z ENDP ; std::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >::_Hash<std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1541 :         return *this;

	mov	eax, ecx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_List_node@HPAX@std@@@std@@V?$_List_val@U?$_List_simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_List_node<int,void *> >,std::_List_val<std::_List_simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_val@U?$_List_simple_types@H@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<int> >::_List_val<std::_List_simple_types<int> >, COMDAT
; _this$ = ecx

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ecx], 0

; 372  :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_List_val@U?$_List_simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<int> >::_List_val<std::_List_simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Mysize@?$list@HV?$allocator@H@std@@@std@@ABEABIXZ
_TEXT	SEGMENT
?_Mysize@?$list@HV?$allocator@H@std@@@std@@ABEABIXZ PROC ; std::list<int,std::allocator<int> >::_Mysize, COMDAT
; _this$ = ecx

; 1583 :         return _Get_data()._Mysize;

	lea	eax, DWORD PTR [ecx+4]

; 1584 :     }

	ret	0
?_Mysize@?$list@HV?$allocator@H@std@@@std@@ABEABIXZ ENDP ; std::list<int,std::allocator<int> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Mysize@?$list@HV?$allocator@H@std@@@std@@AAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$list@HV?$allocator@H@std@@@std@@AAEAAIXZ PROC ; std::list<int,std::allocator<int> >::_Mysize, COMDAT
; _this$ = ecx

; 1579 :         return _Get_data()._Mysize;

	lea	eax, DWORD PTR [ecx+4]

; 1580 :     }

	ret	0
?_Mysize@?$list@HV?$allocator@H@std@@@std@@AAEAAIXZ ENDP ; std::list<int,std::allocator<int> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Myhead@?$list@HV?$allocator@H@std@@@std@@ABEABQAU?$_List_node@HPAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$list@HV?$allocator@H@std@@@std@@ABEABQAU?$_List_node@HPAX@2@XZ PROC ; std::list<int,std::allocator<int> >::_Myhead, COMDAT
; _this$ = ecx

; 1575 :         return _Get_data()._Myhead;

	mov	eax, ecx

; 1576 :     }

	ret	0
?_Myhead@?$list@HV?$allocator@H@std@@@std@@ABEABQAU?$_List_node@HPAX@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Myhead@?$list@HV?$allocator@H@std@@@std@@AAEAAPAU?$_List_node@HPAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$list@HV?$allocator@H@std@@@std@@AAEAAPAU?$_List_node@HPAX@2@XZ PROC ; std::list<int,std::allocator<int> >::_Myhead, COMDAT
; _this$ = ecx

; 1571 :         return _Get_data()._Myhead;

	mov	eax, ecx

; 1572 :     }

	ret	0
?_Myhead@?$list@HV?$allocator@H@std@@@std@@AAEAAPAU?$_List_node@HPAX@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Get_data@?$list@HV?$allocator@H@std@@@std@@ABEABV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$list@HV?$allocator@H@std@@@std@@ABEABV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Get_data, COMDAT
; _this$ = ecx

; 1567 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1568 :     }

	ret	0
?_Get_data@?$list@HV?$allocator@H@std@@@std@@ABEABV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Get_data@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Get_data, COMDAT
; _this$ = ecx

; 1563 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1564 :     }

	ret	0
?_Get_data@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$_List_val@U?$_List_simple_types@H@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Getal@?$list@HV?$allocator@H@std@@@std@@ABEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$list@HV?$allocator@H@std@@@std@@ABEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1559 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1560 :     }

	ret	0
?_Getal@?$list@HV?$allocator@H@std@@@std@@ABEABV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1555 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1556 :     }

	ret	0
?_Getal@?$list@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@U?$_List_node@HPAX@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Alloc_sentinel_and_proxy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ PROC ; std::list<int,std::allocator<int> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1520 :     void _Alloc_sentinel_and_proxy() {

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1520 :     void _Alloc_sentinel_and_proxy() {

	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1528 :         _My_data._Myhead = _Newhead;

	mov	DWORD PTR [esi], eax
	pop	esi

; 1529 :         _Proxy._Release();
; 1530 :     }

	ret	0
?_Alloc_sentinel_and_proxy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ ENDP ; std::list<int,std::allocator<int> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Orphan_ptr2@?$list@HV?$allocator@H@std@@@std@@AAEXPAU?$_List_node@HPAX@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Orphan_ptr2@?$list@HV?$allocator@H@std@@@std@@AAEXPAU?$_List_node@HPAX@2@@Z PROC ; std::list<int,std::allocator<int> >::_Orphan_ptr2, COMDAT
; _this$ = ecx

; 1479 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1480 :         _Lockit _Lock(_LOCK_DEBUG);
; 1481 :         auto _Pnext = (const_iterator**) _Getpfirst();
; 1482 :         if (_Pnext != nullptr) {
; 1483 :             const auto _Head = _Myhead();
; 1484 :             while (*_Pnext != nullptr) {
; 1485 :                 auto _Pnextnext = (const_iterator**) (*_Pnext)->_Getpnext();
; 1486 :                 if ((*_Pnext)->_Ptr == _Head
; 1487 :                     || (*_Pnext)->_Ptr
; 1488 :                            != _Ptr) { // iterator is end() or doesn't point at the one we are orphaning, move on
; 1489 :                     _Pnext = _Pnextnext;
; 1490 :                 } else { // orphan the iterator
; 1491 :                     (*_Pnext)->_Clrcont();
; 1492 :                     *_Pnext = *_Pnextnext;
; 1493 :                 }
; 1494 :             }
; 1495 :         }
; 1496 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1497 :         (void) _Ptr;
; 1498 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1499 :     }

	ret	4
?_Orphan_ptr2@?$list@HV?$allocator@H@std@@@std@@AAEXPAU?$_List_node@HPAX@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Orphan_ptr2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Unchecked_splice@?$list@HV?$allocator@H@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?_Unchecked_splice@?$list@HV?$allocator@H@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00@Z PROC ; std::list<int,std::allocator<int> >::_Unchecked_splice, COMDAT
; _this$ = ecx

; 1467 :         _First._Ptr->_Prev->_Next = _Last._Ptr;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1468 :         _Last._Ptr->_Prev->_Next  = _Where._Ptr;

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1469 :         _Where._Ptr->_Prev->_Next = _First._Ptr;

	mov	eax, DWORD PTR __Where$[esp-4]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __First$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1470 : 
; 1471 :         _Nodeptr _Pnode    = _Where._Ptr->_Prev;

	mov	ecx, DWORD PTR __Where$[esp-4]

; 1472 :         _Where._Ptr->_Prev = _Last._Ptr->_Prev;

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 1473 :         _Last._Ptr->_Prev  = _First._Ptr->_Prev;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	DWORD PTR [eax+4], ecx

; 1474 :         _First._Ptr->_Prev = _Pnode;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	DWORD PTR [eax+4], edx

; 1475 :     }

	ret	12					; 0000000cH
?_Unchecked_splice@?$list@HV?$allocator@H@std@@@std@@AAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@00@Z ENDP ; std::list<int,std::allocator<int> >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Tidy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ PROC	; std::list<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1133 :     void _Tidy() noexcept {

	push	edi
	mov	edi, ecx

; 1134 :         auto& _Al      = _Getal();
; 1135 :         auto& _My_data = _Get_data();
; 1136 :         _My_data._Orphan_all();
; 1137 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	edx, DWORD PTR [edi]

; 341  :         _Head->_Prev->_Next = nullptr;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax], 0

; 342  : 
; 343  :         auto _Pnode = _Head->_Next;

	mov	eax, DWORD PTR [edx]

; 344  :         for (_Nodeptr _Pnext; _Pnode != nullptr; _Pnode = _Pnext) {

	test	eax, eax
	je	SHORT $LN15@Tidy
	push	esi
$LL16@Tidy:

; 345  :             _Pnext = _Pnode->_Next;

	mov	esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 344  :         for (_Nodeptr _Pnext; _Pnode != nullptr; _Pnode = _Pnext) {

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL16@Tidy
	pop	esi
$LN15@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	DWORD PTR [edi]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1139 :     }

	ret	0
?_Tidy@?$list@HV?$allocator@H@std@@@std@@AAEXXZ ENDP	; std::list<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z PROC ; std::list<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 180  :         _List_const_iterator _Tmp = *this;

	mov	eax, DWORD PTR __Where$[esp-4]

; 1082 :     iterator erase(const_iterator _Where) { // erase element at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 175  :         this->_Ptr = this->_Ptr->_Next;

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Where$[esp+4], edx

; 1062 :         _Pnode->_Prev->_Next = _Pnode->_Next;

	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1062 :         _Pnode->_Prev->_Next = _Pnode->_Next;

	mov	DWORD PTR [esi], edx

; 1063 :         _Pnode->_Next->_Prev = _Pnode->_Prev;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1064 :         --_Mysize();

	dec	DWORD PTR [edi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	ecx, DWORD PTR __Where$[esp+4]

; 1083 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1084 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Get_data()), "list erase iterator outside range");
; 1085 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1086 :         _Node::_Freenode(_Getal(), _Unlinknode(_Get_unwrapped(_Where++)));
; 1087 :         return _Make_iter(_Where);

	pop	edi

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	DWORD PTR [eax], ecx

; 1083 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1084 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Get_data()), "list erase iterator outside range");
; 1085 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1086 :         _Node::_Freenode(_Getal(), _Unlinknode(_Get_unwrapped(_Where++)));
; 1087 :         return _Make_iter(_Where);

	pop	esi

; 1088 :     }

	ret	8
?erase@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ENDP ; std::list<int,std::allocator<int> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Unlinknode@?$list@HV?$allocator@H@std@@@std@@AAEPAU?$_List_node@HPAX@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Unlinknode@?$list@HV?$allocator@H@std@@@std@@AAEPAU?$_List_node@HPAX@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::list<int,std::allocator<int> >::_Unlinknode, COMDAT
; _this$ = ecx

; 1060 :         auto _Pnode = _Where._Ptr;

	mov	eax, DWORD PTR __Where$[esp-4]
	push	esi

; 1061 :         _Orphan_ptr2(_Pnode);
; 1062 :         _Pnode->_Prev->_Next = _Pnode->_Next;

	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [esi], edx

; 1063 :         _Pnode->_Next->_Prev = _Pnode->_Prev;

	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], edx

; 1064 :         --_Mysize();

	dec	DWORD PTR [ecx+4]

; 1065 :         return _Pnode;

	pop	esi

; 1066 :     }

	ret	4
?_Unlinknode@?$list@HV?$allocator@H@std@@@std@@AAEPAU?$_List_node@HPAX@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Unlinknode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?push_front@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_front@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::list<int,std::allocator<int> >::push_front, COMDAT
; _this$ = ecx

; 973  :     void push_front(const _Ty& _Val) { // insert element at beginning

	push	ebx
	mov	ebx, ecx
	push	esi

; 750  :         if (max_size() == _Mysize()) {

	cmp	DWORD PTR [ebx+4], 357913941		; 15555555H

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	esi, DWORD PTR [ebx]

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	esi, DWORD PTR [esi]

; 750  :         if (max_size() == _Mysize()) {

	je	SHORT $LN131@push_front
	push	edi

; 752  :         }
; 753  : 
; 754  :         const _Nodeptr _Rightnode = _Where._Ptr;
; 755  :         const _Nodeptr _Leftnode  = _Rightnode->_Prev;

	mov	edi, DWORD PTR [esi+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR __Val$[esp+12]

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 761  :         ++_Mysize();

	inc	DWORD PTR [ebx+4]

; 762  :         _Rightnode->_Prev = _Newnode._Ptr;

	mov	DWORD PTR [esi+4], eax

; 763  :         _Leftnode->_Next  = _Newnode._Ptr;

	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 974  :         _Insert(_Unchecked_begin(), _Val);
; 975  :     }

	pop	ebx
	ret	4
$LN131@push_front:

; 751  :             _Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN129@push_front:
	int	3
?push_front@?$list@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::list<int,std::allocator<int> >::push_front
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?front@?$list@HV?$allocator@H@std@@@std@@QAEAAHXZ
_TEXT	SEGMENT
?front@?$list@HV?$allocator@H@std@@@std@@QAEAAHXZ PROC	; std::list<int,std::allocator<int> >::front, COMDAT
; _this$ = ecx

; 836  :         return iterator(_Myhead()->_Next, _STD addressof(_Get_data()));

	mov	eax, DWORD PTR [ecx]

; 161  :         return this->_Ptr->_Myval;

	mov	eax, DWORD PTR [eax]
	add	eax, 8

; 958  :         return *begin();
; 959  :     }

	ret	0
?front@?$list@HV?$allocator@H@std@@@std@@QAEAAHXZ ENDP	; std::list<int,std::allocator<int> >::front
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::list<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 946  :         return _Alnode_traits::max_size(_Getal());

	mov	eax, 357913941				; 15555555H

; 947  :     }

	ret	0
?max_size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::list<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::list<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 942  :         return this->_Mysize();

	mov	eax, DWORD PTR [ecx+4]

; 943  :     }

	ret	0
?size@?$list@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::list<int,std::allocator<int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@PAU?$_List_node@HPAX@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@PAU?$_List_node@HPAX@2@@Z PROC ; std::list<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 876  :         return iterator(_Where, _STD addressof(_Get_data()));
; 877  :     }

	ret	8
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@PAU?$_List_node@HPAX@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::list<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 872  :         return _Make_iter(_Where._Ptr);
; 873  :     }

	ret	8
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z PROC ; std::list<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 868  :         return _Make_iter(_Where._Ptr);
; 869  :     }

	ret	8
?_Make_iter@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@@Z ENDP ; std::list<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Unchecked_end@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 864  :         return _Unchecked_const_iterator(_Myhead(), nullptr);
; 865  :     }

	ret	4
?_Unchecked_end@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Unchecked_end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 860  :         return _Unchecked_iterator(_Myhead(), nullptr);
; 861  :     }

	ret	4
?_Unchecked_end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Unchecked_begin@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 856  :         return _Unchecked_const_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ecx]

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 857  :     }

	ret	4
?_Unchecked_begin@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?_Unchecked_begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 852  :         return _Unchecked_iterator(_Myhead()->_Next, nullptr);

	mov	eax, DWORD PTR [ecx]

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 853  :     }

	ret	4
?_Unchecked_begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?end@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 848  :         return const_iterator(_Myhead(), _STD addressof(_Get_data()));
; 849  :     }

	ret	4
?end@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 844  :         return iterator(_Myhead(), _STD addressof(_Get_data()));
; 845  :     }

	ret	4
?end@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?begin@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 840  :         return const_iterator(_Myhead()->_Next, _STD addressof(_Get_data()));

	mov	eax, DWORD PTR [ecx]

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 841  :     }

	ret	4
?begin@?$list@HV?$allocator@H@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ PROC ; std::list<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 836  :         return iterator(_Myhead()->_Next, _STD addressof(_Get_data()));

	mov	eax, DWORD PTR [ecx]

; 37   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 837  :     }

	ret	4
?begin@?$list@HV?$allocator@H@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@H@std@@@std@@@2@XZ ENDP ; std::list<int,std::allocator<int> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 790  :     ~list() noexcept { // destroy the object

	push	edi
	mov	edi, ecx

; 1137 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

	mov	edx, DWORD PTR [edi]

; 341  :         _Head->_Prev->_Next = nullptr;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax], 0

; 342  : 
; 343  :         auto _Pnode = _Head->_Next;

	mov	eax, DWORD PTR [edx]

; 344  :         for (_Nodeptr _Pnext; _Pnode != nullptr; _Pnode = _Pnext) {

	test	eax, eax
	je	SHORT $LN17@list
	push	esi
$LL18@list:

; 345  :             _Pnext = _Pnode->_Next;

	mov	esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 344  :         for (_Nodeptr _Pnext; _Pnode != nullptr; _Pnode = _Pnext) {

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL18@list
	pop	esi
$LN17@list:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	12					; 0000000cH
	push	DWORD PTR [edi]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 796  :     }

	ret	0
??1?$list@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::list<int,std::allocator<int> >::~list<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
;	COMDAT ??0?$list@HV?$allocator@H@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$list@HV?$allocator@H@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 544  :     explicit list(const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al) { // construct empty list, allocator

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1528 :         _My_data._Myhead = _Newhead;

	mov	DWORD PTR [esi], eax

; 545  :         _Alloc_sentinel_and_proxy();
; 546  :     }

	mov	eax, esi
	pop	esi
	ret	4
??0?$list@HV?$allocator@H@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::list<int,std::allocator<int> >::list<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@HPAX@std@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@HPAX@std@@@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::select_on_container_copy_construction, COMDAT

; 832  :         return _Al;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 833  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SA?AV?$allocator@U?$_List_node@HPAX@std@@@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@HPAX@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@HPAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::max_size, COMDAT

; 828  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 357913941				; 15555555H

; 829  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@HPAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@2@QAU?$_List_node@HPAX@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@2@QAU?$_List_node@HPAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::deallocate, COMDAT

; 813  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 814  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	shl	ecx, 2

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 815  :     }

	ret	0
$LN12@deallocate:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	jmp	__invalid_parameter_noinfo_noreturn
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_List_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@HPAX@std@@@2@QAU?$_List_node@HPAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_List_node<int,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEPAU?$_List_node@HPAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEPAU?$_List_node@HPAX@2@I@Z PROC ; std::allocator<std::_List_node<int,void *> >::allocate, COMDAT
; _this$ = ecx

; 25   :     size_t _Result                 = _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 2

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN4@allocate

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	or	ecx, -1

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN27@allocate
$LN4@allocate:
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN7@allocate
$LN27@allocate:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 93   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN16@allocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN7@allocate:

; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN8@allocate

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN8@allocate:

; 182  :     return nullptr;

	xor	eax, eax

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN16@allocate:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	__invalid_parameter_noinfo_noreturn
$LN28@allocate:
	int	3
?allocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEPAU?$_List_node@HPAX@2@I@Z ENDP ; std::allocator<std::_List_node<int,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEXQAU?$_List_node@HPAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEXQAU?$_List_node@HPAX@2@I@Z PROC ; std::allocator<std::_List_node<int,void *> >::deallocate, COMDAT
; _this$ = ecx

; 924  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	shl	ecx, 2

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 926  :     }

	ret	8
$LN12@deallocate:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@U?$_List_node@HPAX@std@@@std@@QAEXQAU?$_List_node@HPAX@2@I@Z ENDP ; std::allocator<std::_List_node<int,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
;	COMDAT ?_Kfn@?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@SAABHABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@SAABHABH@Z PROC ; std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0>::_Kfn, COMDAT

; 46   :         return _Val;

	mov	eax, DWORD PTR __Val$[esp-4]

; 47   :     }

	ret	0
?_Kfn@?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@SAABHABH@Z ENDP ; std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0>::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\unordered_set
;	COMDAT ??0?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z
_TEXT	SEGMENT
__Traits$ = 8						; size = 4
??0?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z PROC ; std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0>::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0>, COMDAT
; _this$ = ecx

; 40   :     _Uset_traits(const _Tr& _Traits = _Tr()) : _Tr(_Traits) { // construct with specified comparator

	mov	eax, DWORD PTR __Traits$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 41   :     }

	mov	eax, ecx
	ret	4
??0?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@QAE@ABV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@1@@Z ENDP ; std::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0>::_Uset_traits<int,std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >,std::allocator<int>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::max_size, COMDAT

; 828  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 1073741823				; 3fffffffH

; 829  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 25   :     size_t _Result                 = _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax*4]

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN4@allocate

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	or	ecx, -1

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN27@allocate
$LN4@allocate:
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN7@allocate
$LN27@allocate:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 93   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN16@allocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN7@allocate:

; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN8@allocate

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN8@allocate:

; 182  :     return nullptr;

	xor	eax, eax

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN16@allocate:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	__invalid_parameter_noinfo_noreturn
$LN28@allocate:
	int	3
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXQAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXQAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 924  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Ptr$[esp-4]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 926  :     }

	ret	8
$LN12@deallocate:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@H@std@@QAEXQAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 916  :     }

	mov	eax, ecx
	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@XZ PROC ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@XZ ENDP ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@XZ PROC ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@XZ ENDP ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ PROC ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1541 :         return *this;

	mov	eax, ecx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@H@std@@V?$_Compressed_pair@U?$equal_to@H@std@@M$00@2@$00@std@@QBEABU?$hash@H@2@XZ ENDP ; std::_Compressed_pair<std::hash<int>,std::_Compressed_pair<std::equal_to<int>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABMXZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABMXZ PROC ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABMXZ ENDP ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAEAAMXZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAEAAMXZ PROC ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QAEAAMXZ ENDP ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ PROC ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_first, COMDAT
; _this$ = ecx

; 1541 :         return *this;

	mov	eax, ecx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@H@std@@M$00@std@@QBEABU?$equal_to@H@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<int>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??R?$equal_to@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$equal_to@H@std@@QBE_NABH0@Z PROC			; std::equal_to<int>::operator(), COMDAT
; _this$ = ecx

; 88   :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 89   :     }

	ret	8
??R?$equal_to@H@std@@QBE_NABH0@Z ENDP			; std::equal_to<int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ
_TEXT	SEGMENT
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size, COMDAT
; _this$ = ecx

; 120  :         return _Mypair._Get_second()._Get_second();

	mov	eax, ecx

; 121  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABMXZ ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ
_TEXT	SEGMENT
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size, COMDAT
; _this$ = ecx

; 116  :         return _Mypair._Get_second()._Get_second();

	mov	eax, ecx

; 117  :     }

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAEAAMXZ ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Getkeyeq@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABU?$equal_to@H@2@XZ
_TEXT	SEGMENT
?_Getkeyeq@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABU?$equal_to@H@2@XZ PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Getkeyeq, COMDAT
; _this$ = ecx

; 112  :         return _Mypair._Get_second()._Get_first();

	mov	eax, ecx

; 113  :     }

	ret	0
?_Getkeyeq@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABU?$equal_to@H@2@XZ ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Getkeyeq
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ?_Gethash@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABU?$hash@H@2@XZ
_TEXT	SEGMENT
?_Gethash@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABU?$hash@H@2@XZ PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Gethash, COMDAT
; _this$ = ecx

; 108  :         return _Mypair._Get_first();

	mov	eax, ecx

; 109  :     }

	ret	0
?_Gethash@?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEABU?$hash@H@2@XZ ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Gethash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??R?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Keyval1$ = 8						; size = 4
__Keyval2$ = 12						; size = 4
??R?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBE_NABH0@Z PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator(), COMDAT
; _this$ = ecx

; 104  :         return !_Getkeyeq()(_Keyval1, _Keyval2);

	mov	eax, DWORD PTR __Keyval1$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Keyval2$[esp-4]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 105  :     }

	ret	8
??R?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBE_NABH0@Z ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??R?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??R?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator(), COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	edx, DWORD PTR __Keyval$[esp-4]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 1937 :         _Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 101  :     }

	ret	4
??R?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QBEIABH@Z ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
;	COMDAT ??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@U?$hash@H@1@U?$equal_to@H@1@@Z
_TEXT	SEGMENT
__Hasharg$ = 8						; size = 1
__Keyeqarg$ = 12					; size = 1
??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@U?$hash@H@1@U?$equal_to@H@1@@Z PROC ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1533 :           _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 97   :     }

	mov	eax, ecx
	ret	8
??0?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@QAE@U?$hash@H@1@U?$equal_to@H@1@@Z ENDP ; std::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >::_Uhash_compare<int,std::hash<int>,std::equal_to<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp
;	COMDAT _main
_TEXT	SEGMENT
_N$ = -84						; size = 4
_MAX$ = -80						; size = 4
_t4$ = -76						; size = 8
_t3$ = -68						; size = 8
_t2$ = -60						; size = 8
_t1$ = -52						; size = 8
_vec$ = -44						; size = 12
_rs$ = -32						; size = 32
_main	PROC						; COMDAT

; 123  : int main() {

	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 124  :   int MAX = 1000000;

	mov	DWORD PTR _MAX$[esp+96], 1000000	; 000f4240H

; 125  :   int N = 100000; // Default num integers.

	mov	DWORD PTR _N$[esp+96], 100000		; 000186a0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 555  :             return time_point(duration(_Xtime_get_ticks()));

	call	__Xtime_get_ticks
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 555  :             return time_point(duration(_Xtime_get_ticks()));

	mov	edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 371  :     _List_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR _rs$[esp+108], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 555  :             return time_point(duration(_Xtime_get_ticks()));

	mov	ebx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new

; 179  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax

; 49   :         return ::operator new(_Bytes);

	push	64					; 00000040H

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [esi], esi
	mov	DWORD PTR [esi+4], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\list

; 1528 :         _My_data._Myhead = _Newhead;

	mov	DWORD PTR _rs$[esp+108], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	mov	DWORD PTR _rs$[esp+116], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _rs$[esp+128], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 131  :     _Uninitialized_backout_al(_NoThrowFwdIt _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	DWORD PTR [eax+16], esi
	mov	DWORD PTR [eax+20], esi
	mov	DWORD PTR [eax+24], esi
	mov	DWORD PTR [eax+28], esi
	mov	DWORD PTR [eax+32], esi
	mov	DWORD PTR [eax+36], esi
	mov	DWORD PTR [eax+40], esi
	mov	DWORD PTR [eax+44], esi
	mov	DWORD PTR [eax+48], esi
	mov	DWORD PTR [eax+52], esi
	mov	DWORD PTR [eax+56], esi
	mov	DWORD PTR [eax+60], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 389  :             _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);

	mov	DWORD PTR _rs$[esp+124], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xhash

; 243  :           _Mask(_Min_buckets - 1), _Maxidx(_Min_buckets) { // construct empty hash table

	mov	DWORD PTR _rs$[esp+132], 7
	mov	DWORD PTR _rs$[esp+136], 8

; 244  :         _Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR _rs$[esp+108], 1065353216	; 3f800000H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR _vec$[esp+108], 0
	mov	DWORD PTR _vec$[esp+112], 0
	mov	DWORD PTR _vec$[esp+116], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	call	??2@YAPAXI@Z				; operator new
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN306@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	lea	ecx, DWORD PTR _N$[esp+96]
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR _MAX$[esp+96]
	mov	DWORD PTR [eax+4], ecx
	lea	ecx, DWORD PTR _rs$[esp+96]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], OFFSET ??$generateRandom@H@@YAXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@Z ; generateRandom<int>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	jmp	SHORT $LN307@main
$LN306@main:
	xor	eax, eax
$LN307@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 56   :         _Thr._Hnd =

	lea	ecx, DWORD PTR _t1$[esp+100]
	push	ecx
	push	0
	push	eax
	push	OFFSET ??$_Invoke@V?$tuple@P6AXAAV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@HH@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@H@2@V42@@std@@$0A@$00$01$02@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > &,int,int),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<int>,std::reference_wrapper<int> >,0,1,2,3>
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _t1$[esp+96], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

	test	eax, eax
	je	$LN892@main

; 93   :         return _Thr._Id != 0;

	cmp	DWORD PTR _t1$[esp+100], 0

; 97   :         if (!joinable()) {

	je	$LN889@main

; 99   :         }
; 100  : 
; 101  :         if (_Thr._Id == _Thrd_id()) {

	call	__Thrd_id
	mov	ecx, DWORD PTR _t1$[esp+100]
	cmp	ecx, eax
	je	$LN888@main

; 103  :         }
; 104  : 
; 105  :         if (_Thrd_join(_Thr, nullptr) != _Thrd_success) {

	push	0
	push	ecx
	push	DWORD PTR _t1$[esp+104]
	call	__Thrd_join
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN887@main
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 109  :         _Thr = {};

	movlpd	QWORD PTR _t1$[esp+100], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN454@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	lea	ecx, DWORD PTR _vec$[esp+96]
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR _rs$[esp+96]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], OFFSET ??$insert@H@@YAXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@1@@Z ; insert<int>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	jmp	SHORT $LN455@main
$LN454@main:
	xor	eax, eax
$LN455@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 56   :         _Thr._Hnd =

	lea	ecx, DWORD PTR _t2$[esp+100]
	push	ecx
	push	0
	push	eax
	push	OFFSET ??$_Invoke@V?$tuple@P6AXV?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@AAV?$vector@HV?$allocator@H@std@@@2@@ZV?$reference_wrapper@V?$unordered_set@HU?$hash@H@std@@U?$equal_to@H@2@V?$allocator@H@2@@std@@@2@V?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00$01@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> >,std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::unordered_set<int,std::hash<int>,std::equal_to<int>,std::allocator<int> > >,std::reference_wrapper<std::vector<int,std::allocator<int> > > >,0,1,2>
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _t2$[esp+96], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

	test	eax, eax
	je	$LN893@main

; 93   :         return _Thr._Id != 0;

	cmp	DWORD PTR _t2$[esp+100], 0

; 97   :         if (!joinable()) {

	je	$LN889@main

; 99   :         }
; 100  : 
; 101  :         if (_Thr._Id == _Thrd_id()) {

	call	__Thrd_id
	mov	ecx, DWORD PTR _t2$[esp+100]
	cmp	ecx, eax
	je	$LN888@main

; 103  :         }
; 104  : 
; 105  :         if (_Thrd_join(_Thr, nullptr) != _Thrd_success) {

	push	0
	push	ecx
	push	DWORD PTR _t2$[esp+104]
	call	__Thrd_join
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN887@main
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 109  :         _Thr = {};

	movlpd	QWORD PTR _t2$[esp+100], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN574@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	lea	ecx, DWORD PTR _vec$[esp+96]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], OFFSET ??$InsertionSort@H@@YAXAAV?$vector@HV?$allocator@H@std@@@std@@@Z ; InsertionSort<int>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	jmp	SHORT $LN575@main
$LN574@main:
	xor	eax, eax
$LN575@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 56   :         _Thr._Hnd =

	lea	ecx, DWORD PTR _t3$[esp+100]
	push	ecx
	push	0
	push	eax
	push	OFFSET ??$_Invoke@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,0,1>
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _t3$[esp+96], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

	test	eax, eax
	je	$LN894@main

; 93   :         return _Thr._Id != 0;

	cmp	DWORD PTR _t3$[esp+100], 0

; 97   :         if (!joinable()) {

	je	$LN889@main

; 99   :         }
; 100  : 
; 101  :         if (_Thr._Id == _Thrd_id()) {

	call	__Thrd_id
	mov	ecx, DWORD PTR _t3$[esp+100]
	cmp	ecx, eax
	je	$LN888@main

; 103  :         }
; 104  : 
; 105  :         if (_Thrd_join(_Thr, nullptr) != _Thrd_success) {

	push	0
	push	ecx
	push	DWORD PTR _t3$[esp+104]
	call	__Thrd_join
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN887@main
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	push	8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 109  :         _Thr = {};

	movlpd	QWORD PTR _t3$[esp+100], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN678@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	lea	ecx, DWORD PTR _vec$[esp+96]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], OFFSET ??$erase@H@@YAXAAV?$vector@HV?$allocator@H@std@@@std@@@Z ; erase<int>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 2115 :     return unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...));

	jmp	SHORT $LN679@main
$LN678@main:
	xor	eax, eax
$LN679@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 56   :         _Thr._Hnd =

	lea	ecx, DWORD PTR _t4$[esp+100]
	push	ecx
	push	0
	push	eax
	push	OFFSET ??$_Invoke@V?$tuple@P6AXAAV?$vector@HV?$allocator@H@std@@@std@@@ZV?$reference_wrapper@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@$0A@$00@thread@std@@CGIPAX@Z ; std::thread::_Invoke<std::tuple<void (__cdecl*)(std::vector<int,std::allocator<int> > &),std::reference_wrapper<std::vector<int,std::allocator<int> > > >,0,1>
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _t4$[esp+96], eax

; 57   :             reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id));
; 58   :         if (_Thr._Hnd == nullptr) { // failed to start thread

	test	eax, eax
	je	$LN895@main

; 93   :         return _Thr._Id != 0;

	cmp	DWORD PTR _t4$[esp+100], 0

; 97   :         if (!joinable()) {

	je	$LN889@main

; 99   :         }
; 100  : 
; 101  :         if (_Thr._Id == _Thrd_id()) {

	call	__Thrd_id
	mov	ecx, DWORD PTR _t4$[esp+100]
	cmp	ecx, eax
	je	$LN888@main

; 103  :         }
; 104  : 
; 105  :         if (_Thrd_join(_Thr, nullptr) != _Thrd_success) {

	push	0
	push	ecx
	push	DWORD PTR _t4$[esp+104]
	call	__Thrd_join
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN887@main
	xorps	xmm0, xmm0

; 109  :         _Thr = {};

	movlpd	QWORD PTR _t4$[esp+96], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 555  :             return time_point(duration(_Xtime_get_ticks()));

	call	__Xtime_get_ticks

; 188  :             return _MyDur;

	sub	eax, edi

; 372  :         return _Num_is_one && _Den_is_one

	push	0
	push	10000					; 00002710H

; 188  :             return _MyDur;

	sbb	edx, ebx

; 372  :         return _Num_is_one && _Den_is_one

	push	edx
	push	eax
	call	__alldiv
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 148  :   cout << "Multiple Threads Time: " << time_trial << "ms\n";

	push	OFFSET ??_C@_0BI@FPMLGDN@Multiple?5Threads?5Time?3?5@
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 372  :         return _Num_is_one && _Den_is_one

	mov	edi, eax
	mov	esi, edx
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 148  :   cout << "Multiple Threads Time: " << time_trial << "ms\n";

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	push	OFFSET ??_C@_03LLKPDBLO@ms?6@
	push	esi
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 93   :         return _Thr._Id != 0;

	cmp	DWORD PTR _t4$[esp+100], 0

; 67   :         if (joinable()) {

	jne	$LN886@main

; 93   :         return _Thr._Id != 0;

	cmp	DWORD PTR _t3$[esp+100], 0

; 67   :         if (joinable()) {

	jne	$LN886@main

; 93   :         return _Thr._Id != 0;

	cmp	DWORD PTR _t2$[esp+100], 0

; 67   :         if (joinable()) {

	jne	$LN886@main

; 93   :         return _Thr._Id != 0;

	cmp	DWORD PTR _t1$[esp+100], 0

; 67   :         if (joinable()) {

	jne	$LN886@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	mov	edx, DWORD PTR _vec$[esp+96]
	test	edx, edx
	je	SHORT $LN833@main

; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	ecx, DWORD PTR _vec$[esp+104]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	sub	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	ecx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN873@main

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edx-4]
	add	ecx, 35					; 00000023H
	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN896@main
$LN873@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1530 :             _My_data._Myfirst = pointer();

	mov	DWORD PTR _vec$[esp+96], 0

; 1531 :             _My_data._Mylast  = pointer();

	mov	DWORD PTR _vec$[esp+100], 0

; 1532 :             _My_data._Myend   = pointer();

	mov	DWORD PTR _vec$[esp+104], 0
$LN833@main:
	lea	ecx, DWORD PTR _rs$[esp+96]
	call	??1?$_Hash@V?$_Uset_traits@HV?$_Uhash_compare@HU?$hash@H@std@@U?$equal_to@H@2@@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ
	pop	edi
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\Threading\threading.cpp

; 152  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	add	esp, 84					; 00000054H
	ret	0
$LN889@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 98   :             _Throw_Cpp_error(_INVALID_ARGUMENT);

	push	1
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN892@main:

; 60   :             _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);

	push	6
	mov	DWORD PTR _t1$[esp+104], 0
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN893@main:
	push	6
	mov	DWORD PTR _t2$[esp+104], 0
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN894@main:
	push	6
	mov	DWORD PTR _t3$[esp+104], 0
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN895@main:
	push	6
	mov	DWORD PTR _t4$[esp+104], 0
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN896@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN886@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread

; 68   :             _STD terminate();

	call	_terminate
$LN887@main:

; 106  :             _Throw_Cpp_error(_NO_SUCH_PROCESS);

	push	2
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN888@main:

; 102  :             _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	push	5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN890@main:
	int	3
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
;	COMDAT ?join@thread@std@@QAEXXZ
_TEXT	SEGMENT
?join@thread@std@@QAEXXZ PROC				; std::thread::join, COMDAT
; _this$ = ecx

; 96   :     void join() { // join thread

	push	esi
	mov	esi, ecx

; 93   :         return _Thr._Id != 0;

	cmp	DWORD PTR [esi+4], 0

; 97   :         if (!joinable()) {

	je	SHORT $LN10@join

; 99   :         }
; 100  : 
; 101  :         if (_Thr._Id == _Thrd_id()) {

	call	__Thrd_id
	cmp	DWORD PTR [esi+4], eax
	je	SHORT $LN11@join

; 103  :         }
; 104  : 
; 105  :         if (_Thrd_join(_Thr, nullptr) != _Thrd_success) {

	push	0
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	call	__Thrd_join
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@join

; 107  :         }
; 108  : 
; 109  :         _Thr = {};

	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 110  :     }

	ret	0
$LN10@join:

; 98   :             _Throw_Cpp_error(_INVALID_ARGUMENT);

	push	1
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN11@join:

; 102  :             _Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

	push	5
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN12@join:

; 106  :             _Throw_Cpp_error(_NO_SUCH_PROCESS);

	push	2
	call	?_Throw_Cpp_error@std@@YAXH@Z		; std::_Throw_Cpp_error
$LN8@join:
	int	3
?join@thread@std@@QAEXXZ ENDP				; std::thread::join
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
;	COMDAT ?joinable@thread@std@@QBE_NXZ
_TEXT	SEGMENT
?joinable@thread@std@@QBE_NXZ PROC			; std::thread::joinable, COMDAT
; _this$ = ecx

; 93   :         return _Thr._Id != 0;

	cmp	DWORD PTR [ecx+4], 0
	setne	al

; 94   :     }

	ret	0
?joinable@thread@std@@QBE_NXZ ENDP			; std::thread::joinable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\thread
;	COMDAT ??1thread@std@@QAE@XZ
_TEXT	SEGMENT
??1thread@std@@QAE@XZ PROC				; std::thread::~thread, COMDAT
; _this$ = ecx

; 93   :         return _Thr._Id != 0;

	cmp	DWORD PTR [ecx+4], 0

; 67   :         if (joinable()) {

	jne	_terminate

; 68   :             _STD terminate();
; 69   :         }
; 70   :     }

	ret	0
??1thread@std@@QAE@XZ ENDP				; std::thread::~thread
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::count, COMDAT
; _this$ = ecx

; 88   :             return _MyRep;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 89   :         }

	ret	0
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 77   :         }

	mov	eax, ecx
	ret	4
??$?0_JX@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::duration<__int64,std::ratio<1,10000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 188  :             return _MyDur;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 189  :         }

	ret	4
?time_since_epoch@?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >, COMDAT
; _this$ = ecx

; 179  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

	mov	edx, DWORD PTR __Other$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 180  :         }

	mov	eax, ecx
	ret	4
??0?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >::time_point<std::chrono::system_clock,std::chrono::duration<__int64,std::ratio<1,10000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count, COMDAT
; _this$ = ecx

; 88   :             return _MyRep;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 89   :         }

	ret	0
?count@?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,10000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ PROC ; std::chrono::system_clock::now, COMDAT

; 555  :             return time_point(duration(_Xtime_get_ticks()));

	call	__Xtime_get_ticks

; 179  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [ecx], eax

; 555  :             return time_point(duration(_Xtime_get_ticks()));

	mov	eax, ecx

; 179  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

	mov	DWORD PTR [ecx+4], edx

; 556  :         }

	ret	0
?now@system_clock@chrono@std@@SA?AV?$time_point@Usystem_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0JIJGIA@@std@@@23@@23@XZ ENDP ; std::chrono::system_clock::now
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xbit_ops.h
;	COMDAT ?_Ceiling_of_log_2@std@@YAKI@Z
_TEXT	SEGMENT
__Value$ = 8						; size = 4
?_Ceiling_of_log_2@std@@YAKI@Z PROC			; std::_Ceiling_of_log_2, COMDAT

; 48   :                                                                                   // pre: _Value > 1
; 49   :     return 1 + _Floor_of_log_2(_Value - 1);

	mov	eax, DWORD PTR __Value$[esp-4]
	dec	eax

; 22   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	or	eax, 1

; 23   :     unsigned long _Result;
; 24   : 
; 25   : #ifdef _M_CEE_PURE
; 26   : #ifdef _WIN64
; 27   :     _Result = 63;
; 28   : #else // ^^^ 64-bit ^^^ / vvv 32-bit vvv
; 29   :     _Result = 31;
; 30   : #endif // 64 vs. 32-bit
; 31   : 
; 32   :     while ((size_t{1} << _Result) > _Value) {
; 33   :         --_Result;
; 34   :     }
; 35   : 
; 36   : #else // ^^^ _M_CEE_PURE ^^^ // vvv !_M_CEE_PURE vvv
; 37   : #ifdef _WIN64
; 38   :     _BitScanReverse64(&_Result, _Value);
; 39   : #else // ^^^ 64-bit ^^^ / vvv 32-bit vvv
; 40   :     _BitScanReverse(&_Result, _Value);

	bsr	eax, eax

; 48   :                                                                                   // pre: _Value > 1
; 49   :     return 1 + _Floor_of_log_2(_Value - 1);

	inc	eax

; 50   : }

	ret	0
?_Ceiling_of_log_2@std@@YAKI@Z ENDP			; std::_Ceiling_of_log_2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xbit_ops.h
;	COMDAT ?_Floor_of_log_2@std@@YAKI@Z
_TEXT	SEGMENT
__Value$ = 8						; size = 4
?_Floor_of_log_2@std@@YAKI@Z PROC			; std::_Floor_of_log_2, COMDAT

; 22   :     _Value |= size_t{1}; // avoid undefined answer from _BitScanReverse for 0

	mov	eax, DWORD PTR __Value$[esp-4]
	or	eax, 1

; 23   :     unsigned long _Result;
; 24   : 
; 25   : #ifdef _M_CEE_PURE
; 26   : #ifdef _WIN64
; 27   :     _Result = 63;
; 28   : #else // ^^^ 64-bit ^^^ / vvv 32-bit vvv
; 29   :     _Result = 31;
; 30   : #endif // 64 vs. 32-bit
; 31   : 
; 32   :     while ((size_t{1} << _Result) > _Value) {
; 33   :         --_Result;
; 34   :     }
; 35   : 
; 36   : #else // ^^^ _M_CEE_PURE ^^^ // vvv !_M_CEE_PURE vvv
; 37   : #ifdef _WIN64
; 38   :     _BitScanReverse64(&_Result, _Value);
; 39   : #else // ^^^ 64-bit ^^^ / vvv 32-bit vvv
; 40   :     _BitScanReverse(&_Result, _Value);

	bsr	eax, eax

; 41   : #endif // 64 vs. 32-bit
; 42   : #endif // _M_CEE_PURE
; 43   : 
; 44   :     return _Result;
; 45   : }

	ret	0
?_Floor_of_log_2@std@@YAKI@Z ENDP			; std::_Floor_of_log_2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??Rrandom_device@std@@QAEIXZ
_TEXT	SEGMENT
??Rrandom_device@std@@QAEIXZ PROC			; std::random_device::operator(), COMDAT
; _this$ = ecx

; 5113 :         return _Random_device();

	jmp	?_Random_device@std@@YAIXZ		; std::_Random_device
??Rrandom_device@std@@QAEIXZ ENDP			; std::random_device::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??0random_device@std@@QAE@XZ
_TEXT	SEGMENT
??0random_device@std@@QAE@XZ PROC			; std::random_device::random_device, COMDAT
; _this$ = ecx

; 5095 :     }

	mov	eax, ecx
	ret	0
??0random_device@std@@QAE@XZ ENDP			; std::random_device::random_device
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR [ecx+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 398  :     _NODISCARD locale __CLR_OR_THIS_CALL getloc() const { // get locale

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 272  :         _Ptr->_Incref();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 399  :         return *_Ploc;

	mov	eax, esi
	pop	esi

; 400  :     }

	ret	4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?width@ios_base@std@@QAE_J_J@Z
_TEXT	SEGMENT
__Newwidth$ = 8						; size = 8
?width@ios_base@std@@QAE_J_J@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 393  :         const streamsize _Oldwidth = _Wide;

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]
	push	esi

; 394  :         _Wide                      = _Newwidth;

	mov	esi, DWORD PTR __Newwidth$[esp]
	mov	DWORD PTR [ecx+32], esi
	mov	esi, DWORD PTR __Newwidth$[esp+4]
	mov	DWORD PTR [ecx+36], esi

; 395  :         return _Oldwidth;

	pop	esi

; 396  :     }

	ret	8
?width@ios_base@std@@QAE_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?width@ios_base@std@@QBE_JXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 389  :         return _Wide;

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]

; 390  :     }

	ret	0
?width@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?precision@ios_base@std@@QBE_JXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = ecx

; 379  :         return _Prec;

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+28]

; 380  :     }

	ret	0
?precision@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 352  :         return _Fmtfl;

	mov	eax, DWORD PTR [ecx+20]

; 353  :     }

	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 321  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [ecx+12], 0
	sete	al

; 322  :     }

	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 302  :         return _Mystate;

	mov	eax, DWORD PTR [ecx+12]

; 303  :     }

	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -20						; size = 20
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 270  :         _State &= _Statmask;

	mov	eax, DWORD PTR __State$[esp-4]
	sub	esp, 28					; 0000001cH
	and	eax, 23					; 00000017H

; 271  :         _Mystate             = _State;

	mov	DWORD PTR [ecx+12], eax

; 272  :         const auto _Filtered = _State & _Except;

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax

; 273  :         if (_Filtered) {

	je	SHORT $LN2@clear

; 274  :             if (_Reraise) {

	cmp	BYTE PTR __Reraise$[esp+24], 0
	je	SHORT $LN3@clear
	jmp	SHORT $LN11@clear
$LN2@clear:

; 288  :         }
; 289  :     }

	add	esp, 28					; 0000001cH
	ret	8
$LN11@clear:

; 275  :                 _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN3@clear:
	push	esi

; 276  :             }
; 277  : 
; 278  :             const char* _Msg;
; 279  :             if (_Filtered & ios_base::badbit) {

	test	cl, 4
	je	SHORT $LN4@clear

; 280  :                 _Msg = "ios_base::badbit set";

	mov	esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
	jmp	SHORT $LN6@clear
$LN4@clear:

; 281  :             } else if (_Filtered & ios_base::failbit) {

	test	cl, 2
	mov	esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
	mov	eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
	cmove	esi, eax
$LN6@clear:

; 282  :                 _Msg = "ios_base::failbit set";
; 283  :             } else {
; 284  :                 _Msg = "ios_base::eofbit set";
; 285  :             }
; 286  : 
; 287  :             _THROW(failure(_Msg));

	lea	eax, DWORD PTR $T1[esp+32]
	push	1
	push	eax
	call	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
	add	esp, 8
	lea	ecx, DWORD PTR $T2[esp+32]
	push	eax
	push	esi
	call	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[esp+36]
	push	eax
	call	__CxxThrowException@8
	pop	esi
$LN12@clear:
$LN9@clear:
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN14@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN14@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 68   :     {

	push	esi

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	esi, DWORD PTR ___that$[esp]
	xorps	xmm0, xmm0

; 68   :     {

	push	edi
	mov	edi, ecx

; 67   :         : _Data()

	lea	eax, DWORD PTR [edi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	___std_exception_copy
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	add	esp, 8
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	mov	DWORD PTR [edi], OFFSET ??_7failure@ios_base@std@@6B@
	pop	edi
	pop	esi
	ret	4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 226  :         explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))

	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+28], eax
	mov	edx, DWORD PTR __Message$[esp+24]
	mov	eax, DWORD PTR __Errcode$[esp+24]
	push	ebx
	push	ebp
	push	esi

; 227  :             : system_error(_Errcode, _Message) { // construct with message

	mov	ebx, DWORD PTR [eax+4]
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR $T1[esp+56], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 226  :         explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))

	push	edi

; 227  :             : system_error(_Errcode, _Message) { // construct with message

	mov	edi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T1[esp+64], 15		; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR $T1[esp+44], 0

; 301  :         return __builtin_strlen(_First);

	lea	ebp, DWORD PTR [ecx+1]
	npad	5
$LL91@failure:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL91@failure
	sub	ecx, ebp

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T1[esp+52]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 367  :         : _Mybase(_Errcode, _Message) { // construct from error code and message string

	lea	eax, DWORD PTR $T1[esp+44]
	mov	ecx, esi
	push	eax
	push	ebx
	push	edi
	call	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T1[esp+64]
	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN77@failure
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T1[esp+44]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN76@failure

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN94@failure
$LN76@failure:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN77@failure:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 228  :         }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+44]
	mov	eax, esi
	pop	edi
	mov	DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 28					; 0000001cH
	ret	8
$LN94@failure:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN92@failure:
	int	3
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Lock$1 = -76						; size = 4
$T2 = -72						; size = 4
__Lock$3 = -72						; size = 4
$T4 = -68						; size = 16
$T5 = -52						; size = 52
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 434  : { // get facet reference from locale

	sub	esp, 76					; 0000004cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	ebx, ebx

; 435  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	lea	ecx, DWORD PTR __Lock$3[esp+92]
	push	ebx
	mov	DWORD PTR $T2[esp+96], ebx
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	mov	edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id

; 436  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	ebp, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	test	edi, edi
	jne	SHORT $LN9@use_facet

; 100  :                 _BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$1[esp+96]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 101  :                 if (_Id == 0) {

	cmp	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, ebx ; std::ctype<char>::id
	jne	SHORT $LN10@use_facet

; 102  :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN10@use_facet:

; 103  :                 }
; 104  :                 _END_LOCK()

	lea	ecx, DWORD PTR __Lock$1[esp+92]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
$LN9@use_facet:

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	ecx, DWORD PTR __Loc$[esp+88]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN17@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	test	esi, esi
	jne	$LN88@use_facet
	jmp	SHORT $LN91@use_facet
$LN17@use_facet:

; 380  :     }
; 381  : 
; 382  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	esi, esi
$LN91@use_facet:

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [ecx+20], bl
	je	SHORT $LN15@use_facet

; 385  :             return _Facptr; // found facet or not transparent
; 386  :         } else { // look in current locale
; 387  :             locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 388  :             return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] // get from current locale

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN92@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 437  : 
; 438  :     const size_t _Id         = _Facet::id;
; 439  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 440  : 
; 441  :     if (_Pf == nullptr) {

	test	esi, esi
	jne	$LN88@use_facet
$LN92@use_facet:

; 442  :         if (_Psave != nullptr) {

	test	ebp, ebp
	je	SHORT $LN3@use_facet

; 462  :             _Pf                       = _Psave;
; 463  : 
; 464  :             (void) _Psave_guard.release();
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[esp+92]
	mov	esi, ebp
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

	add	esp, 76					; 0000004cH
	ret	0
$LN3@use_facet:

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN24@use_facet

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	eax, DWORD PTR __Loc$[esp+88]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN29@use_facet
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN34@use_facet
$LN29@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN34@use_facet
	lea	eax, DWORD PTR [ecx+28]
$LN34@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	push	eax
	lea	ecx, DWORD PTR $T5[esp+96]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	lea	eax, DWORD PTR $T4[esp+92]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2187 :         : ctype_base(_Refs) { // construct from current locale

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	call	__Getctype
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	mov	ebx, 1

; 2217 :         _Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+8], xmm0

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	jmp	SHORT $LN25@use_facet
$LN24@use_facet:
	xor	esi, esi
$LN25@use_facet:
	test	bl, 1
	je	SHORT $LN26@use_facet
	lea	ecx, DWORD PTR $T5[esp+92]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN26@use_facet:

; 443  :             _Pf = _Psave; // lazy facet already allocated
; 444  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {
; 445  : #if _HAS_EXCEPTIONS
; 446  :             _THROW(bad_cast{}); // lazy disallowed
; 447  : #else // _HAS_EXCEPTIONS
; 448  :             abort(); // lazy disallowed
; 449  : #endif // _HAS_EXCEPTIONS
; 450  :         } else { // queue up lazy facet for destruction
; 451  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);
; 452  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));
; 453  : 
; 454  : #if defined(_M_CEE)
; 455  :             _Facet_Register_m(_Pfmod);
; 456  : #else // defined(_M_CEE)
; 457  :             _Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 458  : #endif // defined(_M_CEE)
; 459  : 
; 460  :             _Pfmod->_Incref();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [edx+4]

; 461  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
$LN88@use_facet:

; 462  :             _Pf                       = _Psave;
; 463  : 
; 464  :             (void) _Psave_guard.release();
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[esp+92]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

	add	esp, 76					; 0000004cH
	ret	0
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2212 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 2221 :         if (0 < _Ctype._Delfl) {

	mov	eax, DWORD PTR [esi+16]

; 2212 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept { // destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@

; 2221 :         if (0 < _Ctype._Delfl) {

	test	eax, eax
	jle	SHORT $LN18@scalar

; 2222 :             _CSTD free((void*) _Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free
	jmp	SHORT $LN19@scalar
$LN18@scalar:

; 2223 :         } else if (_Ctype._Delfl < 0) {

	jns	SHORT $LN9@scalar

; 2224 :             delete[] _Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]
$LN19@scalar:

; 2225 :         }
; 2226 : 
; 2227 :         _CSTD free(_Ctype._LocaleName);

	add	esp, 4
$LN9@scalar:
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN17@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN17@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2275 :         _Adl_verify_range(_First, _Last);
; 2276 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, edx
	push	ecx
	push	edx
	push	DWORD PTR __Dest$[esp+4]
	call	_memcpy

; 2277 :         return _Last;

	mov	eax, DWORD PTR __Last$[esp+8]
	add	esp, 12					; 0000000cH

; 2278 :     }

	ret	16					; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2270 :         return _Ch;

	mov	al, BYTE PTR __Ch$[esp-4]

; 2271 :     }

	ret	8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2264 :         _Adl_verify_range(_First, _Last);
; 2265 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, edx
	push	ecx
	push	edx
	push	DWORD PTR __Dest$[esp+4]
	call	_memcpy

; 2266 :         return _Last;

	mov	eax, DWORD PTR __Last$[esp+8]
	add	esp, 12					; 0000000cH

; 2267 :     }

	ret	12					; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2259 :         return _Byte;

	mov	al, BYTE PTR __Byte$[esp-4]

; 2260 :     }

	ret	4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2249 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

	push	ebx

; 2250 :         _Adl_verify_range((const _Elem*) _First, _Last);
; 2251 :         for (; _First != _Last; ++_First) {

	mov	ebx, DWORD PTR __Last$[esp]
	xor	edx, edx
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	ebx, esi
	push	edi
	xor	edi, edi
	cmp	esi, DWORD PTR __Last$[esp+8]
	cmova	ebx, edx
	test	ebx, ebx
	je	SHORT $LN12@do_toupper
	push	ebp
	lea	ebp, DWORD PTR [ecx+8]
$LL4@do_toupper:

; 2252 :             *_First = (_Elem) _Toupper((unsigned char) *_First, &_Ctype);

	movzx	eax, BYTE PTR [esi]
	push	ebp
	push	eax
	call	__Toupper
	mov	BYTE PTR [esi], al
	inc	edi
	add	esp, 8
	inc	esi
	cmp	edi, ebx
	jne	SHORT $LL4@do_toupper

; 2253 :         }
; 2254 : 
; 2255 :         return (const _Elem*) _First;

	pop	ebp
$LN12@do_toupper:
	pop	edi

; 2256 :     }

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2245 :         return (_Elem) _Toupper((unsigned char) _Ch, &_Ctype);

	lea	eax, DWORD PTR [ecx+8]
	push	eax
	movzx	eax, BYTE PTR __Ch$[esp]
	push	eax
	call	__Toupper
	add	esp, 8

; 2246 :     }

	ret	4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2235 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

	push	ebx

; 2236 :         _Adl_verify_range((const _Elem*) _First, _Last);
; 2237 :         for (; _First != _Last; ++_First) {

	mov	ebx, DWORD PTR __Last$[esp]
	xor	edx, edx
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	ebx, esi
	push	edi
	xor	edi, edi
	cmp	esi, DWORD PTR __Last$[esp+8]
	cmova	ebx, edx
	test	ebx, ebx
	je	SHORT $LN12@do_tolower
	push	ebp
	lea	ebp, DWORD PTR [ecx+8]
$LL4@do_tolower:

; 2238 :             *_First = (_Elem) _Tolower((unsigned char) *_First, &_Ctype);

	movzx	eax, BYTE PTR [esi]
	push	ebp
	push	eax
	call	__Tolower
	mov	BYTE PTR [esi], al
	inc	edi
	add	esp, 8
	inc	esi
	cmp	edi, ebx
	jne	SHORT $LL4@do_tolower

; 2239 :         }
; 2240 : 
; 2241 :         return (const _Elem*) _First;

	pop	ebp
$LN12@do_tolower:
	pop	edi

; 2242 :     }

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2231 :         return (_Elem) _Tolower((unsigned char) _Ch, &_Ctype);

	lea	eax, DWORD PTR [ecx+8]
	push	eax
	movzx	eax, BYTE PTR __Ch$[esp]
	push	eax
	call	__Tolower
	add	esp, 8

; 2232 :     }

	ret	4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2220 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // free any allocated storage

	push	esi
	mov	esi, ecx

; 2221 :         if (0 < _Ctype._Delfl) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	jle	SHORT $LN6@Tidy

; 2222 :             _CSTD free((void*) _Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free

; 2225 :         }
; 2226 : 
; 2227 :         _CSTD free(_Ctype._LocaleName);

	add	esp, 4
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
	pop	esi

; 2228 :     }

	ret	0
$LN6@Tidy:

; 2223 :         } else if (_Ctype._Delfl < 0) {

	jns	SHORT $LN4@Tidy

; 2224 :             delete[] _Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]

; 2225 :         }
; 2226 : 
; 2227 :         _CSTD free(_Ctype._LocaleName);

	add	esp, 4
$LN4@Tidy:
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
	pop	esi

; 2228 :     }

	ret	0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2216 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

	sub	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	lea	eax, DWORD PTR $T1[esp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2216 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2216 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	call	__Getctype
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2217 :         _Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+8], xmm0
	pop	esi

; 2218 :     }

	add	esp, 16					; 00000010H
	ret	4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2212 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 2221 :         if (0 < _Ctype._Delfl) {

	mov	eax, DWORD PTR [esi+16]

; 2212 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept { // destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@

; 2221 :         if (0 < _Ctype._Delfl) {

	test	eax, eax
	jle	SHORT $LN14@ctype

; 2222 :             _CSTD free((void*) _Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free
	jmp	SHORT $LN15@ctype
$LN14@ctype:

; 2223 :         } else if (_Ctype._Delfl < 0) {

	jns	SHORT $LN6@ctype

; 2224 :             delete[] _Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]
$LN15@ctype:

; 2225 :         }
; 2226 : 
; 2227 :         _CSTD free(_Ctype._LocaleName);

	add	esp, 4
$LN6@ctype:
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2214 :     }

	ret	0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 16
$T3 = -52						; size = 52
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2192 :         const locale* _Ploc = nullptr) { // return locale category mask and construct standard facet

	sub	esp, 72					; 00000048H
	push	ebx
	push	edi

; 2193 :         if (_Ppf != nullptr && *_Ppf == nullptr) {

	mov	edi, DWORD PTR __Ppf$[esp+76]
	xor	ebx, ebx
	mov	DWORD PTR $T1[esp+80], ebx
	test	edi, edi
	je	SHORT $LN28@Getcat
	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN28@Getcat

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	push	esi
	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN4@Getcat

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	ecx, DWORD PTR __Ploc$[esp+80]
	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	jne	SHORT $LN9@Getcat
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN14@Getcat
$LN9@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN14@Getcat
	lea	eax, DWORD PTR [ecx+28]
$LN14@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	push	eax
	lea	ecx, DWORD PTR $T3[esp+88]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	lea	eax, DWORD PTR $T2[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2187 :         : ctype_base(_Refs) { // construct from current locale

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	call	__Getctype
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	mov	ebx, 1

; 2217 :         _Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+8], xmm0

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	esi, esi
$LN5@Getcat:
	mov	DWORD PTR [edi], esi
	pop	esi
	test	bl, 1
	je	SHORT $LN28@Getcat
	lea	ecx, DWORD PTR $T3[esp+80]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN28@Getcat:

; 2195 :         }
; 2196 : 
; 2197 :         return _X_CTYPE;
; 2198 :     }

	pop	edi
	mov	eax, 2
	pop	ebx
	add	esp, 72					; 00000048H
	ret	0
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T1 = -16						; size = 16
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	eax, DWORD PTR __Refs$[esp-4]

; 2186 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)

	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	lea	eax, DWORD PTR $T1[esp+20]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2187 :         : ctype_base(_Refs) { // construct from current locale

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	call	__Getctype
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2217 :         _Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]

; 2188 :         _Init(_Lobj);
; 2189 :     }

	mov	eax, esi

; 2217 :         _Ctype = _Lobj._Getctype();

	movups	XMMWORD PTR [esi+8], xmm0

; 2188 :         _Init(_Lobj);
; 2189 :     }

	pop	esi
	add	esp, 16					; 00000010H
	ret	8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z PROC		; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2155 :         return do_widen(_First, _Last, _Dest);

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+28]
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN10@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 1853 :     }

	ret	0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	eax, DWORD PTR __Refs$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 1850 :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@
	ret	4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z PROC	; std::_Adl_verify_range<char const *,char const *>, COMDAT

; 217  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 218  :         _Verify_range(_First, _Last);
; 219  :     } else {
; 220  :         (void) _First; // TRANSITION, VSO#486357
; 221  :         (void) _Last; // TRANSITION, VSO#486357
; 222  :     }
; 223  : }

	ret	0
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ENDP	; std::_Adl_verify_range<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	cmovb	eax, edx

; 22   : }

	ret	0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR __Id$[esp]
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	eax, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	test	eax, eax
	jne	SHORT $LN3@Getfacet
	jmp	SHORT $LN10@Getfacet
$LN6@Getfacet:

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	eax, eax
$LN10@Getfacet:

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN3@Getfacet

; 385  :             return _Facptr; // found facet or not transparent
; 386  :         } else { // look in current locale
; 387  :             locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 388  :             return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] // get from current locale

	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN8@Getfacet
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 389  :                                             : nullptr; // no entry in current locale
; 390  :         }
; 391  :     }

	ret	4
$LN8@Getfacet:

; 388  :             return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] // get from current locale

	xor	eax, eax
$LN3@Getfacet:
	pop	esi

; 389  :                                             : nullptr; // no entry in current locale
; 390  :         }
; 391  :     }

	ret	4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = ecx

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@c_str
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@

; 380  :     }

	ret	0
$LN3@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN7@c_str
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	eax, ecx

; 380  :     }

	ret	0
$LN7@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	add	eax, 28					; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 380  :     }

	ret	0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 359  :         if (_Ptr != nullptr) {

	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN4@locale

; 360  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN4@locale
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN4@locale:

; 361  :         }
; 362  :     }

	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR __Right$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]

; 273  :     }

	mov	eax, esi
	pop	esi
	ret	4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN8@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 156  :         }

	ret	0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	eax, DWORD PTR __Initrefs$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 153  :         }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 139  :             if (_MT_DECR(_Myrefs) == 0) {

	or	eax, -1
	lock	 xadd	 DWORD PTR [ecx+4], eax
	mov	eax, 0
	cmove	eax, ecx

; 140  :                 return this;
; 141  :             }
; 142  : 
; 143  :             return nullptr;
; 144  :         }

	ret	0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 135  :             _MT_INCR(_Myrefs);

	lock	 inc	 DWORD PTR [ecx+4]

; 136  :         }

	ret	0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 98   :         __CLR_OR_THIS_CALL operator size_t() { // get stamp, with lazy allocation

	push	ecx
	push	esi
	mov	esi, ecx

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN5@operator

; 100  :                 _BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$1[esp+12]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 101  :                 if (_Id == 0) {

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN3@operator

; 102  :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR [esi], eax
$LN3@operator:

; 103  :                 }
; 104  :                 _END_LOCK()

	lea	ecx, DWORD PTR __Lock$1[esp+8]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN5@operator:

; 105  :             }
; 106  :             return _Id;
; 107  :         }

	mov	eax, DWORD PTR [esi]
	pop	esi
	pop	ecx
	ret	0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 95   :         __CLR_OR_THIS_CALL id(size_t _Val = 0) : _Id(_Val) { // construct with specified stamp value

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [ecx], eax

; 96   :         }

	mov	eax, ecx
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 3399 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // discard any string

	push	esi
	mov	esi, ecx

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN4@Tidy:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;
; 3409 :     }

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3378 :     __CLR_OR_THIS_CALL ~_Yarn() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Yarn

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN6@Yarn:

; 3379 :         _Tidy();
; 3380 :     }

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3333 :     __CLR_OR_THIS_CALL _Yarn() : _Myptr(nullptr), _Nul(0) { // default construct

	xor	eax, eax
	mov	DWORD PTR [ecx], 0
	mov	WORD PTR [ecx+4], ax

; 3334 :     }

	mov	eax, ecx
	ret	0
??0?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 3399 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // discard any string

	push	esi
	mov	esi, ecx

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN4@Tidy:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;
; 3409 :     }

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN4@c_str
	lea	eax, DWORD PTR [ecx+4]
$LN4@c_str:

; 3388 :     }

	ret	0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 3378 :     __CLR_OR_THIS_CALL ~_Yarn() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Yarn

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN6@Yarn:

; 3379 :         _Tidy();
; 3380 :     }

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 3333 :     __CLR_OR_THIS_CALL _Yarn() : _Myptr(nullptr), _Nul(0) { // default construct

	mov	DWORD PTR [ecx], 0

; 3334 :     }

	mov	eax, ecx
	mov	BYTE PTR [ecx+4], 0
	ret	0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 154  :         return "true";

	mov	eax, OFFSET ??_C@_04LOAJBDKD@true@

; 155  :     }

	ret	0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 150  :         return "false";

	mov	eax, OFFSET ??_C@_05LAPONLG@false@

; 151  :     }

	ret	0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 116  :         return localeconv();

	jmp	_localeconv
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T1 = -44						; size = 44
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 111  :     _Cvtvec __CLR_OR_THIS_CALL _Getcvt() const { // return codecvt stuff

	sub	esp, 44					; 0000002cH

; 112  :         return ::_Getcvt();

	lea	eax, DWORD PTR $T1[esp+44]
	push	eax
	call	__Getcvt
	mov	edx, DWORD PTR ___$ReturnUdt$[esp+44]
	movups	xmm0, XMMWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+40]
	movups	XMMWORD PTR [edx], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [edx+16], xmm0
	movq	xmm0, QWORD PTR [eax+32]
	mov	eax, edx
	movq	QWORD PTR [edx+32], xmm0
	mov	DWORD PTR [edx+40], ecx

; 113  :     }

	add	esp, 48					; 00000030H
	ret	4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 107  :     _Ctypevec __CLR_OR_THIS_CALL _Getctype() const { // return ctype stuff

	sub	esp, 16					; 00000010H

; 108  :         return ::_Getctype();

	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	__Getctype
	movups	xmm0, XMMWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	movups	XMMWORD PTR [eax], xmm0

; 109  :     }

	add	esp, 20					; 00000014H
	ret	4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 87   :     __CLR_OR_THIS_CALL ~_Locinfo() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 88   :         _Locinfo_dtor(this);

	push	esi
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+44]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 88   :         _Locinfo_dtor(this);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3400 :         if (_Myptr != nullptr) {

	test	eax, eax
	je	SHORT $LN6@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN6@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+44], 0

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN11@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN11@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+36], 0

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN16@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN16@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+28], 0

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN21@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN21@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+20], 0

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN26@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN26@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+12], 0

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN31@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN31@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 89   :     }

	mov	ecx, esi
	pop	esi
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 66   :     { // construct from NTBS

	push	esi
	push	0
	mov	esi, ecx
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3333 :     __CLR_OR_THIS_CALL _Yarn() : _Myptr(nullptr), _Nul(0) { // default construct

	xor	eax, eax
	mov	DWORD PTR [esi+4], 0
	mov	WORD PTR [esi+24], ax
	mov	DWORD PTR [esi+28], eax
	mov	WORD PTR [esi+32], ax
	mov	DWORD PTR [esi+36], eax
	mov	BYTE PTR [esi+40], al
	mov	DWORD PTR [esi+44], eax
	mov	BYTE PTR [esi+48], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 67   :         if (_Pch == nullptr) {

	mov	eax, DWORD PTR __Pch$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3333 :     __CLR_OR_THIS_CALL _Yarn() : _Myptr(nullptr), _Nul(0) { // default construct

	mov	BYTE PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	BYTE PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 67   :         if (_Pch == nullptr) {

	test	eax, eax
	je	SHORT $LN18@Locinfo

; 69   :         }
; 70   : 
; 71   :         _Locinfo_ctor(this, _Pch);

	push	eax
	push	esi
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
	add	esp, 8

; 72   :     }

	mov	eax, esi
	pop	esi
	ret	4
$LN18@Locinfo:

; 68   :             _Xruntime_error("bad locale name");

	push	OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
	call	?_Xruntime_error@std@@YAXPBD@Z		; std::_Xruntime_error
$LN16@Locinfo:
	int	3
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN6@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT	SEGMENT
??0_Facet_base@std@@QAE@XZ PROC				; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
	mov	eax, ecx
	ret	0
??0_Facet_base@std@@QAE@XZ ENDP				; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@

; 25   :     }

	ret	0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_typeinfo.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 131  :     {

	xorps	xmm0, xmm0

; 132  :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 61   :         : _Data()

	movq	QWORD PTR [ecx+4], xmm0

; 62   :     {
; 63   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_typeinfo.h

; 131  :     {

	mov	DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@

; 132  :     }

	ret	0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ PROC ; std::_Immortalize<std::_Iostream_error_category>, COMDAT

; 502  :     static_assert(sizeof(void*) == sizeof(once_flag), "TRANSITION, VSO#406237");
; 503  :     static_assert(alignof(void*) == alignof(once_flag), "TRANSITION, VSO#406237");
; 504  :     static void* _Flag = nullptr;
; 505  :     static aligned_union_t<1, _Ty> _Storage;
; 506  :     if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage)
; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	push	OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	push	OFFSET ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
	push	OFFSET ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
	call	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z ; std::_Execute_once
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	_terminate

; 508  :         _STD terminate();
; 509  :     }
; 510  : 
; 511  :     return reinterpret_cast<_Ty&>(_Storage);

	mov	eax, OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage

; 512  : }

	ret	0
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ENDP ; std::_Immortalize<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	je	SHORT $LN10@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 429  :         if (_Errcode == (int) io_errc::stream) {

	mov	eax, DWORD PTR __Errcode$[esp-4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	cmp	eax, 1
	jne	SHORT $LN2@message
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	21					; 00000015H
	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error@
	mov	ecx, esi

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 434  :     }

	mov	eax, esi
	pop	esi
	ret	8
$LN2@message:
	push	edi

; 413  :         return _Syserror_map(_Errcode);

	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	mov	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 413  :         return _Syserror_map(_Errcode);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]
$LL67@message:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL67@message
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 432  :             return _Generic_error_category::message(_Errcode);

	pop	edi

; 434  :     }

	mov	eax, esi
	pop	esi
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 425  :         return "iostream";

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream@

; 426  :     }

	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 420  :     _Iostream_error_category() noexcept { // default constructor

	mov	DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@

; 421  :         _Addr = _Iostream_addr;
; 422  :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 5
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	je	SHORT $LN8@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 412  :     _NODISCARD virtual string message(int _Errcode) const override { // convert to name of error

	push	esi
	push	edi

; 413  :         return _Syserror_map(_Errcode);

	push	DWORD PTR __Errcode$[esp+4]
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 413  :         return _Syserror_map(_Errcode);

	mov	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 413  :         return _Syserror_map(_Errcode);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	npad	6
$LL33@message:

; 301  :         return __builtin_strlen(_First);

	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL33@message
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 413  :         return _Syserror_map(_Errcode);

	pop	edi
	mov	eax, esi
	pop	esi

; 414  :     }

	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 409  :         return "generic";

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic@

; 410  :     }

	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 404  :     _Generic_error_category() noexcept { // default constructor

	mov	DWORD PTR [ecx], OFFSET ??_7_Generic_error_category@std@@6B@

; 405  :         _Addr = _Generic_addr;
; 406  :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 3
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN12@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx

; 68   :     {

	push	esi

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	esi, DWORD PTR ___that$[esp]
	xorps	xmm0, xmm0

; 68   :     {

	push	edi
	mov	edi, ecx

; 67   :         : _Data()

	lea	eax, DWORD PTR [edi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	___std_exception_copy
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	add	esp, 8
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	mov	DWORD PTR [edi], OFFSET ??_7system_error@std@@6B@
	pop	edi
	pop	esi
	ret	4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 366  :     system_error(error_code _Errcode, const char* _Message)

	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+28], eax
	mov	edx, DWORD PTR __Message$[esp+24]
	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR $T1[esp+48], 0

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T1[esp+52], 15		; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 366  :     system_error(error_code _Errcode, const char* _Message)

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 343  :         _Left = _Right;

	mov	BYTE PTR $T1[esp+36], 0

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]
$LL88@system_err:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL88@system_err
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T1[esp+44]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 367  :         : _Mybase(_Errcode, _Message) { // construct from error code and message string

	lea	eax, DWORD PTR $T1[esp+36]
	mov	ecx, esi
	push	eax
	push	DWORD PTR __Errcode$[esp+40]
	push	DWORD PTR __Errcode$[esp+40]
	call	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T1[esp+56]
	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN75@system_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T1[esp+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN74@system_err

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN91@system_err
$LN74@system_err:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN75@system_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 368  :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+36]
	mov	eax, esi
	pop	edi
	mov	DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
$LN91@system_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN89@system_err:
	int	3
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 68   :     {

	push	esi

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	esi, DWORD PTR ___that$[esp]
	xorps	xmm0, xmm0

; 68   :     {

	push	edi
	mov	edi, ecx

; 67   :         : _Data()

	lea	eax, DWORD PTR [edi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	___std_exception_copy
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	add	esp, 8
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = -84						; size = 24
__InitData$2 = -60					; size = 8
$T3 = -52						; size = 24
$T4 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 348  :           _Mycode(_Errcode) { // construct from error code and message string

	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+84], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Message$[esp+96]
	mov	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	ebp, DWORD PTR [edi+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN35@System_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edi, DWORD PTR [edi]
$LN35@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2443 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	ebp, 16					; 00000010H
	jae	SHORT $LN24@System_err

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	xmm0, XMMWORD PTR [edi]

; 2446 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T1[esp+120], 15		; 0000000fH

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	XMMWORD PTR $T1[esp+100], xmm0

; 2447 :             return;

	jmp	SHORT $LN337@System_err
$LN24@System_err:

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	esi, ebp

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR $T1[esp+100]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	eax, 2147483647				; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	or	esi, 15					; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	esi, eax
	cmova	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	ecx, eax

; 2453 :         _Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_array);
; 2454 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	eax, DWORD PTR [ebp+1]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	edi
	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR $T1[esp+112], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	call	_memcpy
	add	esp, 12					; 0000000cH

; 2456 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR $T1[esp+120], esi
$LN337@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 347  :         : runtime_error(_Makestr(_Errcode, _Message)),

	mov	edi, DWORD PTR __Errcode$[esp+96]
	mov	esi, DWORD PTR __Errcode$[esp+100]
	mov	DWORD PTR $T1[esp+116], ebp
	test	ebp, ebp

; 337  :         if (!_Message.empty()) {

	je	SHORT $LN78@System_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2627 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@
	lea	ecx, DWORD PTR $T1[esp+108]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN78@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 151  :         return category().message(value());

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T3[esp+100]
	push	edi
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR $T3[esp+120], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T3[esp+100]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	push	DWORD PTR $T3[esp+116]

; 2024 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR $T3[esp+104]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	lea	ecx, DWORD PTR $T1[esp+104]
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T3[esp+120]
	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN155@System_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T3[esp+100]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN154@System_err

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN339@System_err
$LN154@System_err:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN155@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm1, XMMWORD PTR $T1[esp+100]

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR $T4[esp+100]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR $T1[esp+120], 16		; 00000010H

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movq	xmm0, QWORD PTR $T1[esp+116]

; 2024 :         if (_Large_string_engaged()) {

	movd	eax, xmm1

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movq	QWORD PTR $T4[esp+116], xmm0
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 55   :     {

	mov	DWORD PTR [ebx], OFFSET ??_7exception@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	cmovae	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 54   :         : _Data()

	movq	QWORD PTR [ebx+4], xmm0
	lea	eax, DWORD PTR [ebx+4]

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$2[esp+100], ecx

; 57   :         __std_exception_copy(&_InitData, &_Data);

	push	eax
	lea	eax, DWORD PTR __InitData$2[esp+104]
	mov	BYTE PTR __InitData$2[esp+108], 1
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	XMMWORD PTR $T4[esp+108], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 57   :         __std_exception_copy(&_InitData, &_Data);

	call	___std_exception_copy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T4[esp+128]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 57   :         __std_exception_copy(&_InitData, &_Data);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

	mov	DWORD PTR [ebx], OFFSET ??_7runtime_error@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN324@System_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T4[esp+100]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN323@System_err

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN340@System_err
$LN323@System_err:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN324@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 348  :           _Mycode(_Errcode) { // construct from error code and message string

	mov	ecx, DWORD PTR __Errcode$[esp+96]

; 349  :     }

	mov	eax, ebx
	pop	edi
	mov	DWORD PTR [ebx+12], ecx
	mov	ecx, DWORD PTR __Errcode$[esp+96]
	pop	esi
	mov	DWORD PTR [ebx+16], ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+92]
	pop	ebp
	mov	DWORD PTR [ebx], OFFSET ??_7_System_error@std@@6B@
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 84					; 00000054H
	ret	12					; 0000000cH
$LN339@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN340@System_err:
	call	__invalid_parameter_noinfo_noreturn
$LN336@System_err:
	int	3
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 24
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 336  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+28], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3321 :         return size() == 0;

	cmp	DWORD PTR __Message$[esp+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 336  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]

; 337  :         if (!_Message.empty()) {

	je	SHORT $LN2@Makestr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2627 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@
	lea	ecx, DWORD PTR __Message$[esp+36]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Makestr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 151  :         return category().message(value());

	mov	ecx, DWORD PTR __Errcode$[esp+32]
	lea	edx, DWORD PTR $T1[esp+32]
	push	DWORD PTR __Errcode$[esp+28]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR $T1[esp+52], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T1[esp+32]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	push	DWORD PTR $T1[esp+48]

; 2024 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR $T1[esp+36]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	lea	ecx, DWORD PTR __Message$[esp+32]
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T1[esp+52]
	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN79@Makestr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T1[esp+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN78@Makestr

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN190@Makestr
$LN78@Makestr:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN79@Makestr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR __Message$[esp+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 343  :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+32]
	mov	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR __Message$[esp+44]
	movq	QWORD PTR [esi+16], xmm0
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 343  :     }

	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 28					; 0000001cH
	ret	0
$LN190@Makestr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN188@Makestr:
	int	3
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ?_Do_hash@?$hash@H@std@@SAIABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Do_hash@?$hash@H@std@@SAIABH@Z PROC			; std::hash<int>::_Do_hash, COMDAT

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	edx, DWORD PTR __Keyval$[esp-4]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 1937 :         _Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619

; 2008 :         return _Hash_representation(_Keyval);
; 2009 :     }

	ret	0
?_Do_hash@?$hash@H@std@@SAIABH@Z ENDP			; std::hash<int>::_Do_hash
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z PROC ; std::_Conditionally_enabled_hash<int,1>::operator(), COMDAT
; _this$ = ecx

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	edx, DWORD PTR __Keyval$[esp-4]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 1937 :         _Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619

; 1986 :         noexcept(hash<_Kty>::_Do_hash(_Keyval))) { // hash _Keyval to size_t value by pseudorandomizing transform
; 1987 :         return hash<_Kty>::_Do_hash(_Keyval);
; 1988 :     }

	ret	4
??R?$_Conditionally_enabled_hash@H$00@std@@QBEIABH@Z ENDP ; std::_Conditionally_enabled_hash<int,1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??8std@@YA_NABVerror_condition@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8std@@YA_NABVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 83   :         return _Addr == _Right._Addr;

	mov	edx, DWORD PTR __Left$[esp-4]

; 233  :     const error_condition& _Left, const error_condition& _Right) noexcept { // test errors for equality

	push	esi

; 83   :         return _Addr == _Right._Addr;

	mov	esi, DWORD PTR __Right$[esp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [ecx+4]

; 234  :     return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN3@operator
	mov	al, 1
	pop	esi

; 235  : }

	ret	0
$LN3@operator:

; 234  :     return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	xor	al, al
	pop	esi

; 235  : }

	ret	0
??8std@@YA_NABVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 200  :         return *_Mycat;

	mov	eax, DWORD PTR [ecx+4]

; 201  :     }

	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 196  :         return _Myval;

	mov	eax, DWORD PTR [ecx]

; 197  :     }

	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 170  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Cat$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 171  :     }

	mov	eax, ecx
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 145  :         return *_Mycat;

	mov	eax, DWORD PTR [ecx+4]

; 151  :         return category().message(value());

	push	DWORD PTR [ecx]
	mov	ecx, eax
	push	DWORD PTR ___$ReturnUdt$[esp]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 152  :     }

	ret	4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 145  :         return *_Mycat;

	mov	eax, DWORD PTR [ecx+4]

; 146  :     }

	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 141  :         return _Myval;

	mov	eax, DWORD PTR [ecx]

; 142  :     }

	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 115  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Cat$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 116  :     }

	mov	eax, ecx
	ret	8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 83   :         return _Addr == _Right._Addr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	sete	al

; 84   :     }

	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 83   :         return _Addr == _Right._Addr;

	mov	eax, DWORD PTR [ecx+4]

; 282  :     noexcept { // test if conditions same for this category

	push	esi

; 83   :         return _Addr == _Right._Addr;

	mov	esi, DWORD PTR __Code$[esp]
	mov	edx, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [edx+4]

; 283  :     return *this == _Code.category() && _Code.value() == _Errval;

	jne	SHORT $LN3@equivalent
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR __Errval$[esp]
	jne	SHORT $LN3@equivalent
	mov	al, 1
	pop	esi

; 284  : }

	ret	8
$LN3@equivalent:

; 283  :     return *this == _Code.category() && _Code.value() == _Errval;

	xor	al, al
	pop	esi

; 284  : }

	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 278  :     return default_error_condition(_Errval) == _Cond;

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T1[esp]
	sub	esp, 8
	push	esi
	push	DWORD PTR __Errval$[esp+8]
	push	edx
	call	DWORD PTR [eax+12]

; 83   :         return _Addr == _Right._Addr;

	mov	esi, DWORD PTR __Cond$[esp+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx+4]

; 234  :     return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	jne	SHORT $LN5@equivalent
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN5@equivalent
	mov	al, 1
	pop	esi

; 279  : }

	add	esp, 8
	ret	8
$LN5@equivalent:

; 234  :     return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	xor	al, al
	pop	esi

; 279  : }

	add	esp, 8
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 170  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Errval$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 273  :     return error_condition(_Errval, *this);
; 274  : }

	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 70   :     virtual ~error_category() noexcept {}

	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 66   :         // default constructor
; 67   :         _Addr = reinterpret_cast<uintptr_t>(this);

	mov	DWORD PTR [ecx+4], ecx

; 68   :     }

	mov	eax, ecx
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?iostream_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAABVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	push	OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	push	OFFSET ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
	push	OFFSET ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
	call	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z ; std::_Execute_once
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	_terminate

; 520  :     return _Immortalize<_Iostream_error_category>();
; 521  : }

	mov	eax, OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	ret	0
?iostream_category@std@@YAABVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	push	OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	push	OFFSET ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
	push	OFFSET ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
	call	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z ; std::_Execute_once
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	_terminate

; 115  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Errno$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage

; 298  :     return error_code((int) _Errno, iostream_category());
; 299  : }

	ret	0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 68   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 67   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[esp+4]
	add	eax, 4
	push	eax
	call	___std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2023 :         const value_type* _Result = _Bx._Buf;

	mov	edx, DWORD PTR __Message$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

	sub	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edx+20], 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@runtime_er
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edx, DWORD PTR [edx]
$LN10@runtime_er:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 54   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 55   :     {

	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$1[esp+12], edx

; 57   :         __std_exception_copy(&_InitData, &_Data);

	push	eax
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR __InitData$1[esp+16]
	push	eax
	mov	BYTE PTR __InitData$1[esp+24], 1
	call	___std_exception_copy
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 127  :     }

	mov	eax, esi
	pop	esi
	add	esp, 8
	ret	4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1541 :         return *this;

	mov	eax, ecx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data, COMDAT
; _this$ = ecx

; 3912 :         return _Mypair._Get_second();

	mov	eax, ecx

; 3913 :     }

	ret	0
?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data, COMDAT
; _this$ = ecx

; 3908 :         return _Mypair._Get_second();

	mov	eax, ecx

; 3909 :     }

	ret	0
?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3904 :         return _Mypair._Get_first();

	mov	eax, ecx

; 3905 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3900 :         return _Mypair._Get_first();

	mov	eax, ecx

; 3901 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Orphan_all@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Orphan_all, COMDAT
; _this$ = ecx

; 3891 :         _Get_data()._Orphan_all();
; 3892 :     }

	ret	0
?_Orphan_all@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 3886 :         _Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3868 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	esi
	mov	esi, ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3869 :         _Orphan_all();
; 3870 :         auto& _My_data = _Get_data();
; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN41@Tidy_deall
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN40@Tidy_deall

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN37@Tidy_deall

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN40@Tidy_deall:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN41@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi

; 3883 :     }

	ret	0
$LN37@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN46@Tidy_deall:
	int	3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3860 :         auto& _My_data   = _Get_data();
; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ecx], 0

; 3863 :         // the _Traits::assign is last so the codegen doesn't think the char
; 3864 :         // write can alias this
; 3865 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3866 :     }

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	mov	eax, DWORD PTR __Newsize$[esp-4]
	mov	DWORD PTR [ecx+16], eax
	jb	SHORT $LN16@Eos
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 343  :         _Left = _Right;

	mov	BYTE PTR [edx+eax], 0

; 3855 :         auto& _My_data = _Get_data();
; 3856 :         _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());
; 3857 :     }

	ret	4
$LN16@Eos:

; 343  :         _Left = _Right;

	mov	BYTE PTR [ecx+eax], 0

; 3855 :         auto& _My_data = _Get_data();
; 3856 :         _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());
; 3857 :     }

	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 3766 :         const size_type _Max    = max_size();
; 3767 :         auto& _My_data          = _Get_data();
; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edx, DWORD PTR __Requested$[esp-4]
	or	edx, 15					; 0000000fH
	push	esi
	cmp	edx, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN25@Calculate_

; 3770 :             return _Max;
; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;

	mov	esi, DWORD PTR [ecx+20]

; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, 2147483647				; 7fffffffH
	mov	ecx, esi
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	ja	SHORT $LN25@Calculate_

; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	edx, eax
	pop	esi
	cmovb	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	mov	eax, edx

; 3779 :     }

	ret	4
$LN25@Calculate_:

; 3775 :             return _Max;

	mov	eax, 2147483647				; 7fffffffH
	pop	esi

; 3779 :     }

	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 3321 :         return size() == 0;

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 3322 :     }

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
tv665 = -12						; size = 4
tv657 = -12						; size = 4
tv658 = -8						; size = 4
__Old_size$1$ = -8					; size = 4
__Old$1$ = -4						; size = 4
__New_ptr$1$ = 8					; size = 4
__Newsize$ = 8						; size = 4
tv663 = 12						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 3276 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Elem _Ch = _Elem()) {

	sub	esp, 12					; 0000000cH
	push	ebp

; 3277 :         // determine new length, padding with _Ch elements as needed
; 3278 :         const size_type _Old_size = size();
; 3279 :         if (_Newsize <= _Old_size) {

	mov	ebp, DWORD PTR __Newsize$[esp+12]
	push	esi
	mov	esi, ecx

; 3264 :         return _Get_data()._Mysize;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR __Old_size$1$[esp+20], ecx

; 3276 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Elem _Ch = _Elem()) {

	push	edi

; 3264 :         return _Get_data()._Mysize;

	mov	edx, DWORD PTR [esi+20]
	lea	edi, DWORD PTR [esi+16]
	mov	DWORD PTR tv665[esp+24], edi
	mov	DWORD PTR __Old$1$[esp+24], edx

; 3277 :         // determine new length, padding with _Ch elements as needed
; 3278 :         const size_type _Old_size = size();
; 3279 :         if (_Newsize <= _Old_size) {

	cmp	ebp, ecx
	ja	SHORT $LN2@resize

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN18@resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	esi, DWORD PTR [esi]
$LN18@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3856 :         _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi], ebp
	pop	edi

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebp], 0

; 3284 :     }

	pop	esi
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
$LN2@resize:
	push	ebx

; 3280 :             _Eos(_Newsize);
; 3281 :         } else {
; 3282 :             append(_Newsize - _Old_size, _Ch);

	mov	ebx, ebp

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	eax, edx

; 3280 :             _Eos(_Newsize);
; 3281 :         } else {
; 3282 :             append(_Newsize - _Old_size, _Ch);

	sub	ebx, ecx

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN27@resize

; 2634 :             _My_data._Mysize      = _Old_size + _Count;

	mov	DWORD PTR [edi], ebp

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN34@resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	esi, DWORD PTR [esi]
$LN34@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+24]

; 2636 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	add	esi, ecx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
	pop	ebx
	pop	edi

; 3284 :     }

	pop	esi
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
$LN27@resize:

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	eax, 2147483647				; 7fffffffH
	sub	eax, ecx
	cmp	eax, ebx
	jb	$LN149@resize

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, ebp
	or	edi, 15					; 0000000fH
	cmp	edi, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN68@resize

; 3770 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN67@resize
$LN68@resize:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, edx
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN69@resize

; 3775 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN67@resize
$LN69@resize:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN67@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;

	mov	ecx, DWORD PTR tv665[esp+28]

; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR __New_ptr$1$[esp+24], eax
	mov	DWORD PTR [ecx], ebp

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	movsx	ecx, BYTE PTR __Ch$[esp+24]

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	ebp, DWORD PTR __Old$1$[esp+28]
	mov	DWORD PTR tv663[esp+24], ecx
	mov	ecx, DWORD PTR __Old_size$1$[esp+28]
	push	ecx
	lea	edi, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv658[esp+32], edi
	lea	edx, DWORD PTR [edi+ebx]
	mov	DWORD PTR tv657[esp+32], edx
	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN46@resize

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	DWORD PTR tv663[esp+40]
	push	DWORD PTR tv658[esp+48]
	call	_memset

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv657[esp+52]

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	inc	ebp

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebp, 4096				; 00001000H
	jb	SHORT $LN123@resize

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [edi-4]
	add	ebp, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN120@resize

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, ecx
$LN123@resize:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ebp
	push	edi
	call	??3@YAXPAXI@Z				; operator delete

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR __New_ptr$1$[esp+32]

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [esi], eax
	pop	ebx
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3284 :     }

	pop	esi
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
$LN46@resize:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	DWORD PTR tv663[esp+40]
	push	edi
	call	_memset
	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi+ebx], 0
	lea	eax, DWORD PTR [edi+ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR __New_ptr$1$[esp+24]
	mov	DWORD PTR [esi], eax
	pop	ebx
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3284 :     }

	pop	esi
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
$LN149@resize:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN150@resize:
$LN120@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN151@resize:
$LN146@resize:
	int	3
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3268 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3269 :         const size_type _Storage_max = // can always store small string
; 3270 :             _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3271 :         return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, 2147483647				; 7fffffffH

; 3272 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3273 :         );
; 3274 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3264 :         return _Get_data()._Mysize;

	mov	eax, DWORD PTR [ecx+16]

; 3265 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN14@c_str

; 3246 :         return _Get_data()._Myptr();

	mov	eax, DWORD PTR [ecx]

; 3247 :     }

	ret	0
$LN14@c_str:

; 3246 :         return _Get_data()._Myptr();

	mov	eax, ecx

; 3247 :     }

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2024 :         if (_Large_string_engaged()) {

	mov	eax, DWORD PTR __Off$[esp-4]
	jb	SHORT $LN14@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	ecx, DWORD PTR [ecx]
$LN14@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3190 :     }

	add	eax, ecx
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	mov	eax, DWORD PTR __Off$[esp-4]
	jb	SHORT $LN14@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	ecx, DWORD PTR [ecx]
$LN14@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3182 :     }

	add	eax, ecx
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
__Old$1$ = -16						; size = 4
tv595 = -12						; size = 4
tv593 = -8						; size = 4
__New_ptr$1$ = -4					; size = 4
__Off$ = 8						; size = 4
tv594 = 12						; size = 4
__Count$ = 12						; size = 4
tv603 = 16						; size = 4
__Ch$ = 16						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2801 :     basic_string& insert(const size_type _Off, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi
	mov	edi, ecx

; 2036 :         if (_Mysize < _Off) {

	mov	ecx, DWORD PTR __Off$[esp+20]
	mov	ebx, DWORD PTR [edi+16]
	cmp	ebx, ecx
	jb	$LN127@insert

; 2802 :         // insert _Count * _Ch at _Off
; 2803 :         auto& _My_data = _Get_data();
; 2804 :         _My_data._Check_offset(_Off);
; 2805 :         const size_type _Old_size = _My_data._Mysize;
; 2806 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	edx, DWORD PTR [edi+20]
	mov	eax, edx
	push	ebp
	mov	ebp, DWORD PTR __Count$[esp+24]
	sub	eax, ebx
	mov	DWORD PTR __Old$1$[esp+28], edx
	push	esi
	cmp	ebp, eax
	ja	SHORT $LN2@insert

; 2807 :             _My_data._Mysize        = _Old_size + _Count;

	lea	eax, DWORD PTR [ebx+ebp]
	mov	DWORD PTR [edi+16], eax

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	eax, edi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN13@insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	eax, DWORD PTR [edi]
$LN13@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	sub	ebx, ecx

; 2808 :             _Elem* const _Old_ptr   = _My_data._Myptr();
; 2809 :             _Elem* const _Insert_at = _Old_ptr + _Off;

	lea	esi, DWORD PTR [eax+ecx]

; 2810 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	ebx
	lea	eax, DWORD PTR [esi+ebp]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	ebx
	push	esi
	push	eax
	call	_memmove

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+40]
	push	ebp
	push	eax
	push	esi
	call	_memset
	add	esp, 24					; 00000018H

; 2823 :     }

	mov	eax, edi
	pop	esi
	pop	ebp
	pop	edi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN2@insert:

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	sub	eax, ebx
	cmp	eax, ebp
	jb	$LN128@insert

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	esi, DWORD PTR [ebx+ebp]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, ecx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN47@insert

; 3770 :             return _Max;

	mov	esi, ecx
	jmp	SHORT $LN46@insert
$LN47@insert:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, edx
	shr	eax, 1
	sub	ecx, eax
	cmp	edx, ecx
	jbe	SHORT $LN48@insert

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN46@insert
$LN48@insert:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN46@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	mov	ecx, edi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	ecx, eax

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR [edi+20], esi
	lea	eax, DWORD PTR [ebx+ebp]
	mov	DWORD PTR __New_ptr$1$[esp+32], ecx
	mov	DWORD PTR [edi+16], eax

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	movsx	eax, BYTE PTR __Ch$[esp+28]
	mov	DWORD PTR tv603[esp+28], eax
	mov	eax, DWORD PTR __Off$[esp+28]
	sub	ebx, eax

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	push	eax
	lea	edx, DWORD PTR [ebx+1]
	mov	ebx, DWORD PTR __Old$1$[esp+36]
	mov	DWORD PTR tv594[esp+32], edx
	lea	esi, DWORD PTR [ecx+eax]
	mov	DWORD PTR tv595[esp+36], esi
	lea	edx, DWORD PTR [esi+ebp]
	mov	DWORD PTR tv593[esp+36], edx
	cmp	ebx, 16					; 00000010H
	jb	SHORT $LN25@insert

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR [edi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ecx
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebp
	push	DWORD PTR tv603[esp+44]
	push	DWORD PTR tv595[esp+52]
	call	_memset

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv594[esp+52]

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	eax, DWORD PTR __Off$[esp+56]
	add	eax, esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	mov	eax, DWORD PTR tv593[esp+64]
	push	eax
	call	_memcpy

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	inc	ebx

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 36					; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebx, 4096				; 00001000H
	jb	SHORT $LN102@insert

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [esi-4]
	add	ebx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN99@insert

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, ecx
$LN102@insert:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ebx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2815 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2815 :         return _Reallocate_grow_by(_Count,

	mov	DWORD PTR [edi], eax

; 2823 :     }

	mov	eax, edi
	pop	esi
	pop	ebp
	pop	edi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN25@insert:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ecx
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebp
	push	DWORD PTR tv603[esp+44]
	push	esi
	call	_memset

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv594[esp+52]

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	eax, DWORD PTR __Off$[esp+56]
	add	eax, edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	lea	eax, DWORD PTR [esi+ebp]
	push	eax
	call	_memcpy

; 2815 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+68]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 36					; 00000024H

; 2815 :         return _Reallocate_grow_by(_Count,

	mov	DWORD PTR [edi], eax

; 2823 :     }

	mov	eax, edi
	pop	esi
	pop	ebp
	pop	edi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN127@insert:

; 2037 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN128@insert:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN129@insert:
$LN99@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN130@insert:
$LN124@insert:
	int	3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__New_ptr$1$ = 8					; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2707 :     basic_string& assign(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // assign _Count * _Ch

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 2708 :         auto& _My_data = _Get_data();
; 2709 :         if (_Count <= _My_data._Myres) {

	mov	edi, DWORD PTR __Count$[esp+12]
	mov	ebp, DWORD PTR [esi+20]
	cmp	edi, ebp
	ja	SHORT $LN2@assign

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	ebx, esi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	ebp, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	ebx, DWORD PTR [esi]
$LN9@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+12]
	push	edi
	push	eax
	push	ebx

; 2710 :             _Elem* const _Old_ptr = _My_data._Myptr();
; 2711 :             _My_data._Mysize      = _Count;

	mov	DWORD PTR [esi+16], edi

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ebx+edi], 0

; 2718 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
; 2719 :                 _Traits::assign(_New_ptr, _Count, _Ch);
; 2720 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2721 :             },
; 2722 :             _Ch);
; 2723 :     }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN2@assign:

; 3785 :         if (_New_size > max_size()) {

	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN110@assign

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	ebx, edi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN43@assign

; 3770 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN43@assign:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, ebp
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	ebp, eax
	jbe	SHORT $LN44@assign

; 3775 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN44@assign:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	ebx, eax
	cmovb	ebx, eax
$LN42@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Ch$[esp+12]
	push	edi
	push	ecx
	push	eax

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	DWORD PTR __New_ptr$1$[esp+24], eax

; 3794 :         _My_data._Orphan_all();
; 3795 :         _My_data._Mysize = _New_size;

	mov	DWORD PTR [esi+16], edi

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR [esi+20], ebx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	call	_memset

; 343  :         _Left = _Right;

	mov	ebx, DWORD PTR __New_ptr$1$[esp+24]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ebx+edi], 0

; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN21@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebp, 4096				; 00001000H
	jb	SHORT $LN94@assign

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	ebp, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN91@assign

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN94@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ebp
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN21@assign:
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2717 :         return _Reallocate_for(_Count,

	mov	DWORD PTR [esi], ebx

; 2718 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
; 2719 :                 _Traits::assign(_New_ptr, _Count, _Ch);
; 2720 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2721 :             },
; 2722 :             _Ch);
; 2723 :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN91@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN110@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN107@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 301  :         return __builtin_strlen(_First);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	mov	eax, edx

; 2703 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) { // assign [_Ptr, <null>)

	push	esi
	push	edi
	mov	esi, ecx

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [eax+1]
	npad	3
$LL7@assign:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL7@assign
	sub	eax, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 2705 :     }

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__New_ptr$1$ = 12					; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2684 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 2685 :         // assign [_Ptr, _Ptr + _Count)
; 2686 :         auto& _My_data = _Get_data();
; 2687 :         if (_Count <= _My_data._Myres) {

	mov	edi, DWORD PTR __Count$[esp+12]
	mov	ebp, DWORD PTR [esi+20]
	cmp	edi, ebp
	ja	SHORT $LN2@assign

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	ebx, esi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	ebp, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	ebx, DWORD PTR [esi]
$LN9@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	edi
	push	DWORD PTR __Ptr$[esp+16]

; 2688 :             _Elem* const _Old_ptr = _My_data._Myptr();
; 2689 :             _My_data._Mysize      = _Count;

	mov	DWORD PTR [esi+16], edi

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ebx+edi], 0

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2697 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2698 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2699 :             },
; 2700 :             _Ptr);
; 2701 :     }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN2@assign:

; 3785 :         if (_New_size > max_size()) {

	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN110@assign

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	ebx, edi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN43@assign

; 3770 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN43@assign:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, ebp
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	ebp, eax
	jbe	SHORT $LN44@assign

; 3775 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN44@assign:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	ebx, eax
	cmovb	ebx, eax
$LN42@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	DWORD PTR __Ptr$[esp+16]

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	DWORD PTR __New_ptr$1$[esp+20], eax

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax

; 3795 :         _My_data._Mysize = _New_size;

	mov	DWORD PTR [esi+16], edi

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR [esi+20], ebx

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	call	_memcpy

; 343  :         _Left = _Right;

	mov	ebx, DWORD PTR __New_ptr$1$[esp+24]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ebx+edi], 0

; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN21@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebp, 4096				; 00001000H
	jb	SHORT $LN94@assign

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	ebp, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN91@assign

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN94@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ebp
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN21@assign:
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2695 :         return _Reallocate_for(_Count,

	mov	DWORD PTR [esi], ebx

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2697 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2698 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2699 :             },
; 2700 :             _Ptr);
; 2701 :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN91@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN110@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN107@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Old$1$ = -12						; size = 4
tv579 = -8						; size = 4
__New_ptr$1$ = -4					; size = 4
tv580 = 8						; size = 4
__Count$ = 8						; size = 4
tv589 = 12						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2630 :     basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // append _Count * _Ch

	sub	esp, 12					; 0000000cH
	push	ebx

; 2631 :         auto& _My_data            = _Get_data();
; 2632 :         const size_type _Old_size = _My_data._Mysize;
; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	ebx, DWORD PTR __Count$[esp+12]
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+20]
	mov	eax, ecx
	mov	ebp, DWORD PTR [edi+16]
	sub	eax, ebp
	mov	DWORD PTR __Old$1$[esp+28], ecx
	cmp	ebx, eax
	ja	SHORT $LN2@append

; 2634 :             _My_data._Mysize      = _Old_size + _Count;

	lea	eax, DWORD PTR [ebx+ebp]
	mov	DWORD PTR [edi+16], eax

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	eax, edi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	eax, DWORD PTR [edi]
$LN9@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2636 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	esi, DWORD PTR [eax+ebp]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+24]
	push	ebx
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0

; 2649 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN2@append:

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, 2147483647				; 7fffffffH
	mov	eax, edx
	sub	eax, ebp
	cmp	eax, ebx
	jb	$LN122@append

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	esi, DWORD PTR [ebx+ebp]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, edx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN43@append

; 3770 :             return _Max;

	mov	esi, edx
	jmp	SHORT $LN42@append
$LN43@append:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, ecx
	shr	eax, 1
	sub	edx, eax
	cmp	ecx, edx
	jbe	SHORT $LN44@append

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@append
$LN44@append:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN42@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	mov	ecx, edi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;
; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[esp+28], 16		; 00000010H
	lea	ecx, DWORD PTR [ebx+ebp]
	mov	DWORD PTR [edi+16], ecx
	movsx	ecx, BYTE PTR __Ch$[esp+24]
	mov	DWORD PTR [edi+20], esi
	lea	esi, DWORD PTR [eax+ebp]
	mov	DWORD PTR tv589[esp+24], ecx
	lea	ecx, DWORD PTR [esi+ebx]
	mov	DWORD PTR __New_ptr$1$[esp+28], eax
	mov	DWORD PTR tv580[esp+24], esi
	mov	DWORD PTR tv579[esp+28], ecx
	push	ebp
	jb	SHORT $LN21@append

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR [edi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	DWORD PTR tv589[esp+40]
	push	DWORD PTR tv580[esp+44]
	call	_memset

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv579[esp+52]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 24					; 00000018H

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[esp+28]
	inc	ecx

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN98@append

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN95@append

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN98@append:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2641 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2641 :         return _Reallocate_grow_by(_Count,

	mov	DWORD PTR [edi], eax

; 2649 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN21@append:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	DWORD PTR tv589[esp+40]
	push	esi
	call	_memset

; 343  :         _Left = _Right;

	lea	eax, DWORD PTR [esi+ebx]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 2641 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+28]
	mov	DWORD PTR [edi], eax

; 2649 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN122@append:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN95@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN119@append:
	int	3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 301  :         return __builtin_strlen(_First);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	mov	eax, edx

; 2626 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	esi
	push	edi
	mov	esi, ecx

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [eax+1]
	npad	3
$LL7@append:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL7@append
	sub	eax, edi

; 2627 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	edi
	pop	esi

; 2628 :     }

	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -12						; size = 4
tv540 = -8						; size = 4
__New_ptr$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
tv541 = 12						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2604 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	sub	esp, 12					; 0000000cH
	push	ebx

; 2605 :         // append [_Ptr, _Ptr + _Count)
; 2606 :         auto& _My_data            = _Get_data();
; 2607 :         const size_type _Old_size = _My_data._Mysize;
; 2608 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	ebx, DWORD PTR __Count$[esp+12]
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+20]
	mov	eax, ecx
	mov	ebp, DWORD PTR [edi+16]
	sub	eax, ebp
	mov	DWORD PTR __Old$1$[esp+28], ecx
	cmp	ebx, eax
	ja	SHORT $LN2@append

; 2609 :             _My_data._Mysize      = _Old_size + _Count;

	lea	eax, DWORD PTR [ebx+ebp]
	mov	DWORD PTR [edi+16], eax

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	eax, edi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	eax, DWORD PTR [edi]
$LN9@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	ebx
	push	DWORD PTR __Ptr$[esp+28]

; 2610 :             _Elem* const _Old_ptr = _My_data._Myptr();
; 2611 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	esi, DWORD PTR [eax+ebp]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0

; 2624 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN2@append:

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, 2147483647				; 7fffffffH
	mov	eax, edx
	sub	eax, ebp
	cmp	eax, ebx
	jb	$LN122@append

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	esi, DWORD PTR [ebx+ebp]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, edx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN43@append

; 3770 :             return _Max;

	mov	esi, edx
	jmp	SHORT $LN42@append
$LN43@append:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, ecx
	shr	eax, 1
	sub	edx, eax
	cmp	ecx, edx
	jbe	SHORT $LN44@append

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@append
$LN44@append:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN42@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	mov	ecx, edi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;
; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[esp+28], 16		; 00000010H
	lea	ecx, DWORD PTR [ebx+ebp]
	mov	DWORD PTR [edi+20], esi
	mov	DWORD PTR [edi+16], ecx
	lea	esi, DWORD PTR [eax+ebp]
	mov	DWORD PTR __New_ptr$1$[esp+28], eax
	lea	ecx, DWORD PTR [esi+ebx]
	mov	DWORD PTR tv541[esp+24], esi
	mov	DWORD PTR tv540[esp+28], ecx
	push	ebp
	jb	SHORT $LN21@append

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR [edi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	eax
	call	_memcpy
	push	ebx
	push	DWORD PTR __Ptr$[esp+40]
	push	DWORD PTR tv541[esp+44]
	call	_memcpy

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv540[esp+52]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[esp+28]
	inc	ecx

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN98@append

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN95@append

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN98@append:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2616 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2616 :         return _Reallocate_grow_by(_Count,

	mov	DWORD PTR [edi], eax

; 2624 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN21@append:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	eax
	call	_memcpy
	push	ebx
	push	DWORD PTR __Ptr$[esp+40]
	push	esi
	call	_memcpy

; 343  :         _Left = _Right;

	lea	eax, DWORD PTR [esi+ebx]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 2616 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+28]
	mov	DWORD PTR [edi], eax

; 2624 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN122@append:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN95@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN119@append:
	int	3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	mov	eax, DWORD PTR __Right$[esp-4]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	mov	edx, DWORD PTR [eax+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	eax, DWORD PTR [eax]
$LN8@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	push	edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2579 :     }

	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2497 :     ~basic_string() noexcept { // destroy the string

	push	esi
	mov	esi, ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN43@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN42@basic_stri

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN39@basic_stri

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN42@basic_stri:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN43@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi

; 2503 :     }

	ret	0
$LN39@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN55@basic_stri:
	int	3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2434 :     void _Construct_lv_contents(const basic_string& _Right) {

	push	ebx
	push	ebp
	push	edi

; 2435 :         // assign by copying data stored in _Right
; 2436 :         // pre: this != &_Right
; 2437 :         // pre: *this owns no memory, iterators orphaned (note:
; 2438 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2439 :         auto& _My_data                = _Get_data();
; 2440 :         auto& _Right_data             = _Right._Get_data();
; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	edi, DWORD PTR __Right$[esp+8]
	mov	ebx, ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2435 :         // assign by copying data stored in _Right
; 2436 :         // pre: this != &_Right
; 2437 :         // pre: *this owns no memory, iterators orphaned (note:
; 2438 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2439 :         auto& _My_data                = _Get_data();
; 2440 :         auto& _Right_data             = _Right._Get_data();
; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	ebp, DWORD PTR [edi+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN13@Construct_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edi, DWORD PTR [edi]
$LN13@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2443 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	ebp, 16					; 00000010H
	jae	SHORT $LN2@Construct_

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	xmm0, XMMWORD PTR [edi]
	pop	edi
	movups	XMMWORD PTR [ebx], xmm0

; 2455 :         _My_data._Mysize = _Right_size;
; 2456 :         _My_data._Myres  = _New_capacity;
; 2457 :     }

	mov	DWORD PTR [ebx+16], ebp
	pop	ebp
	mov	DWORD PTR [ebx+20], 15			; 0000000fH
	pop	ebx
	ret	4
$LN2@Construct_:
	push	esi

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	esi, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	eax, 2147483647				; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	or	esi, 15					; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	esi, eax
	cmova	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 2453 :         _Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_array);
; 2454 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	ecx, DWORD PTR [ebp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [ebx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ecx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2455 :         _My_data._Mysize = _Right_size;
; 2456 :         _My_data._Myres  = _New_capacity;
; 2457 :     }

	mov	DWORD PTR [ebx+16], ebp
	mov	DWORD PTR [ebx+20], esi
	pop	esi
	pop	edi
	pop	ebp
	pop	ebx
	ret	4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 2390 :         // assign by stealing _Right's buffer, memcpy optimization
; 2391 :         // pre: this != &_Right
; 2392 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is
; 2393 :         // complete pre: *this owns no memory, iterators orphaned (note:
; 2394 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2395 :         auto& _Right_data = _Right._Get_data();
; 2396 : 
; 2397 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2398 :         if (_Right_data._Large_string_engaged()) { // take ownership of _Right's iterators along with its buffer
; 2399 :             _Swap_proxy_and_iterators(_Right);
; 2400 :         } else {
; 2401 :             _Right._Orphan_all();
; 2402 :         }
; 2403 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2404 : 
; 2405 :         const auto _My_data_mem = reinterpret_cast<unsigned char*>(_STD addressof(_Get_data())) + _Memcpy_move_offset;
; 2406 :         const auto _Right_data_mem =
; 2407 :             reinterpret_cast<unsigned char*>(_STD addressof(_Right_data)) + _Memcpy_move_offset;
; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[esp-4]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 2409 :         _Right._Tidy_init();
; 2410 :     }

	ret	8
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2384 :         _NOEXCEPT_COND(noexcept(*this = _STD move(_Right))) { // assign by moving _Right

	push	esi
	push	edi

; 2376 :         if (this != _STD addressof(_Right)) {

	mov	edi, DWORD PTR __Right$[esp+4]

; 2384 :         _NOEXCEPT_COND(noexcept(*this = _STD move(_Right))) { // assign by moving _Right

	mov	esi, ecx

; 2376 :         if (this != _STD addressof(_Right)) {

	cmp	esi, edi
	je	SHORT $LN57@assign

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN52@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN51@assign

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN48@assign

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN51@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN52@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edi+16]
	movq	QWORD PTR [esi+16], xmm0

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi], 0
$LN57@assign:
	pop	edi

; 2385 :         *this = _STD move(_Right);
; 2386 :         return *this;

	mov	eax, esi

; 2387 :     }

	pop	esi
	ret	4
$LN48@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN94@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2375 :         _NOEXCEPT_COND(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {

	push	esi
	push	edi

; 2376 :         if (this != _STD addressof(_Right)) {

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN53@operator

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN48@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN47@operator

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN44@operator

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN47@operator:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN48@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edi+16]
	movq	QWORD PTR [esi+16], xmm0

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi], 0
$LN53@operator:
	pop	edi

; 2377 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});
; 2378 :         }
; 2379 : 
; 2380 :         return *this;

	mov	eax, esi

; 2381 :     }

	pop	esi
	ret	4
$LN44@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN89@operator:
	int	3
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign, COMDAT
; _this$ = ecx

; 2345 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {

	push	esi
	mov	esi, ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN43@Move_assig
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN42@Move_assig

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN39@Move_assig

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN42@Move_assig:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN43@Move_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[esp]

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [esi+16], xmm0

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
	pop	esi

; 2349 :     }

	ret	8
$LN39@Move_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN83@Move_assig:
	int	3
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[esp-4]

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 2297 :         : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) { // construct by moving _Right
; 2298 :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2299 :         _Take_contents(_Right, _Use_memcpy_move{});
; 2300 :     }

	mov	eax, ecx
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2231 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)

	push	ebx

; 2709 :         if (_Count <= _My_data._Myres) {

	mov	ebx, DWORD PTR __Count$[esp]

; 2231 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)

	push	edi
	mov	edi, ecx

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi], 0

; 2709 :         if (_Count <= _My_data._Myres) {

	cmp	ebx, 15					; 0000000fH
	ja	SHORT $LN24@basic_stri

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+4]
	push	ebx
	push	eax
	push	edi

; 2711 :             _My_data._Mysize      = _Count;

	mov	DWORD PTR [edi+16], ebx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ebx+edi], 0

; 2238 :     }

	mov	eax, edi
	pop	edi
	pop	ebx
	ret	8
$LN24@basic_stri:

; 3785 :         if (_New_size > max_size()) {

	cmp	ebx, 2147483647				; 7fffffffH
	ja	SHORT $LN134@basic_stri
	push	ebp

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	ebp, ebx
	or	ebp, 15					; 0000000fH
	push	esi
	cmp	ebp, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN65@basic_stri

; 3770 :             return _Max;

	mov	ebp, 2147483647				; 7fffffffH
	jmp	SHORT $LN64@basic_stri
$LN65@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	eax, 22					; 00000016H
	cmp	ebp, eax
	cmovb	ebp, eax
$LN64@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ebp+1]
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Ch$[esp+12]

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	esi, eax

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	ecx
	push	esi

; 3795 :         _My_data._Mysize = _New_size;

	mov	DWORD PTR [edi+16], ebx

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR [edi+20], ebp

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [edi], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2238 :     }

	mov	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	pop	esi
	pop	ebp
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2238 :     }

	pop	ebx
	ret	8
$LN134@basic_stri:

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN132@basic_stri:
	int	3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 301  :         return __builtin_strlen(_First);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	mov	eax, edx

; 2210 :     basic_string(_In_z_ const _Elem* const _Ptr)

	push	esi
	mov	esi, ecx
	push	edi

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [eax+1]

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	npad	2
$LL31@basic_stri:

; 301  :         return __builtin_strlen(_First);

	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL31@basic_stri
	sub	eax, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2211 :         : _Mypair(_Zero_then_variadic_args_t()) { // construct from [_Ptr, <null>)
; 2212 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2213 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 2214 :         _Tidy_init();
; 2215 :         assign(_Ptr);
; 2216 :         _Proxy._Release();
; 2217 :     }

	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 2161 :         : _Mypair(_Zero_then_variadic_args_t()) { // construct empty string
; 2162 :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2163 :         _Tidy_init();
; 2164 :     }

	mov	eax, ecx

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ecx], 0

; 2161 :         : _Mypair(_Zero_then_variadic_args_t()) { // construct empty string
; 2162 :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2163 :         _Tidy_init();
; 2164 :     }

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2145 :               _Alty_traits::select_on_container_copy_construction(_Right._Getal())) { // construct by copying _Right

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	edi, DWORD PTR __Right$[esp+12]

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	ebp, DWORD PTR [edi+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN33@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edi, DWORD PTR [edi]
$LN33@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2443 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	ebp, 16					; 00000010H
	jae	SHORT $LN22@basic_stri

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	xmm0, XMMWORD PTR [edi]

; 2446 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	ebx, 15					; 0000000fH

; 2146 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2147 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 2148 :         _Construct_lv_contents(_Right);
; 2149 :         _Proxy._Release();
; 2150 :     }

	mov	eax, esi
	pop	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	XMMWORD PTR [esi], xmm0

; 2146 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2147 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 2148 :         _Construct_lv_contents(_Right);
; 2149 :         _Proxy._Release();
; 2150 :     }

	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebx
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN22@basic_stri:

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	ebx, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	eax, 2147483647				; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	or	ebx, 15					; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	ebx, eax
	cmova	ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ebx+1]
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 2453 :         _Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_array);
; 2454 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	ecx, DWORD PTR [ebp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [esi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ecx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2146 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2147 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 2148 :         _Construct_lv_contents(_Right);
; 2149 :         _Proxy._Release();
; 2150 :     }

	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebx
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2061 :         }

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2058 :         }

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2048 :         _Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN3@Xran:
	int	3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2036 :         if (_Mysize < _Off) {

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[esp-4]
	jb	SHORT $LN6@Check_offs

; 2038 :         }
; 2039 :     }

	ret	4
$LN6@Check_offs:

; 2037 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN4@Check_offs:
	int	3
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	setae	al

; 2033 :     }

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;
; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Myptr

; 2025 :             _Result = _Unfancy(_Bx._Ptr);
; 2026 :         }
; 2027 : 
; 2028 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2029 :     }

	ret	0
$LN8@Myptr:

; 2025 :             _Result = _Unfancy(_Bx._Ptr);
; 2026 :         }
; 2027 : 
; 2028 :         return _Result;

	mov	eax, ecx

; 2029 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;
; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Myptr

; 2016 :             _Result = _Unfancy(_Bx._Ptr);
; 2017 :         }
; 2018 : 
; 2019 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2020 :     }

	ret	0
$LN8@Myptr:

; 2016 :             _Result = _Unfancy(_Bx._Ptr);
; 2017 :         }
; 2018 : 
; 2019 :         return _Result;

	mov	eax, ecx

; 2020 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+16], 0

; 2003 :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 832  :         return _Al;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 833  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 828  :         return static_cast<size_t>(-1) / sizeof(value_type);

	or	eax, -1

; 829  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	ecx, DWORD PTR __Count$[esp-4]
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 93   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN15@allocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN6@allocate:

; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN7@allocate

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN7@allocate:

; 182  :     return nullptr;

	xor	eax, eax

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN15@allocate:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	__invalid_parameter_noinfo_noreturn
$LN26@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 924  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	eax, DWORD PTR __Ptr$[esp-4]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 926  :     }

	ret	8
$LN12@deallocate:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 916  :     }

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 374  :         return EOF;

	or	eax, -1

; 375  :     }

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 366  :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 367  :     }

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 361  :         return static_cast<unsigned char>(_Ch);

	mov	eax, DWORD PTR __Ch$[esp-4]
	movzx	eax, BYTE PTR [eax]

; 362  :     }

	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[esp-4]
	mov	BYTE PTR [eax], cl

; 344  :     }

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$char_traits@D@std@@SAPADQADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADQADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 338  :         // assign _Count * _Ch to [_First, ...)
; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR __Count$[esp-4]
	movsx	eax, BYTE PTR __Ch$[esp]
	push	eax
	push	DWORD PTR __First$[esp+4]
	call	_memset
	add	esp, 12					; 0000000cH

; 340  :     }

	ret	0
?assign@?$char_traits@D@std@@SAPADQADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 332  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	jmp	_memmove
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 309  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	jmp	_memcpy
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 299  :         // find length of null-terminated string
; 300  : #if _HAS_CXX17
; 301  :         return __builtin_strlen(_First);

	mov	eax, DWORD PTR __First$[esp-4]
	lea	edx, DWORD PTR [eax+1]
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 302  : #else // _HAS_CXX17
; 303  :         return _CSTD strlen(_First);
; 304  : #endif // _HAS_CXX17
; 305  :     }

	ret	0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ
_TEXT	SEGMENT
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ PROC		; std::_Fake_proxy_ptr_impl::_Release, COMDAT
; _this$ = ecx

; 1451 :     void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ENDP		; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT
; _this$ = ecx

; 1448 :     _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	eax, ecx
	ret	8
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 1251 :         return nullptr;

	xor	eax, eax

; 1252 :     }

	ret	0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 1248 :     }

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1240 :     }

	ret	4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 1234 :     }

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 1136 :     return _Len;

	mov	eax, DWORD PTR __Len$[esp-4]

; 1137 : }

	ret	0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 107  :     _Bytes += _Non_user_size;

	mov	eax, DWORD PTR __Bytes$[esp-4]

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	add	DWORD PTR [eax], 35			; 00000023H
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax-4]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN7@Adjust_man

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	DWORD PTR [ecx], edx

; 126  : }

	ret	0
$LN7@Adjust_man:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	jmp	__invalid_parameter_noinfo_noreturn
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 49   :         return ::operator new(_Bytes);

	jmp	??2@YAPAXI@Z				; operator new
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 37   :     return _Count;

	mov	eax, DWORD PTR __Count$[esp-4]

; 38   : }

	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 508  :         return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH

; 509  :     }

	ret	0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 91   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
	test	ecx, ecx
	cmovne	eax, ecx

; 92   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx

; 87   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 68   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR __Other$[esp+4]
	add	eax, 4
	push	eax
	call	___std_exception_copy
	add	esp, 8

; 70   :     }

	mov	eax, esi
	pop	esi
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 63   :         _Data._What = _Message;

	mov	eax, DWORD PTR __Message$[esp-4]
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [ecx+4], xmm0
	mov	DWORD PTR [ecx+4], eax

; 64   :     }

	mov	eax, ecx
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -8					; size = 8
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 55   :     {

	sub	esp, 8

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[esp+4]
	xorps	xmm0, xmm0
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __InitData$[esp+12], eax
	lea	edx, DWORD PTR [esi+4]
	mov	BYTE PTR __InitData$[esp+16], 1

; 57   :         __std_exception_copy(&_InitData, &_Data);

	push	edx
	lea	eax, DWORD PTR __InitData$[esp+16]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	call	___std_exception_copy
	add	esp, 8

; 58   :     }

	mov	eax, esi
	pop	esi
	add	esp, 8
	ret	4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ?_Fnv1a_append_bytes@std@@YAIIQBEI@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__First$ = 12						; size = 4
__Count$ = 16						; size = 4
?_Fnv1a_append_bytes@std@@YAIIQBEI@Z PROC		; std::_Fnv1a_append_bytes, COMDAT

; 1934 :     const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val

	push	esi

; 1935 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	esi, DWORD PTR __Count$[esp]
	xor	ecx, ecx
	test	esi, esi
	je	SHORT $LN12@Fnv1a_appe
	mov	edx, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
$LL8@Fnv1a_appe:

; 1936 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	movzx	eax, BYTE PTR [ecx+edi]
	inc	ecx
	xor	eax, edx

; 1937 :         _Val *= _FNV_prime;

	imul	edx, eax, 16777619
	cmp	ecx, esi
	jb	SHORT $LL8@Fnv1a_appe

; 1938 :     }
; 1939 : 
; 1940 :     return _Val;

	pop	edi
	mov	eax, edx
	pop	esi

; 1941 : }

	ret	0
$LN12@Fnv1a_appe:

; 1938 :     }
; 1939 : 
; 1940 :     return _Val;

	mov	eax, DWORD PTR __Val$[esp]
	pop	esi

; 1941 : }

	ret	0
?_Fnv1a_append_bytes@std@@YAIIQBEI@Z ENDP		; std::_Fnv1a_append_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1498 :         int const _Result = __stdio_common_vsprintf_s(

	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	0
	push	DWORD PTR __Format$[esp+4]
	push	DWORD PTR __BufferCount$[esp+8]
	push	DWORD PTR __Buffer$[esp+12]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	___stdio_common_vsprintf_s

; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1842 :             int _Result;
; 1843 :             va_list _ArgList;
; 1844 :             __crt_va_start(_ArgList, _Format);
; 1845 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1846 :             __crt_va_end(_ArgList);
; 1847 :             return _Result;
; 1848 :         }

	ret	0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1498 :         int const _Result = __stdio_common_vsprintf_s(

	push	DWORD PTR __ArgList$[esp-4]
	push	DWORD PTR __Locale$[esp]
	push	DWORD PTR __Format$[esp+4]
	push	DWORD PTR __BufferCount$[esp+8]
	push	DWORD PTR __Buffer$[esp+12]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	___stdio_common_vsprintf_s

; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1503 :     }

	ret	0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _frexpl
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 4
_frexpl	PROC						; COMDAT

; 864  :         return frexp((double)_X, _Y);

	push	DWORD PTR __Y$[esp-4]
	movsd	xmm0, QWORD PTR __X$[esp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_frexp
	add	esp, 12					; 0000000cH

; 865  :     }

	ret	0
_frexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _fabsl
_TEXT	SEGMENT
tv68 = -8						; size = 8
__X$ = 8						; size = 8
_fabsl	PROC						; COMDAT

; 842  :     {

	sub	esp, 8

; 843  :         return fabs((double)_X);

	movsd	xmm0, QWORD PTR __X$[esp+4]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movsd	QWORD PTR tv68[esp+8], xmm0
	fld	QWORD PTR tv68[esp+8]

; 844  :     }

	add	esp, 8
	ret	0
_fabsl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _ceilf
_TEXT	SEGMENT
tv69 = -8						; size = 8
tv75 = 8						; size = 4
__X$ = 8						; size = 4
_ceilf	PROC						; COMDAT

; 643  :         {

	sub	esp, 8
	movss	xmm0, DWORD PTR __X$[esp+4]

; 644  :             return (float)ceil(_X);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv69[esp+16], xmm0
	fld	QWORD PTR tv69[esp+16]
	fstp	QWORD PTR [esp]
	call	_ceil
	fstp	DWORD PTR tv75[esp+12]
	fld	DWORD PTR tv75[esp+12]

; 645  :         }

	add	esp, 16					; 00000010H
	ret	0
_ceilf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 169  :         (void)_Size;
; 170  :         return _Where;

	mov	eax, DWORD PTR __Where$[esp-4]

; 171  :     }

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
