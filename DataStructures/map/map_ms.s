; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27508.1 

	TITLE	C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	_fabsl
PUBLIC	_frexpl
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsprintf_s_l
PUBLIC	_sprintf_s
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0?$tuple@$$V@std@@QAE@XZ			; std::tuple<>::tuple<>
PUBLIC	??0?$tuple@$$V@std@@QAE@ABV01@@Z		; std::tuple<>::tuple<>
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAPADQADID@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Orphan_all@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Orphan_all
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data
PUBLIC	?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8std@@YA_NABVerror_condition@0@0@Z		; std::operator==
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??1_System_error@std@@UAE@XZ			; std::_System_error::~_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??0_Facet_base@std@@QAE@XZ			; std::_Facet_base::_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
PUBLIC	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ	; std::_Locinfo::_Getlconv
PUBLIC	?_Getfalse@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Getfalse
PUBLIC	?_Gettrue@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Gettrue
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
PUBLIC	??0?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::_Yarn<wchar_t>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	?_Tidy@?$_Yarn@_W@std@@AAEXXZ			; std::_Yarn<wchar_t>::_Tidy
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?c_str@locale@std@@QBEPBDXZ			; std::locale::c_str
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z	; std::_Adl_verify_range<char const *,char const *>
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?widen@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::widen
PUBLIC	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z		; std::ctype<char>::widen
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	?precision@ios_base@std@@QBE_JXZ		; std::ios_base::precision
PUBLIC	?width@ios_base@std@@QBE_JXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QAE_J_J@Z			; std::ios_base::width
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
PUBLIC	?map_access@@YAXABV?$vector@HV?$allocator@H@std@@@std@@PAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@2@@Z ; map_access
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	?deallocate@?$allocator@H@std@@QAEXQAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@IABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QBEPBHXZ ; std::vector<int,std::allocator<int> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QBEPBHXZ ; std::vector<int,std::allocator<int> >::_Unchecked_end
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?_Has_unused_capacity@?$vector@HV?$allocator@H@std@@@std@@ABE_NXZ ; std::vector<int,std::allocator<int> >::_Has_unused_capacity
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAHIU_Value_init_tag@2@@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	?_Umove@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ; std::vector<int,std::allocator<int> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero
PUBLIC	?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range
PUBLIC	?_Orphan_all@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Orphan_all
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Get_data@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::_Get_data
PUBLIC	?_Get_data@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::_Get_data
PUBLIC	?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ; std::vector<int,std::allocator<int> >::_Myfirst
PUBLIC	?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ; std::vector<int,std::allocator<int> >::_Myfirst
PUBLIC	?_Mylast@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ; std::vector<int,std::allocator<int> >::_Mylast
PUBLIC	?_Mylast@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ; std::vector<int,std::allocator<int> >::_Mylast
PUBLIC	?_Myend@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ; std::vector<int,std::allocator<int> >::_Myend
PUBLIC	?_Myend@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ; std::vector<int,std::allocator<int> >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::max_size
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound
PUBLIC	?_Destroy_if_node@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Destroy_if_node
PUBLIC	?_Compare@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBE_NABH0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Compare
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getcomp
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getcomp
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getal
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getal
PUBLIC	?_Get_data@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Get_data
PUBLIC	?_Get_data@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Get_data
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Min
PUBLIC	?_Root@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Root
PUBLIC	?_Lmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Lmost
PUBLIC	?_Rmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Rmost
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Rrotate
PUBLIC	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Extract
PUBLIC	?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Orphan_ptr
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_second
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_second
PUBLIC	??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
PUBLIC	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
PUBLIC	?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
PUBLIC	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
PUBLIC	?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
PUBLIC	?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
PUBLIC	??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
PUBLIC	?min@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::min
PUBLIC	?max@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::max
PUBLIC	??0?$uniform_int@H@std@@QAE@HH@Z		; std::uniform_int<int>::uniform_int<int>
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAII@Z		; std::uniform_int<int>::_Adjust
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ; std::uniform_int<int>::_Adjust
PUBLIC	??0param_type@?$uniform_int@H@std@@QAE@HH@Z	; std::uniform_int<int>::param_type::param_type
PUBLIC	?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z	; std::uniform_int<int>::param_type::_Init
PUBLIC	??0?$uniform_int_distribution@H@std@@QAE@HH@Z	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
PUBLIC	??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@QBEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ; std::uniform_int<int>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator--
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator*
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator!=
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator*
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator->
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--
PUBLIC	??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@X@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V21@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,void>
PUBLIC	?time@@YAXP6AXABV?$vector@HV?$allocator@H@std@@@std@@PAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@2@@Z01@Z ; time
PUBLIC	??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,1000000000>,void>
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	_main
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
PUBLIC	??$try_emplace@$$V@?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@ABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::try_emplace<>
PUBLIC	??$move@AAH@std@@YA$$QAHAAH@Z			; std::move<int &>
PUBLIC	??$emplace_back@H@?$vector@HV?$allocator@H@std@@@std@@QAEAAH$$QAH@Z ; std::vector<int,std::allocator<int> >::emplace_back<int>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int>
PUBLIC	??$_Unfancy@H@std@@YAPAHPAH@Z			; std::_Unfancy<int>
PUBLIC	??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
PUBLIC	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
PUBLIC	??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
PUBLIC	??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?decimal_point@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::decimal_point
PUBLIC	?thousands_sep@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::thousands_sep
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z	; std::numpunct<char>::numpunct<char>
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z	; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBHH@std@@@std@@SAPAU?$pair@$$CBHH@2@AAU32@@Z ; std::pointer_traits<std::pair<int const ,int> *>::pointer_to
PUBLIC	??$_Lbound@H@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound<int>
PUBLIC	??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
PUBLIC	??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
PUBLIC	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ; std::addressof<std::pair<int const ,int> >
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<int const ,int>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
PUBLIC	??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter
PUBLIC	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
PUBLIC	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@ABEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@HH@Z ; std::uniform_int<int>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<int const ,int>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<int const ,int>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
PUBLIC	??$_Try_emplace@ABH$$V@?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@ABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::_Try_emplace<int const &>
PUBLIC	??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
PUBLIC	??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z ; std::forward<std::less<int> const &>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1><>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<int const ,int>,void *> *>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU31@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>
PUBLIC	??$_Get_size_of_n@$0BI@@std@@YAII@Z		; std::_Get_size_of_n<24>
PUBLIC	??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
PUBLIC	??$_Uninitialized_value_construct_n@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@@Z ; std::_Uninitialized_value_construct_n<int *,unsigned int,std::allocator<int> >
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$swap@DX@std@@YAXAAD0@Z			; std::swap<char,void>
PUBLIC	??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ; std::numpunct<char>::_Getvals<char>
PUBLIC	??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>
PUBLIC	??0?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAE@AAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
PUBLIC	??R?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEII@Z ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::operator()
PUBLIC	?_Get_all_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_all_bits
PUBLIC	?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
PUBLIC	??$destroy@U?$pair@$$CBHH@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAU?$pair@$$CBHH@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::pair<int const ,int> >
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,int>,void *> *>
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z ; std::forward_as_tuple<int const &>
PUBLIC	??0?$tuple@ABH@std@@QAE@$$QAV01@@Z		; std::tuple<int const &>::tuple<int const &>
PUBLIC	??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ; std::forward_as_tuple<>
PUBLIC	??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool,0>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > &,bool,0>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,int>,void *> * &>
PUBLIC	??$_Get_unwrapped@H@std@@YAPAHQAH@Z		; std::_Get_unwrapped<int>
PUBLIC	??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z	; std::_Idl_distance<int *,int *>
PUBLIC	??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z	; std::_Get_unwrapped_n<int,int,0>
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z		; std::_Seek_wrapped<int>
PUBLIC	??$_Uninitialized_value_construct_n1@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<int *,unsigned int,std::allocator<int> >
PUBLIC	??$move@AAD@std@@YA$$QADAAD@Z			; std::move<char &>
PUBLIC	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z		; std::tuple<int const &>::tuple<int const &><int const &,0>
PUBLIC	??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z ; std::forward<std::piecewise_construct_t const &>
PUBLIC	??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ; std::forward<std::tuple<int const &> >
PUBLIC	??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_hint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > >
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > &>
PUBLIC	??$_Zero_range@PAH@std@@YAPAHQAH0@Z		; std::_Zero_range<int *>
PUBLIC	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$?0U_Exact_args_t@std@@ABH$$V$0A@@?$tuple@ABH@std@@QAE@U_Exact_args_t@1@ABH@Z ; std::tuple<int const &>::tuple<int const &><std::_Exact_args_t,int const &,0>
PUBLIC	??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_node<std::pair<int const ,int>,void *>::_Buynode<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$forward@AAU?$pair@$$CBHH@std@@@std@@YAAAU?$pair@$$CBHH@0@AAU10@@Z ; std::forward<std::pair<int const ,int> &>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_at<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_nohint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z	; std::_Tuple_val<int const &>::_Tuple_val<int const &><int const &>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
PUBLIC	??$construct@U?$pair@$$CBHH@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAU?$pair@$$CBHH@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::pair<int const ,int>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$_Buy_if_not_node@AAU?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PAU21@AAU?$pair@$$CBHH@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buy_if_not_node<std::pair<int const ,int> &>
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Tree_node<std::pair<int const ,int>,void *> *,std::nullptr_t>
PUBLIC	??$?0ABH$$Z$$V@?$pair@$$CBHH@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$V@1@@Z ; std::pair<int const ,int>::pair<int const ,int><int const &>
PUBLIC	??$?0V?$tuple@ABH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHH@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ; std::pair<int const ,int>::pair<int const ,int><std::tuple<int const &>,std::tuple<>,0>
PUBLIC	??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ; std::move<std::tuple<int const &> &>
PUBLIC	??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z	; std::get<0,int const &>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic@			; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error@	; `string'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@	; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@	; `string'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0O@IALHGEAH@?5milliseconds@		; `string'
PUBLIC	??_C@_0BH@KLJDGFCF@cold?5cache?5took?5time?3?5@	; `string'
PUBLIC	??_C@_0BH@BJIMNNC@warm?5cache?5took?5time?3?5@	; `string'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_C@_02BBAHNLBA@?$CFp@				; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu@				; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld@				; `string'
PUBLIC	??_C@_02BDDLJJBK@lu@				; `string'
PUBLIC	??_C@_02EAOCLKAK@ld@				; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	??_C@_02MDKMJEGG@eE@				; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP@				; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
PUBLIC	?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@4202a05f20000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	_frexp:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	_terminate:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	_strcspn:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xruntime_error@std@@YAXPBD@Z:PROC		; std::_Xruntime_error
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z:PROC ; std::_Execute_once
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	_localeconv:PROC
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	__Query_perf_counter:PROC
EXTRN	__Query_perf_frequency:PROC
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__alldvrm:PROC
EXTRN	__allmul:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cout
EXTRN	?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cerr
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA
_BSS	SEGMENT
?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA DD 01H DUP (?) ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
_BSS	ENDS
;	COMDAT ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A
_BSS	SEGMENT
?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A DQ 01H DUP (?) ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$r	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$r	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$r	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$r	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$r	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$r	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$r	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long@ DB 'map/set<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@ DB 'vector<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp@ DB '%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_C@_0BH@BJIMNNC@warm?5cache?5took?5time?3?5@
CONST	SEGMENT
??_C@_0BH@BJIMNNC@warm?5cache?5took?5time?3?5@ DB 'warm cache took time: '
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KLJDGFCF@cold?5cache?5took?5time?3?5@
CONST	SEGMENT
??_C@_0BH@KLJDGFCF@cold?5cache?5took?5time?3?5@ DB 'cold cache took time:'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IALHGEAH@?5milliseconds@
CONST	SEGMENT
??_C@_0O@IALHGEAH@?5milliseconds@ DB ' milliseconds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@ DB 'ios_base::failbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error@ DB 'iostream stream error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream@ DB 'iostream', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$0
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$2
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$0
__unwindtable$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$2
__ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z$0
__unwindtable$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z$2
__ehfuncinfo$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0
__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2
__ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$0
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$2
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$0
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$2
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z PROC	; std::get<0,int const &>, COMDAT

; 659  :     using _Ttype  = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 660  :     using _RRtype = tuple_element_t<_Index, tuple<_Types...>>&&;
; 661  :     return _STD forward<_RRtype>(((_Ttype&) _Tuple)._Myfirst._Val);

	mov	eax, DWORD PTR __Tuple$[esp-4]
	mov	eax, DWORD PTR [eax]

; 662  : }

	ret	0
??$get@$0A@ABH@std@@YAABH$$QAV?$tuple@ABH@0@@Z ENDP	; std::get<0,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z PROC ; std::move<std::tuple<int const &> &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAV?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ENDP ; std::move<std::tuple<int const &> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0V?$tuple@ABH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHH@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$?0V?$tuple@ABH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHH@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z PROC ; std::pair<int const ,int>::pair<int const ,int><std::tuple<int const &>,std::tuple<>,0>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples
; 895  : }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	16					; 00000010H
??$?0V?$tuple@ABH@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@$$CBHH@std@@QAE@AAV?$tuple@ABH@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ENDP ; std::pair<int const ,int>::pair<int const ,int><std::tuple<int const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0ABH$$Z$$V@?$pair@$$CBHH@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0ABH$$Z$$V@?$pair@$$CBHH@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$V@1@@Z PROC ; std::pair<int const ,int>::pair<int const ,int><int const &>, COMDAT
; _this$ = ecx

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 903  :           index_sequence_for<_Types2...>()) { // construct from pair of tuples
; 904  : }

	mov	eax, ecx

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples

	mov	DWORD PTR [ecx+4], 0

; 903  :           index_sequence_for<_Types2...>()) { // construct from pair of tuples
; 904  : }

	ret	12					; 0000000cH
??$?0ABH$$Z$$V@?$pair@$$CBHH@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABH@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<int const ,int>::pair<int const ,int><int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Tree_node<std::pair<int const ,int>,void *> *,std::nullptr_t>, COMDAT

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	edx, DWORD PTR __Val$[esp-4]

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	ecx, DWORD PTR __New_val$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx

; 528  :     return _Old_val;
; 529  : }

	ret	0
??$exchange@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Tree_node<std::pair<int const ,int>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Buy_if_not_node@AAU?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PAU21@AAU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Buy_if_not_node@AAU?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PAU21@AAU?$pair@$$CBHH@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buy_if_not_node<std::pair<int const ,int> &>, COMDAT
; _this$ = ecx

; 1255 :         return _Node;

	mov	eax, DWORD PTR __Node$[esp-4]

; 1256 :     }

	ret	8
??$_Buy_if_not_node@AAU?$pair@$$CBHH@std@@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PAU21@AAU?$pair@$$CBHH@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buy_if_not_node<std::pair<int const ,int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBHH@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAU?$pair@$$CBHH@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$construct@U?$pair@$$CBHH@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAU?$pair@$$CBHH@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::pair<int const ,int>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

	mov	eax, DWORD PTR _<_Args_1>$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	ecx, DWORD PTR __Ptr$[esp-4]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

	mov	eax, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 820  :     }

	ret	0
??$construct@U?$pair@$$CBHH@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAU?$pair@$$CBHH@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::pair<int const ,int>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 1198 :         if (_Ptr) {

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN19@Alloc_cons

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN19@Alloc_cons:

; 1199 :             _Al.deallocate(_Ptr, 1);
; 1200 :         }
; 1201 :     }

	ret	0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1192 :     void _Allocate() { // disengage *this, then allocate a new memory block

	push	esi
	mov	esi, ecx

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H

; 1193 :         _Ptr = nullptr; // if allocate throws, prevents double-free

	mov	DWORD PTR [esi+4], 0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1194 :         _Ptr = _Al.allocate(1);

	mov	DWORD PTR [esi+4], eax
	pop	esi

; 1195 :     }

	ret	0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::_Release, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR [ecx+4]

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1190 :     }

	ret	0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 1186 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

	mov	eax, DWORD PTR __Al_$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z PROC		; std::_Tuple_val<int const &>::_Tuple_val<int const &><int const &>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR __Arg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 161  :     }

	mov	eax, ecx
	ret	4
??$?0ABH@?$_Tuple_val@ABH@std@@QAE@ABH@Z ENDP		; std::_Tuple_val<int const &>::_Tuple_val<int const &><int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT
; _this$ = ecx

; 224  :     }

	mov	eax, ecx
	ret	4
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
_TEXT	SEGMENT
__Bytes$2 = -28						; size = 4
tv539 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Addleft$3 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T4 = 12						; size = 4
$T5 = 12						; size = 4
__Where$6 = 12						; size = 4
__Leftish$ = 12						; size = 1
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_nohint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT
; _this$ = ecx

; 1353 :     _Pairib _Insert_nohint(bool _Leftish, _Valty&& _Val, _Nodety _Newnode) { // try to insert node, on left if _Leftish

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, ecx
	mov	DWORD PTR _this$[ebp], eax

; 1354 :         auto& _My_data = _Get_data();
; 1355 :         _TRY_BEGIN

	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1356 :         _Nodeptr _Wherenode = _My_data._Myhead;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv539[ebp], eax
	mov	edi, eax

; 1357 :         _Nodeptr _Trynode   = _Wherenode->_Parent;

	mov	ecx, DWORD PTR [edi+4]

; 1358 :         bool _Addleft       = true; // add to left of head if tree empty

	mov	al, 1
	mov	BYTE PTR __Addleft$3[ebp], al
	mov	edx, DWORD PTR __Val$[ebp]
	npad	4
$LL2@Insert_noh:

; 1359 : 
; 1360 :         while (!_Trynode->_Isnil) { // look for leaf to insert before (_Addleft) or after

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@Insert_noh

; 1361 :             _Wherenode = _Trynode;

	mov	edi, ecx

; 1362 :             if (_Leftish) {

	cmp	BYTE PTR __Leftish$[ebp], 0
	je	SHORT $LN5@Insert_noh
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1363 :                 _Addleft = !_DEBUG_LT_PRED(_Getcomp(), _Key(_Trynode),

	setge	al

; 1364 :                     _Kfn(_Val)); // favor left end
; 1365 :             } else {

	jmp	SHORT $LN184@Insert_noh
$LN5@Insert_noh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx+16]
	setl	al
$LN184@Insert_noh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1370 :             _Trynode = _Addleft ? _Trynode->_Left : _Trynode->_Right;

	mov	BYTE PTR __Addleft$3[ebp], al
	test	al, al
	je	SHORT $LN14@Insert_noh
	mov	ecx, DWORD PTR [ecx]
	jmp	SHORT $LL2@Insert_noh
$LN14@Insert_noh:
	mov	ecx, DWORD PTR [ecx+8]

; 1371 :         }

	jmp	SHORT $LL2@Insert_noh
$LN3@Insert_noh:

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	esi, edi
	mov	DWORD PTR __Where$6[ebp], esi

; 1372 : 
; 1373 :         if
; 1374 :             _CONSTEXPR_IF(_Multi) {
; 1375 :                 return _Pairib(_Insert_at(_Addleft, _Wherenode, _STD forward<_Valty>(_Val), _Newnode), true);
; 1376 :             }
; 1377 :         else { // insert only if unique
; 1378 :             iterator _Where = iterator(_Wherenode, _STD addressof(_My_data));
; 1379 :             if (!_Addleft) { // need to test if insert after is okay

	test	al, al
	je	SHORT $LN10@Insert_noh

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR tv539[ebp]
	cmp	edi, DWORD PTR [eax]

; 1380 :             } else if (_Where == begin()) {

	jne	SHORT $LN9@Insert_noh

; 1381 :                 return _Pairib(_Insert_at(true, _Wherenode, _STD forward<_Valty>(_Val), _Newnode), true);

	push	DWORD PTR __Newnode$[ebp]
	push	edx
	push	edi
	push	1
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_at<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ebx], ecx
$LN185@Insert_noh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1397 :     }

	mov	BYTE PTR [ebx+4], 1
$LN186@Insert_noh:
	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN9@Insert_noh:

; 296  :         --static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$6[ebp]
	call	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--
	mov	esi, DWORD PTR __Where$6[ebp]
$LN10@Insert_noh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR __Val$[ebp]
	cmp	eax, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1386 :             if (_DEBUG_LT_PRED(_Getcomp(), _Key(_Where._Ptr), _Kfn(_Val))) {

	jge	SHORT $LN11@Insert_noh

; 1387 :                 return _Pairib(_Insert_at(_Addleft, _Wherenode, _STD forward<_Valty>(_Val), _Newnode), true);

	push	DWORD PTR __Newnode$[ebp]
	push	ecx
	push	edi
	push	DWORD PTR __Addleft$3[ebp]
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_at<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1387 :                 return _Pairib(_Insert_at(_Addleft, _Wherenode, _STD forward<_Valty>(_Val), _Newnode), true);

	jmp	SHORT $LN185@Insert_noh
$LN11@Insert_noh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 814  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	mov	DWORD PTR __Bytes$2[ebp], 24		; 00000018H

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	DWORD PTR __Newnode$[ebp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [ebx], esi
	mov	BYTE PTR [ebx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1390 :                 return _Pairib(_Where, false);

	jmp	SHORT $LN186@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$0:

; 1391 :             }
; 1392 :         }
; 1393 :         _CATCH_ALL
; 1394 :         _Destroy_if_node(_Newnode);

	push	DWORD PTR __Newnode$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy_if_node@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Destroy_if_node

; 1395 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN183@Insert_noh:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_nohint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_at<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT
; _this$ = ecx

; 1401 :         _Nodety _Node) { // add node with value next to _Wherenode, to left if _Addleft

	push	ebp
	mov	ebp, ecx

; 1402 :         auto& _My_data = _Get_data();
; 1403 :         if (max_size() - 1 <= _My_data._Mysize) { // tree would get too big, fail

	mov	eax, DWORD PTR [ebp+4]
	cmp	eax, 178956969				; 0aaaaaa9H
	jae	$LN104@Insert_at

; 1406 :         }
; 1407 : 
; 1408 :         _Nodeptr _Newnode = _Buy_if_not_node(_Node, _STD forward<_Valty>(_Val));
; 1409 : 
; 1410 :         ++_My_data._Mysize;
; 1411 :         _Newnode->_Parent = _Wherenode;

	push	ebx
	mov	ebx, DWORD PTR __Node$[esp+4]
	inc	eax
	mov	DWORD PTR [ebp+4], eax
	mov	eax, DWORD PTR __Wherenode$[esp+4]
	mov	DWORD PTR [ebx+4], eax

; 1412 : 
; 1413 :         if (_Wherenode == _My_data._Myhead) { // first node in tree, just set head values

	mov	ecx, DWORD PTR [ebp]
	cmp	eax, ecx
	jne	SHORT $LN6@Insert_at

; 1414 :             _My_data._Root()  = _Newnode;

	mov	DWORD PTR [ecx+4], ebx

; 444  :         return _Myhead->_Left;

	mov	eax, DWORD PTR [ebp]

; 1415 :             _My_data._Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1416 :             _My_data._Rmost() = _Newnode;

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN11@Insert_at
$LN6@Insert_at:

; 1417 :         } else if (_Addleft) { // add to left of _Wherenode

	cmp	BYTE PTR __Addleft$[esp+4], 0
	je	SHORT $LN8@Insert_at

; 1418 :             _Wherenode->_Left = _Newnode;

	mov	DWORD PTR [eax], ebx

; 444  :         return _Myhead->_Left;

	mov	ecx, DWORD PTR [ebp]

; 1419 :             if (_Wherenode == _My_data._Lmost()) {

	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN11@Insert_at

; 1420 :                 _My_data._Lmost() = _Newnode;

	mov	DWORD PTR [ecx], ebx

; 1421 :             }
; 1422 :         } else { // add to right of _Wherenode

	jmp	SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1423 :             _Wherenode->_Right = _Newnode;

	mov	DWORD PTR [eax+8], ebx

; 448  :         return _Myhead->_Right;

	mov	ecx, DWORD PTR [ebp]

; 1424 :             if (_Wherenode == _My_data._Rmost()) {

	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN11@Insert_at

; 1425 :                 _My_data._Rmost() = _Newnode;

	mov	DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1426 :             }
; 1427 :         }
; 1428 : 
; 1429 :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	eax, DWORD PTR [ebx+4]
	mov	edx, ebx
	cmp	BYTE PTR [eax+12], 0
	jne	$LN3@Insert_at
	push	esi
	push	edi
	npad	5
$LL2@Insert_at:

; 1430 :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

	mov	ecx, DWORD PTR [edx+4]
	lea	edi, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+4]
	lea	ebx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [esi]
	cmp	ecx, eax
	jne	$LN12@Insert_at

; 1431 :                 _Wherenode = _Pnode->_Parent->_Parent->_Right;

	mov	eax, DWORD PTR [esi+8]

; 1432 :                 if (_Wherenode->_Color == _Red) { // parent has two red children, blacken both

	cmp	BYTE PTR [eax+12], 0
	je	$LN102@Insert_at

; 1433 :                     _Pnode->_Parent->_Color          = _Black;
; 1434 :                     _Wherenode->_Color               = _Black;
; 1435 :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 1436 :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 1437 :                 } else { // parent has red and black children
; 1438 :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	jne	SHORT $LN99@Insert_at

; 453  :         _Wherenode->_Right = _Pnode->_Left;

	mov	eax, DWORD PTR [esi]

; 1439 :                         _Pnode = _Pnode->_Parent;

	mov	edx, ecx

; 453  :         _Wherenode->_Right = _Pnode->_Left;

	mov	DWORD PTR [edx+8], eax

; 454  : 
; 455  :         if (!_Pnode->_Left->_Isnil) {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN56@Insert_at

; 456  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN56@Insert_at:

; 457  :         }
; 458  : 
; 459  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi+4], eax

; 460  : 
; 461  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ebp]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN57@Insert_at

; 462  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 470  :         _Wherenode->_Parent = _Pnode;

	mov	edi, ebx
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [ebx], esi
	jmp	SHORT $LN97@Insert_at
$LN57@Insert_at:

; 463  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	eax, DWORD PTR [ebx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN59@Insert_at

; 464  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], esi

; 470  :         _Wherenode->_Parent = _Pnode;

	mov	edi, ebx
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [ebx], esi
	jmp	SHORT $LN97@Insert_at
$LN59@Insert_at:

; 466  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 470  :         _Wherenode->_Parent = _Pnode;

	mov	edi, ebx
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [ebx], esi
	jmp	SHORT $LN97@Insert_at
$LN99@Insert_at:
	mov	esi, ecx
$LN97@Insert_at:

; 1440 :                         _My_data._Lrotate(_Pnode);
; 1441 :                     }
; 1442 : 
; 1443 :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	BYTE PTR [esi+12], 1

; 1444 :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1445 :                     _My_data._Rrotate(_Pnode->_Parent->_Parent);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]

; 474  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	esi, DWORD PTR [ecx]

; 475  :         _Wherenode->_Left = _Pnode->_Right;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], eax

; 476  : 
; 477  :         if (!_Pnode->_Right->_Isnil) {

	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN63@Insert_at

; 478  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN63@Insert_at:

; 479  :         }
; 480  : 
; 481  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax

; 482  : 
; 483  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN64@Insert_at

; 484  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Right      = _Wherenode;

	mov	DWORD PTR [esi+8], ecx

; 1446 :                 }
; 1447 :             } else { // fixup red-red in right subtree

	jmp	$LN101@Insert_at
$LN64@Insert_at:

; 485  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN66@Insert_at

; 486  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Right      = _Wherenode;

	mov	DWORD PTR [esi+8], ecx

; 1446 :                 }
; 1447 :             } else { // fixup red-red in right subtree

	jmp	$LN101@Insert_at
$LN66@Insert_at:

; 488  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], esi

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Right      = _Wherenode;

	mov	DWORD PTR [esi+8], ecx

; 1446 :                 }
; 1447 :             } else { // fixup red-red in right subtree

	jmp	$LN101@Insert_at
$LN12@Insert_at:

; 1448 :                 _Wherenode = _Pnode->_Parent->_Parent->_Left;
; 1449 :                 if (_Wherenode->_Color == _Red) { // parent has two red children, blacken both

	cmp	BYTE PTR [eax+12], 0
	jne	SHORT $LN17@Insert_at
$LN102@Insert_at:

; 1426 :             }
; 1427 :         }
; 1428 : 
; 1429 :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	BYTE PTR [ecx+12], 1
	mov	BYTE PTR [eax+12], 1
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]
	jmp	$LN18@Insert_at
$LN17@Insert_at:

; 1450 :                     _Pnode->_Parent->_Color          = _Black;
; 1451 :                     _Wherenode->_Color               = _Black;
; 1452 :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 1453 :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 1454 :                 } else { // parent has red and black children
; 1455 :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

	mov	eax, DWORD PTR [ecx]
	cmp	edx, eax
	jne	SHORT $LN19@Insert_at

; 1456 :                         _Pnode = _Pnode->_Parent;

	mov	edx, ecx

; 474  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	ecx, eax

; 475  :         _Wherenode->_Left = _Pnode->_Right;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 476  : 
; 477  :         if (!_Pnode->_Right->_Isnil) {

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN70@Insert_at

; 478  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN70@Insert_at:

; 479  :         }
; 480  : 
; 481  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ecx+4], eax

; 482  : 
; 483  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ebp]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN71@Insert_at

; 484  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN74@Insert_at
$LN71@Insert_at:

; 485  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	eax, DWORD PTR [ebx]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN73@Insert_at

; 486  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], ecx

; 487  :         } else {

	jmp	SHORT $LN74@Insert_at
$LN73@Insert_at:

; 488  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], ecx
$LN74@Insert_at:

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Right      = _Wherenode;

	mov	DWORD PTR [ecx+8], edx

; 492  :         _Wherenode->_Parent = _Pnode;

	mov	edi, ebx
	mov	DWORD PTR [ebx], ecx
$LN19@Insert_at:

; 1457 :                         _My_data._Rrotate(_Pnode);
; 1458 :                     }
; 1459 : 
; 1460 :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

	mov	BYTE PTR [ecx+12], 1

; 1461 :                     _Pnode->_Parent->_Parent->_Color = _Red;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1462 :                     _My_data._Lrotate(_Pnode->_Parent->_Parent);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]

; 452  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	esi, DWORD PTR [ecx+8]

; 453  :         _Wherenode->_Right = _Pnode->_Left;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx+8], eax

; 454  : 
; 455  :         if (!_Pnode->_Left->_Isnil) {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN77@Insert_at

; 456  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN77@Insert_at:

; 457  :         }
; 458  : 
; 459  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax

; 460  : 
; 461  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN78@Insert_at

; 462  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], esi
	jmp	SHORT $LN81@Insert_at
$LN78@Insert_at:

; 463  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN80@Insert_at

; 464  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], esi

; 465  :         } else {

	jmp	SHORT $LN81@Insert_at
$LN80@Insert_at:

; 466  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], esi
$LN81@Insert_at:

; 467  :         }
; 468  : 
; 469  :         _Pnode->_Left       = _Wherenode;

	mov	DWORD PTR [esi], ecx
$LN101@Insert_at:

; 1426 :             }
; 1427 :         }
; 1428 : 
; 1429 :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

	mov	DWORD PTR [ecx+4], esi
$LN18@Insert_at:
	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+12], 0
	je	$LL2@Insert_at
	mov	ebx, DWORD PTR __Node$[esp+12]
	pop	edi
	pop	esi
$LN3@Insert_at:

; 1463 :                 }
; 1464 :             }
; 1465 :         }
; 1466 : 
; 1467 :         _My_data._Root()->_Color = _Black; // root is always black

	mov	eax, DWORD PTR [ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 1

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	DWORD PTR [eax], ebx

; 1468 :         return iterator(_Newnode, _STD addressof(_My_data));

	pop	ebx
	pop	ebp

; 1469 :     }

	ret	20					; 00000014H
$LN104@Insert_at:

; 1404 :             _Destroy_if_node(_Node);

	push	DWORD PTR __Node$[esp]
	call	?_Destroy_if_node@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Destroy_if_node

; 1405 :             _Xlength_error("map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN100@Insert_at:
	int	3
??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_at<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBHH@std@@@std@@YAAAU?$pair@$$CBHH@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@$$CBHH@std@@@std@@YAAAU?$pair@$$CBHH@0@AAU10@@Z PROC ; std::forward<std::pair<int const ,int> &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAU?$pair@$$CBHH@std@@@std@@YAAAU?$pair@$$CBHH@0@AAU10@@Z ENDP ; std::forward<std::pair<int const ,int> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
_<_Val_1>$ = 20						; size = 4
_<_Val_2>$ = 24						; size = 4
??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree_node<std::pair<int const ,int>,void *>::_Buynode<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

	mov	ecx, DWORD PTR _<_Val_1>$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR __Myhead$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples

	mov	DWORD PTR [eax+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 369  :         _Newnode._Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 370  :         _Newnode._Ptr->_Isnil = false;
; 371  :         return _Newnode._Release();
; 372  :     }

	ret	0
??$_Buynode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_node<std::pair<int const ,int>,void *>::_Buynode<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@ABH$$V$0A@@?$tuple@ABH@std@@QAE@U_Exact_args_t@1@ABH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@ABH$$V$0A@@?$tuple@ABH@std@@QAE@U_Exact_args_t@1@ABH@Z PROC ; std::tuple<int const &>::tuple<int const &><std::_Exact_args_t,int const &,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 251  :           _Myfirst(_STD forward<_This2>(_This_arg)) { // construct from one arg per element
; 252  :     }

	mov	eax, ecx
	ret	8
??$?0U_Exact_args_t@std@@ABH$$V$0A@@?$tuple@ABH@std@@QAE@U_Exact_args_t@1@ABH@Z ENDP ; std::tuple<int const &>::tuple<int const &><std::_Exact_args_t,int const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Zero_range@PAH@std@@YAPAHQAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAH@std@@YAPAHQAH0@Z PROC		; std::_Zero_range<int *>, COMDAT

; 312  :     char* const _First_ch = reinterpret_cast<char*>(_First);
; 313  :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);
; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, edx
	push	ecx
	push	0
	push	edx
	call	_memset

; 315  :     return _Last;

	mov	eax, DWORD PTR __Last$[esp+8]
	add	esp, 12					; 0000000cH

; 316  : }

	ret	0
??$_Zero_range@PAH@std@@YAPAHQAH0@Z ENDP		; std::_Zero_range<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 8
_this$ = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
$T3 = 16						; size = 4
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_hint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT
; _this$ = ecx

; 1271 :     iterator _Insert_hint(const_iterator _Where, _Valty&& _Val, _Nodety _Newnode) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	DWORD PTR _this$[ebp], ebx

; 32   :     _Tree_unchecked_const_iterator() : _Ptr() { // construct with null node pointer

	mov	DWORD PTR __Next$[ebp], 0

; 1272 :         // try to insert node using _Where as a hint
; 1273 :         const_iterator _Next;
; 1274 :         bool _Leftish  = false; // assume nearest point is end of sequence
; 1275 :         auto& _My_data = _Get_data();
; 1276 : 
; 1277 :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1022 :         return _Get_data()._Mysize;

	mov	eax, DWORD PTR [ebx]

; 1278 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1279 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_My_data), "map/set insert iterator outside range");
; 1280 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1281 : 
; 1282 :         if (size() == 0) {

	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LN3@Insert_hin

; 1283 :             return _Insert_at(true, _My_data._Myhead, _STD forward<_Valty>(_Val), _Newnode); // empty tree

	push	DWORD PTR __Newnode$[ebp]
	push	DWORD PTR __Val$[ebp]
	push	eax
$LN225@Insert_hin:

; 1350 :     }

	push	1
$LN226@Insert_hin:
	mov	ecx, ebx
$LN227@Insert_hin:
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
	call	??$_Insert_at@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAU?$pair@$$CBHH@1@1@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_at<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@Insert_hin:

; 231  :         return this->_Ptr == _Right._Ptr;

	mov	esi, DWORD PTR __Where$[ebp]

; 1284 :         } else if
; 1285 :             _CONSTEXPR_IF(_Multi) { // insert even if duplicate
; 1286 :                 if (_Where == begin()) { // insert at beginning if before first element
; 1287 :                     if (!_DEBUG_LT_PRED(_Getcomp(), _Key(_Where._Ptr), _Kfn(_Val))) {
; 1288 :                         return _Insert_at(true, _Where._Ptr, _STD forward<_Valty>(_Val), _Newnode);
; 1289 :                     }
; 1290 : 
; 1291 :                     _Leftish = true; // nearest point is beginning of sequence
; 1292 :                 } else if (_Where == end()) { // insert at end if after last element
; 1293 :                     if (!_DEBUG_LT_PRED(_Getcomp(), _Kfn(_Val), _Key(_My_data._Rmost()))) {
; 1294 :                         return _Insert_at(false, _My_data._Rmost(), _STD forward<_Valty>(_Val), _Newnode);
; 1295 :                     }
; 1296 :                 } else if (!_DEBUG_LT_PRED(_Getcomp(), _Key(_Where._Ptr), _Kfn(_Val))
; 1297 :                            && !_DEBUG_LT_PRED(_Getcomp(), _Kfn(_Val),
; 1298 :                                   _Key((--(_Next = _Where))._Ptr))) { // insert before _Where
; 1299 :                     if (_Next._Ptr->_Right->_Isnil) {
; 1300 :                         return _Insert_at(false, _Next._Ptr, _STD forward<_Valty>(_Val), _Newnode);
; 1301 :                     } else {
; 1302 :                         return _Insert_at(true, _Where._Ptr, _STD forward<_Valty>(_Val), _Newnode);
; 1303 :                     }
; 1304 :                 } else if (!_DEBUG_LT_PRED(_Getcomp(), _Kfn(_Val), _Key(_Where._Ptr))
; 1305 :                            && (++(_Next = _Where) == end()
; 1306 :                                   || !_DEBUG_LT_PRED(
; 1307 :                                          _Getcomp(), _Key(_Next._Ptr), _Kfn(_Val)))) { // insert after _Where
; 1308 :                     if (_Where._Ptr->_Right->_Isnil) {
; 1309 :                         return _Insert_at(false, _Where._Ptr, _STD forward<_Valty>(_Val), _Newnode);
; 1310 :                     } else {
; 1311 :                         return _Insert_at(true, _Next._Ptr, _STD forward<_Valty>(_Val), _Newnode);
; 1312 :                     }
; 1313 :                 } else {
; 1314 :                     _Leftish = true; // nearest point is beginning of sequence
; 1315 :                 }
; 1316 :             }
; 1317 :         else { // insert only if unique
; 1318 :             if (_Where == begin()) { // insert at beginning if before first element

	mov	edi, DWORD PTR __Val$[ebp]

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, DWORD PTR [eax]

; 1284 :         } else if
; 1285 :             _CONSTEXPR_IF(_Multi) { // insert even if duplicate
; 1286 :                 if (_Where == begin()) { // insert at beginning if before first element
; 1287 :                     if (!_DEBUG_LT_PRED(_Getcomp(), _Key(_Where._Ptr), _Kfn(_Val))) {
; 1288 :                         return _Insert_at(true, _Where._Ptr, _STD forward<_Valty>(_Val), _Newnode);
; 1289 :                     }
; 1290 : 
; 1291 :                     _Leftish = true; // nearest point is beginning of sequence
; 1292 :                 } else if (_Where == end()) { // insert at end if after last element
; 1293 :                     if (!_DEBUG_LT_PRED(_Getcomp(), _Kfn(_Val), _Key(_My_data._Rmost()))) {
; 1294 :                         return _Insert_at(false, _My_data._Rmost(), _STD forward<_Valty>(_Val), _Newnode);
; 1295 :                     }
; 1296 :                 } else if (!_DEBUG_LT_PRED(_Getcomp(), _Key(_Where._Ptr), _Kfn(_Val))
; 1297 :                            && !_DEBUG_LT_PRED(_Getcomp(), _Kfn(_Val),
; 1298 :                                   _Key((--(_Next = _Where))._Ptr))) { // insert before _Where
; 1299 :                     if (_Next._Ptr->_Right->_Isnil) {
; 1300 :                         return _Insert_at(false, _Next._Ptr, _STD forward<_Valty>(_Val), _Newnode);
; 1301 :                     } else {
; 1302 :                         return _Insert_at(true, _Where._Ptr, _STD forward<_Valty>(_Val), _Newnode);
; 1303 :                     }
; 1304 :                 } else if (!_DEBUG_LT_PRED(_Getcomp(), _Kfn(_Val), _Key(_Where._Ptr))
; 1305 :                            && (++(_Next = _Where) == end()
; 1306 :                                   || !_DEBUG_LT_PRED(
; 1307 :                                          _Getcomp(), _Key(_Next._Ptr), _Kfn(_Val)))) { // insert after _Where
; 1308 :                     if (_Where._Ptr->_Right->_Isnil) {
; 1309 :                         return _Insert_at(false, _Where._Ptr, _STD forward<_Valty>(_Val), _Newnode);
; 1310 :                     } else {
; 1311 :                         return _Insert_at(true, _Next._Ptr, _STD forward<_Valty>(_Val), _Newnode);
; 1312 :                     }
; 1313 :                 } else {
; 1314 :                     _Leftish = true; // nearest point is beginning of sequence
; 1315 :                 }
; 1316 :             }
; 1317 :         else { // insert only if unique
; 1318 :             if (_Where == begin()) { // insert at beginning if before first element

	jne	SHORT $LN5@Insert_hin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1319 :                 if (_DEBUG_LT_PRED(_Getcomp(), _Kfn(_Val), _Key(_Where._Ptr))) {

	jge	$LN18@Insert_hin

; 1320 :                     return _Insert_at(true, _Where._Ptr, _STD forward<_Valty>(_Val), _Newnode);

	push	DWORD PTR __Newnode$[ebp]
	push	edi
	push	esi
	jmp	SHORT $LN225@Insert_hin
$LN5@Insert_hin:

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, eax

; 1321 :                 }
; 1322 :             } else if (_Where == end()) { // insert at end if after last element

	jne	SHORT $LN8@Insert_hin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 62   :         return _Val.first;

	mov	ecx, DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1323 :                 if (_DEBUG_LT_PRED(_Getcomp(), _Key(_My_data._Rmost()), _Kfn(_Val))) {

	jge	$LN18@Insert_hin

; 1324 :                     return _Insert_at(false, _My_data._Rmost(), _STD forward<_Valty>(_Val), _Newnode);

	push	DWORD PTR __Newnode$[ebp]
	push	edi
	push	ecx
	push	0
	jmp	SHORT $LN226@Insert_hin
$LN8@Insert_hin:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	ecx, DWORD PTR [edi]
	cmp	DWORD PTR [esi+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1327 :                        && _DEBUG_LT_PRED(_Getcomp(), _Key((--(_Next = _Where))._Ptr),

	jle	SHORT $LN224@Insert_hin
	mov	DWORD PTR __Next$[ebp], esi
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--
	mov	eax, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	ecx, DWORD PTR [edi]
	cmp	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1327 :                        && _DEBUG_LT_PRED(_Getcomp(), _Key((--(_Next = _Where))._Ptr),

	jge	SHORT $LN11@Insert_hin

; 1328 :                               _Kfn(_Val))) { // insert before _Where
; 1329 :                 if (_Next._Ptr->_Right->_Isnil) {

	mov	eax, DWORD PTR __Next$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	DWORD PTR __Newnode$[ebp]
	push	edi
	cmp	BYTE PTR [ecx+13], 0
	mov	ecx, ebx
	je	SHORT $LN13@Insert_hin

; 1330 :                     return _Insert_at(false, _Next._Ptr, _STD forward<_Valty>(_Val), _Newnode);

	push	eax
	push	0
	jmp	$LN227@Insert_hin
$LN13@Insert_hin:

; 1331 :                 } else {
; 1332 :                     return _Insert_at(true, _Where._Ptr, _STD forward<_Valty>(_Val), _Newnode);

	push	esi
	push	1
	jmp	$LN227@Insert_hin
$LN11@Insert_hin:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	cmp	DWORD PTR [esi+16], ecx
$LN224@Insert_hin:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1335 :                        && (++(_Next = _Where) == end()

	jge	SHORT $LN18@Insert_hin
	mov	DWORD PTR __Next$[ebp], esi
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR $T3[ebp], ecx

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	DWORD PTR [eax], ecx

; 1335 :                        && (++(_Next = _Where) == end()

	mov	eax, DWORD PTR __Next$[ebp]
	je	SHORT $LN16@Insert_hin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1335 :                        && (++(_Next = _Where) == end()

	jge	SHORT $LN18@Insert_hin
$LN16@Insert_hin:

; 1336 :                               || _DEBUG_LT_PRED(_Getcomp(), _Kfn(_Val), _Key(_Next._Ptr)))) { // insert after _Where
; 1337 :                 if (_Where._Ptr->_Right->_Isnil) {

	mov	ecx, DWORD PTR [esi+8]
	push	DWORD PTR __Newnode$[ebp]
	push	edi
	cmp	BYTE PTR [ecx+13], 0
	mov	ecx, ebx
	je	SHORT $LN17@Insert_hin

; 1338 :                     return _Insert_at(false, _Where._Ptr, _STD forward<_Valty>(_Val), _Newnode);

	push	esi
	push	0
	jmp	$LN227@Insert_hin
$LN17@Insert_hin:

; 1339 :                 } else {
; 1340 :                     return _Insert_at(true, _Next._Ptr, _STD forward<_Valty>(_Val), _Newnode);

	push	eax
	push	1
	jmp	$LN227@Insert_hin
$LN18@Insert_hin:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1347 :         _CATCH_END
; 1348 : 
; 1349 :         return _Insert_nohint(_Leftish, _STD forward<_Valty>(_Val), _Newnode).first;

	push	DWORD PTR __Newnode$[ebp]
	push	edi
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, ebx
	call	??$_Insert_nohint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_nohint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1350 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
__catch$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z$0:

; 1341 :                 }
; 1342 :             }
; 1343 :         }
; 1344 :         _CATCH_ALL
; 1345 :         _Destroy_if_node(_Newnode);

	push	DWORD PTR __Newnode$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy_if_node@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Destroy_if_node

; 1346 :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN223@Insert_hin:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_hint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
_<_Val_1>$ = 12						; size = 4
_<_Val_2>$ = 16						; size = 4
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 1814 :     _Nodeptr _Buynode(_Valty&&... _Val) { // allocate a node with defaults and set links and value

	push	esi

; 1815 :         return _Node::_Buynode(_Getal(), _Get_data()._Myhead, _STD forward<_Valty>(_Val)...);

	mov	esi, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

	mov	ecx, DWORD PTR _<_Val_1>$[esp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

	mov	ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+16], ecx

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples

	mov	DWORD PTR [eax+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 369  :         _Newnode._Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 1816 :     }

	pop	esi
	ret	12					; 0000000cH
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z PROC ; std::forward<std::tuple<int const &> >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@V?$tuple@ABH@std@@@std@@YA$$QAV?$tuple@ABH@0@AAV10@@Z ENDP ; std::forward<std::tuple<int const &> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z PROC ; std::forward<std::piecewise_construct_t const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z ENDP ; std::forward<std::piecewise_construct_t const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z
_TEXT	SEGMENT
__This_arg$ = 8						; size = 4
??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z PROC		; std::tuple<int const &>::tuple<int const &><int const &,0>, COMDAT
; _this$ = ecx

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR __This_arg$[esp-4]
	mov	DWORD PTR [ecx], eax

; 304  :         : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}

	mov	eax, ecx
	ret	4
??$?0ABH$0A@@?$tuple@ABH@std@@QAE@ABH@Z ENDP		; std::tuple<int const &>::tuple<int const &><int const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT
; _this$ = ecx

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR _<_Val2_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1528 :     }

	mov	eax, ecx
	ret	8
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAD@std@@YA$$QADAAD@Z PROC			; std::move<char &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAD@std@@YA$$QADAAD@Z ENDP			; std::move<char &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_value_construct_n1@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<int *,unsigned int,std::allocator<int> >, COMDAT

; 332  :     return _Zero_range(_First, _First + _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	push	esi

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	esi, DWORD PTR __First$[esp]

; 331  :     true_type) { // value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

	push	edi

; 332  :     return _Zero_range(_First, _First + _Count);

	lea	edi, DWORD PTR [eax*4]

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 332  :     return _Zero_range(_First, _First + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 333  : }

	ret	0
??$_Uninitialized_value_construct_n1@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<int *,unsigned int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z PROC		; std::_Seek_wrapped<int>, COMDAT

; 435  :     _It = _UIt;

	mov	eax, DWORD PTR __It$[esp-4]
	mov	ecx, DWORD PTR __UIt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 436  : }

	ret	0
??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z ENDP		; std::_Seek_wrapped<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 1762 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 1763 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 1764 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __First$[esp-4]
	push	esi

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 1767 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 1768 : }

	ret	0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z PROC	; std::_Get_unwrapped_n<int,int,0>, COMDAT

; 395  :     return _Src;

	mov	eax, DWORD PTR __Src$[esp-4]

; 396  : }

	ret	0
??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z ENDP	; std::_Get_unwrapped_n<int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z PROC		; std::_Idl_distance<int *,int *>, COMDAT

; 487  :     if constexpr (_Is_random_iter_v<_Iter>) {
; 488  :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 489  :     } else {
; 490  :         (void) _First; // TRANSITION, VSO#486357
; 491  :         (void) _Last; // TRANSITION, VSO#486357
; 492  :         return _Distance_unknown{};
; 493  :     }
; 494  : }

	ret	0
??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z ENDP		; std::_Idl_distance<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Get_unwrapped@H@std@@YAPAHQAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@H@std@@YAPAHQAH@Z PROC		; std::_Get_unwrapped<int>, COMDAT

; 275  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[esp-4]

; 276  : }

	ret	0
??$_Get_unwrapped@H@std@@YAPAHQAH@Z ENDP		; std::_Get_unwrapped<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<int const ,int>,void *> * &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<int const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > &,bool,0>, COMDAT
; _this$ = ecx

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al
	mov	eax, ecx
	ret	8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > > &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool,0>, COMDAT
; _this$ = ecx

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR __Val1$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Val2$[esp-4]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al
	mov	eax, ecx
	ret	8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
_<_Val_1>$ = 20						; size = 4
_<_Val_2>$ = 24						; size = 4
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 897  :     iterator emplace_hint(const_iterator _Where, _Valty&&... _Val) { // insert value_type(_Val...) at _Where

	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1815 :         return _Node::_Buynode(_Getal(), _Get_data()._Myhead, _STD forward<_Valty>(_Val)...);

	mov	edi, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

	mov	edx, DWORD PTR _<_Val_1>$[esp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 364  :         _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

	lea	esi, DWORD PTR [eax+16]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

	mov	edx, DWORD PTR [edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	eax
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	mov	ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples

	mov	DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 369  :         _Newnode._Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	DWORD PTR __Where$[esp+16]
	push	esi
	call	??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_hint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>

; 900  :     }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	ret	20					; 00000014H
??$emplace_hint@ABUpiecewise_construct_t@std@@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::emplace_hint<std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ PROC	; std::forward_as_tuple<>, COMDAT

; 737  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 738  : }

	ret	0
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ENDP	; std::forward_as_tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
;	COMDAT ??0?$tuple@ABH@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$tuple@ABH@std@@QAE@$$QAV01@@Z PROC			; std::tuple<int const &>::tuple<int const &>, COMDAT
; _this$ = ecx

	mov	eax, DWORD PTR ___that$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	4
??0?$tuple@ABH@std@@QAE@$$QAV01@@Z ENDP			; std::tuple<int const &>::tuple<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z PROC ; std::forward_as_tuple<int const &>, COMDAT

; 160  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) { // construct with argument

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR _<_Args_0>$[esp-4]
	mov	DWORD PTR [eax], ecx

; 737  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);
; 738  : }

	ret	0
??$forward_as_tuple@ABH@std@@YA?AV?$tuple@ABH@0@ABH@Z ENDP ; std::forward_as_tuple<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT

; 824  :         _Ptr->~_Uty();
; 825  :     }

	ret	0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::_Tree_node<std::pair<int const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBHH@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBHH@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAU?$pair@$$CBHH@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::pair<int const ,int> >, COMDAT

; 824  :         _Ptr->~_Uty();
; 825  :     }

	ret	0
??$destroy@U?$pair@$$CBHH@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAU?$pair@$$CBHH@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::destroy<std::pair<int const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ PROC ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits, COMDAT
; _this$ = ecx

; 3314 :     _Udiff _Get_bits() { // return a random value within [0, _Bmask]

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	DWORD PTR _this$1$[esp+16], ecx
	push	edi
	npad	7
$LL2@Get_bits:

; 3315 :         for (;;) { // repeat until random value is in range
; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	mov	edi, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1136 :         if (this->_Idx == _Nx) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 624				; 00000270H
	jne	SHORT $LN8@Get_bits

; 1178 :         for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { // fill in values

	lea	eax, DWORD PTR [edi+8]
	mov	esi, 624				; 00000270H
$LL15@Get_bits:

; 1179 :             _Ty _Tmp       = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + 1] & _LMSK);

	mov	edx, DWORD PTR [eax-4]
	lea	eax, DWORD PTR [eax+4]
	xor	edx, DWORD PTR [eax-4]
	and	edx, 2147483647				; 7fffffffH
	xor	edx, DWORD PTR [eax-8]

; 1180 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	ecx, edx
	and	cl, 1
	movzx	ecx, cl
	neg	ecx
	sbb	ecx, ecx
	shr	edx, 1
	and	ecx, -1727483681			; 9908b0dfH
	xor	ecx, DWORD PTR [eax+1580]
	xor	ecx, edx
	mov	DWORD PTR [eax+2488], ecx
	sub	esi, 1
	jne	SHORT $LL15@Get_bits

; 1138 :         } else if (2 * _Nx <= this->_Idx) {

	mov	eax, DWORD PTR [edi]
	jmp	$LN10@Get_bits
$LN8@Get_bits:
	cmp	eax, 1248				; 000004e0H
	jb	$LN10@Get_bits

; 1161 :         for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix) { // fill in lower region

	mov	eax, DWORD PTR [edi+2500]
	lea	ebx, DWORD PTR [edi+2500]
	mov	ebp, 227				; 000000e3H
	npad	1
$LL20@Get_bits:

; 1162 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR [ebx+4]
	xor	ecx, eax
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1163 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [ebx+1588]
	xor	eax, ecx
	mov	DWORD PTR [ebx-2496], eax
	lea	ebx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL20@Get_bits

; 1164 :         }
; 1165 : 
; 1166 :         for (; _Ix < _Nx - 1; ++_Ix) { // fill in upper region (avoids modulus operation)

	mov	eax, DWORD PTR [edi+3408]
	lea	ebx, DWORD PTR [edi+3408]
	mov	ebp, 396				; 0000018cH
	npad	6
$LL23@Get_bits:

; 1167 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, eax
	lea	edx, DWORD PTR [ebx+4]
	xor	ecx, DWORD PTR [edx]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1168 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [ebx-3404]
	xor	eax, ecx
	mov	DWORD PTR [ebx-2496], eax
	lea	ebx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL23@Get_bits

; 1169 :         }
; 1170 : 
; 1171 :         _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

	mov	ecx, DWORD PTR [edi+4992]
	xor	ecx, DWORD PTR [edi+4]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, DWORD PTR [edi+4992]

; 1172 :         this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [edi+1588]
	xor	eax, ecx
	mov	DWORD PTR [edi+2496], eax

; 1173 :         this->_Idx     = 0;

	xor	eax, eax
	mov	DWORD PTR [edi], 0
$LN10@Get_bits:

; 1142 :         _Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

	mov	edx, DWORD PTR [edi+eax*4+4]
	inc	eax
	mov	DWORD PTR [edi], eax

; 1143 :         _Res ^= (_Res >> _Ux) & _Dxval;

	mov	ecx, edx
	mov	eax, DWORD PTR [edi+4996]
	shr	ecx, 11					; 0000000bH
	and	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3318 :             if (_Val <= _Bmask) {

	mov	ecx, DWORD PTR _this$1$[esp+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1143 :         _Res ^= (_Res >> _Ux) & _Dxval;

	xor	edx, eax

; 1144 :         _Res ^= (_Res << _Sx) & _Bx;

	mov	eax, edx
	and	eax, -12953427				; ff3a58adH
	shl	eax, 7
	xor	edx, eax

; 1145 :         _Res ^= (_Res << _Tx) & _Cx;

	mov	eax, edx
	and	eax, -8308				; ffffdf8cH
	shl	eax, 15					; 0000000fH
	xor	edx, eax

; 1146 :         _Res ^= (_Res & _WMSK) >> _Lx;

	mov	eax, edx
	shr	eax, 18					; 00000012H
	xor	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3318 :             if (_Val <= _Bmask) {

	cmp	eax, DWORD PTR [ecx+8]
	ja	$LL2@Get_bits

; 3319 :                 return _Val;

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3320 :             }
; 3321 :         }
; 3322 :     }

	pop	ecx
	ret	0
?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ?_Get_all_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEIXZ
_TEXT	SEGMENT
?_Get_all_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEIXZ PROC ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_all_bits, COMDAT
; _this$ = ecx

; 3298 :     _Udiff _Get_all_bits() { // return a random value

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 3299 :         _Udiff _Ret = 0;

	xor	edi, edi

; 3300 : 
; 3301 :         for (size_t _Num = 0; _Num < CHAR_BIT * sizeof(_Udiff); _Num += _Bits) { // don't mask away any bits

	xor	ebx, ebx
	mov	eax, DWORD PTR [esi+4]
	npad	4
$LL4@Get_all_bi:

; 3302 :             _Ret <<= _Bits - 1; // avoid full shift

	lea	ecx, DWORD PTR [eax-1]
	shl	edi, cl

; 3303 :             _Ret <<= 1;

	add	edi, edi
$LL7@Get_all_bi:

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	mov	ecx, DWORD PTR [esi]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()

; 3317 : 
; 3318 :             if (_Val <= _Bmask) {

	cmp	eax, DWORD PTR [esi+8]
	ja	SHORT $LL7@Get_all_bi

; 3300 : 
; 3301 :         for (size_t _Num = 0; _Num < CHAR_BIT * sizeof(_Udiff); _Num += _Bits) { // don't mask away any bits

	or	edi, eax
	mov	eax, DWORD PTR [esi+4]
	add	ebx, eax
	cmp	ebx, 32					; 00000020H
	jb	SHORT $LL4@Get_all_bi

; 3304 :             _Ret |= _Get_bits();
; 3305 :         }
; 3306 : 
; 3307 :         return _Ret;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3308 :     }

	ret	0
?_Get_all_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_all_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??R?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEII@Z
_TEXT	SEGMENT
__Index$ = 8						; size = 4
??R?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEII@Z PROC ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::operator(), COMDAT
; _this$ = ecx

; 3277 :     _Diff operator()(_Diff _Index) { // adapt _Urng closed range to [0, _Index)

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Index$[esp+4]
	push	esi
	push	edi
	mov	esi, ecx
	dec	ebp
	npad	5
$LL2@operator:

; 3278 :         for (;;) { // try a sample random value
; 3279 :             _Udiff _Ret  = 0; // random bits

	xor	edi, edi

; 3280 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

	xor	ebx, ebx

; 3281 : 
; 3282 :             while (_Mask < _Udiff(_Index - 1)) { // need more random bits

	test	ebp, ebp
	je	SHORT $LN6@operator
	mov	edx, DWORD PTR [esi+4]
	npad	5
$LL5@operator:

; 3283 :                 _Ret <<= _Bits - 1; // avoid full shift

	lea	ecx, DWORD PTR [edx-1]
	shl	edi, cl

; 3284 :                 _Ret <<= 1;

	add	edi, edi
$LL11@operator:

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	mov	ecx, DWORD PTR [esi]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
	mov	ecx, eax

; 3317 : 
; 3318 :             if (_Val <= _Bmask) {

	mov	eax, DWORD PTR [esi+8]
	cmp	ecx, eax
	ja	SHORT $LL11@operator

; 3285 :                 _Ret |= _Get_bits();

	mov	edx, DWORD PTR [esi+4]
	or	edi, ecx

; 3286 :                 _Mask <<= _Bits - 1; // avoid full shift

	lea	ecx, DWORD PTR [edx-1]
	shl	ebx, cl

; 3287 :                 _Mask <<= 1;

	add	ebx, ebx

; 3288 :                 _Mask |= _Bmask;

	or	ebx, eax
	cmp	ebx, ebp
	jb	SHORT $LL5@operator
$LN6@operator:

; 3289 :             }
; 3290 : 
; 3291 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3292 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

	xor	edx, edx
	mov	eax, ebx
	div	DWORD PTR __Index$[esp+12]
	mov	ecx, eax
	mov	ebx, edx
	xor	edx, edx
	mov	eax, edi
	div	DWORD PTR __Index$[esp+12]
	cmp	eax, ecx
	jb	SHORT $LN23@operator
	cmp	ebx, ebp
	jne	SHORT $LL2@operator
$LN23@operator:

; 3293 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, edi
	xor	edx, edx
	div	DWORD PTR __Index$[esp+12]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, edx
	pop	ebx

; 3294 :             }
; 3295 :         }
; 3296 :     }

	ret	4
??R?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAEII@Z ENDP ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??0?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAE@AAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
_TEXT	SEGMENT
__Func$ = 8						; size = 4
??0?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAE@AAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z PROC ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT
; _this$ = ecx

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	eax, DWORD PTR __Func$[esp-4]
	mov	DWORD PTR [ecx], eax

; 3272 :         for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1) {
; 3273 :             --_Bits;
; 3274 :         }
; 3275 :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 32			; 00000020H
	mov	DWORD PTR [ecx+8], -1
	ret	4
??0?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@QAE@AAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ENDP ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1816 :     }

	mov	eax, ecx
	ret	4
??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Ptr$ = 12						; size = 4
__Cvt$ = 16						; size = 44
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z PROC ; std::numpunct<char>::_Getvals<char>, COMDAT
; _this$ = ecx

; 170  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	mov	eax, DWORD PTR [edx]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ecx+12], al

; 171  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	eax, DWORD PTR [edx+4]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ecx+13], al

; 172  :     }

	ret	52					; 00000034H
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ENDP ; std::numpunct<char>::_Getvals<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 546  :     return (_Elem)(unsigned char) _Byte;

	mov	al, BYTE PTR __Byte$[esp-4]

; 547  : }

	ret	0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 572  :     const _Locinfo::_Cvtvec&) { // convert C string to _Elem sequence using _Cvtvec

	push	esi

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	esi, DWORD PTR __Ptr$[esp]
	push	edi
	mov	edi, esi
	lea	ecx, DWORD PTR [edi+1]
	npad	5
$LL11@Maklocstr:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL11@Maklocstr
	sub	edi, ecx
	inc	edi

; 574  : 
; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
	call	_calloc
	mov	edx, eax
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	edx, edx
	je	SHORT $LN14@Maklocstr

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	test	edi, edi
	je	SHORT $LN3@Maklocstr
	mov	ecx, edx
	sub	ecx, esi
$LL4@Maklocstr:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL4@Maklocstr
$LN3@Maklocstr:
	pop	edi

; 583  :     }
; 584  : 
; 585  :     return _Ptrdest;

	mov	eax, edx

; 586  : }

	pop	esi
	ret	0
$LN14@Maklocstr:

; 578  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN12@Maklocstr:
	int	3
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ PROC	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >, COMDAT
; _this$ = ecx

; 3513 :     ~_Tidy_guard() {

	push	esi

; 3514 :         if (_Target) {

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN2@Tidy_guard
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 224  :         _CSTD free((void*) _Grouping);

	push	DWORD PTR [esi+8]
	call	_free

; 225  :         _CSTD free((void*) _Falsename);

	push	DWORD PTR [esi+16]
	call	_free

; 226  :         _CSTD free((void*) _Truename);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 12					; 0000000cH
$LN2@Tidy_guard:
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3517 :     }

	ret	0
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ENDP	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
;	COMDAT ??$swap@DX@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@DX@std@@YAXAAD0@Z PROC				; std::swap<char,void>, COMDAT

; 54   :     _Ty _Tmp = _STD move(_Left);
; 55   :     _Left    = _STD move(_Right);

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR __Left$[esp-4]
	push	ebx
	mov	al, BYTE PTR [ecx]
	mov	bl, BYTE PTR [edx]
	mov	BYTE PTR [edx], al

; 56   :     _Right   = _STD move(_Tmp);

	mov	BYTE PTR [ecx], bl
	pop	ebx

; 57   : }

	ret	0
??$swap@DX@std@@YAXAAD0@Z ENDP				; std::swap<char,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 24   :     constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   :     size_t _Result                 = _Count * _Ty_size;

	mov	ecx, DWORD PTR __Count$[esp-4]

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	ecx, 1073741823				; 3fffffffH
	lea	eax, DWORD PTR [ecx*4]
	cmova	eax, edx

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);
; 29   :     }
; 30   : 
; 31   :     return _Result;
; 32   : }

	ret	0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_value_construct_n<int *,unsigned int,std::allocator<int> >, COMDAT

; 332  :     return _Zero_range(_First, _First + _Count);

	mov	eax, DWORD PTR __Count$[esp-4]

; 337  :     _NoThrowFwdIt _First, _Diff _Count, _Alloc& _Al) { // value-initialize _Count objects to raw _First, using _Al

	push	esi

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	esi, DWORD PTR __First$[esp]

; 337  :     _NoThrowFwdIt _First, _Diff _Count, _Alloc& _Al) { // value-initialize _Count objects to raw _First, using _Al

	push	edi

; 332  :     return _Zero_range(_First, _First + _Count);

	lea	edi, DWORD PTR [eax*4]

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 332  :     return _Zero_range(_First, _First + _Count);

	lea	eax, DWORD PTR [edi+esi]

; 338  :     return _Uninitialized_value_construct_n1(_First, _Count, _Al,

	pop	edi
	pop	esi

; 339  :         bool_constant<conjunction_v<_Use_memset_value_construct_t<_NoThrowFwdIt>,
; 340  :             _Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{});
; 341  : }

	ret	0
??$_Uninitialized_value_construct_n@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_value_construct_n<int *,unsigned int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,int *,std::allocator<int> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 221  :     _Alloc& _Al) { // move [_First, _Last) to raw _Dest, using _Al

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 221  :     _Alloc& _Al) { // move [_First, _Last) to raw _Dest, using _Al

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, eax

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 1767 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 240  :     return _Dest;

	pop	edi
	pop	esi

; 241  : }

	ret	0
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$0BI@@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0BI@@std@@YAII@Z PROC		; std::_Get_size_of_n<24>, COMDAT

; 24   :     constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   :     size_t _Result                 = _Count * _Ty_size;

	mov	ecx, DWORD PTR __Count$[esp-4]

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	or	edx, -1
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	cmp	ecx, 178956970				; 0aaaaaaaH
	cmova	eax, edx

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);
; 29   :     }
; 30   : 
; 31   :     return _Result;
; 32   : }

	ret	0
??$_Get_size_of_n@$0BI@@std@@YAII@Z ENDP		; std::_Get_size_of_n<24>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@AAPAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::construct<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<int const ,int>,void *> *>, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<int const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	mov	eax, DWORD PTR __Bytes$[esp-4]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	lea	ecx, DWORD PTR [eax+35]
	cmp	ecx, eax
	cmovbe	ecx, edx

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 89   :                                  // allocation function will throw bad_alloc
; 90   :         _Block_size = static_cast<size_t>(-1);
; 91   :     }
; 92   : 
; 93   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN7@Allocate_m

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 97   : 
; 98   : #ifdef _DEBUG
; 99   :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 100  : #endif // _DEBUG
; 101  :     return _Ptr;
; 102  : }

	ret	0
$LN7@Allocate_m:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	jmp	__invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 415  :     _Tree_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1528 :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 415  :     _Tree_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1528 :     }

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z PROC ; std::forward<std::less<int> const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z ENDP ; std::forward<std::less<int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 3514 :         if (_Target) {

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 3515 :             _Target->_Tidy();
; 3516 :         }
; 3517 :     }

	ret	0
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z PROC ; std::forward<std::allocator<int> const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ENDP ; std::forward<std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
;	COMDAT ??$_Try_emplace@ABH$$V@?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
??$_Try_emplace@ABH$$V@?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@ABH@Z PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::_Try_emplace<int const &>, COMDAT
; _this$ = ecx

; 188  :         _Mappedty&&... _Mapval) { // fail if _Keyval present, else emplace

	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1585 :         while (!_Pnode->_Isnil) {

	mov	ebx, DWORD PTR __Keyval$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 188  :         _Mappedty&&... _Mapval) { // fail if _Keyval present, else emplace

	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1582 :         _Nodeptr _Wherenode = _Get_data()._Myhead; // end() if search fails

	mov	edi, DWORD PTR [ebp]
	mov	esi, edi

; 1583 :         _Nodeptr _Pnode     = _Wherenode->_Parent;

	mov	eax, DWORD PTR [esi+4]

; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN18@Try_emplac
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	ecx, DWORD PTR [ebx]
	npad	6
$LL17@Try_emplac:
	cmp	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1586 :             if (_Compare(_Key(_Pnode), _Keyval)) {

	jge	SHORT $LN19@Try_emplac

; 1587 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 1588 :             } else { // _Pnode not less than _Keyval, remember it

	jmp	SHORT $LN20@Try_emplac
$LN19@Try_emplac:

; 1589 :                 _Wherenode = _Pnode;

	mov	esi, eax

; 1590 :                 _Pnode     = _Pnode->_Left; // descend left subtree

	mov	eax, DWORD PTR [eax]
$LN20@Try_emplac:

; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL17@Try_emplac
$LN18@Try_emplac:

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	je	SHORT $LN268@Try_emplac
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	jl	SHORT $LN268@Try_emplac
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax], esi
	mov	BYTE PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 198  :     }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN268@Try_emplac:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	ecx, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	mov	ecx, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples

	mov	DWORD PTR [eax+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 364  :         _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	edx

; 369  :         _Newnode._Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	lea	eax, DWORD PTR $T2[esp+20]
	push	esi
	push	eax
	call	??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_hint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	ecx, DWORD PTR $T2[esp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 198  :     }

	pop	edi
	pop	esi
	pop	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 198  :     }

	pop	ebx
	ret	8
??$_Try_emplace@ABH$$V@?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@ABH@Z ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::_Try_emplace<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<int const ,int>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	DWORD PTR __Ptr$[esp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 382  :     }

	ret	0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<int const ,int>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<int const ,int>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	DWORD PTR __Ptr$[esp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 390  :     }

	ret	0
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<int const ,int>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@0@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@0@Z PROC ; std::exchange<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>, COMDAT

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	edx, DWORD PTR __Val$[esp-4]

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	ecx, DWORD PTR __New_val$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx

; 528  :     return _Old_val;
; 529  : }

	ret	0
??$exchange@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@0@AAPAU10@0@Z ENDP ; std::exchange<std::_Tree_node<std::pair<int const ,int>,void *> *,std::_Tree_node<std::pair<int const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>, COMDAT
; _this$ = ecx

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 77   :         }

	mov	eax, ecx
	ret	4
??$?0_JX@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::duration<__int64,std::ratio<1,1000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z PROC ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >, COMDAT

; 248  :         using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
; 249  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	mov	ecx, DWORD PTR __Left$[esp-4]
	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	sbb	ecx, DWORD PTR [eax+4]

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 250  :     }

	ret	0
??$?G_JU?$ratio@$00$0DLJKMKAA@@std@@_JU01@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV201@0@Z ENDP ; std::chrono::operator-<__int64,std::ratio<1,1000000000>,__int64,std::ratio<1,1000000000> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@ABEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@HH@Z
_TEXT	SEGMENT
__Rng$ = -12						; size = 12
__Eng$ = 8						; size = 4
__Umin$1$ = 12						; size = 4
__Min$ = 12						; size = 4
__Max$ = 16						; size = 4
??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@ABEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@HH@Z PROC ; std::uniform_int<int>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT
; _this$ = ecx

; 1873 :     result_type _Eval(_Engine& _Eng, _Ty _Min, _Ty _Max) const { // compute next value in range [_Min, _Max]

	sub	esp, 12					; 0000000cH

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	mov	eax, DWORD PTR __Min$[esp+8]
	cmp	eax, -2147483648			; 80000000H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	edx, DWORD PTR __Eng$[esp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1873 :     result_type _Eval(_Engine& _Eng, _Ty _Min, _Ty _Max) const { // compute next value in range [_Min, _Max]

	push	ebx
	push	esi

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	lea	ecx, DWORD PTR [eax-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$[esp+20], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	lea	ebx, DWORD PTR [eax-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$[esp+24], 32		; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1877 :         const _Uty _Umax = _Adjust(_Uty(_Max));

	mov	eax, DWORD PTR __Max$[esp+16]
	cmovae	ebx, ecx
	cmp	eax, -2147483648			; 80000000H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$[esp+28], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	mov	DWORD PTR __Umin$1$[esp+16], ebx

; 1877 :         const _Uty _Umax = _Adjust(_Uty(_Max));

	lea	ecx, DWORD PTR [eax-2147483648]
	lea	esi, DWORD PTR [eax-2147483648]
	cmovae	esi, ecx

; 1878 : 
; 1879 :         _Uty _Uret;
; 1880 : 
; 1881 :         if (_Umax - _Umin == _Uty(-1)) {

	sub	esi, ebx
	cmp	esi, -1
	jne	SHORT $LN2@Eval
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3304 :             _Ret |= _Get_bits();

	lea	ecx, DWORD PTR __Rng$[esp+20]
	call	?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1882 :             _Uret = static_cast<_Uty>(_Rng._Get_all_bits());

	mov	edx, eax

; 1883 :         } else {

	jmp	SHORT $LN33@Eval
$LN2@Eval:
	push	ebp
	push	edi

; 1884 :             _Uret = static_cast<_Uty>(_Rng(static_cast<_Uty>(_Umax - _Umin + 1)));

	lea	ebp, DWORD PTR [esi+1]
	npad	6
$LL32@Eval:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3279 :             _Udiff _Ret  = 0; // random bits

	xor	edi, edi

; 3280 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

	xor	eax, eax

; 3281 : 
; 3282 :             while (_Mask < _Udiff(_Index - 1)) { // need more random bits

	test	esi, esi
	je	SHORT $LN36@Eval

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	mov	ecx, edx
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
	mov	edi, eax

; 3288 :                 _Mask |= _Bmask;

	or	eax, -1
$LN36@Eval:

; 3289 :             }
; 3290 : 
; 3291 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3292 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

	xor	edx, edx
	div	ebp
	mov	ecx, eax
	mov	ebx, edx
	xor	edx, edx
	mov	eax, edi
	div	ebp
	cmp	eax, ecx
	jb	SHORT $LN61@Eval
	mov	edx, DWORD PTR __Eng$[esp+24]
	cmp	ebx, esi
	jne	SHORT $LL32@Eval
$LN61@Eval:
	mov	ebx, DWORD PTR __Umin$1$[esp+24]

; 3293 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, edi
	xor	edx, edx
	pop	edi
	div	ebp
	pop	ebp
$LN33@Eval:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1887 :         return _Ty(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	ecx, DWORD PTR [edx+ebx]
	cmp	ecx, -2147483648			; 80000000H
	lea	edx, DWORD PTR [ecx-2147483648]
	lea	eax, DWORD PTR [ecx-2147483648]
	pop	esi
	cmovae	eax, edx
	pop	ebx

; 1888 :     }

	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
??$_Eval@V?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@ABEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@HH@Z ENDP ; std::uniform_int<int>::_Eval<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory

; 1871 :     }

	mov	eax, ecx
	ret	4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; _this$ = ecx

; 1947 :         return this->_Myptr();

	mov	eax, DWORD PTR [ecx]

; 1955 :         pointer _Ans   = get();
; 1956 :         this->_Myptr() = pointer();

	mov	DWORD PTR [ecx], 0

; 1957 :         return _Ans;
; 1958 :     }

	ret	0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get, COMDAT
; _this$ = ecx

; 1947 :         return this->_Myptr();

	mov	eax, DWORD PTR [ecx]

; 1948 :     }

	ret	0
?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 1933 :         if (get() != pointer()) {

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN22@unique_ptr

; 1768 :         delete _Ptr;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN22@unique_ptr:

; 1934 :             this->get_deleter()(get());
; 1935 :         }
; 1936 :     }

	ret	0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr, COMDAT
; _this$ = ecx

; 1831 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1832 :     }

	ret	0
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr, COMDAT
; _this$ = ecx

; 1827 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1828 :     }

	ret	0
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter, COMDAT
; _this$ = ecx

; 1819 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1820 :     }

	ret	0
?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT
; _this$ = ecx

; 1767 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 1768 :         delete _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	test	ecx, ecx
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Ptr$[esp-4], 1
	jmp	DWORD PTR [eax]
$LN3@operator:

; 1769 :     }

	ret	4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Storage_ptr$ = 12					; size = 4
___formal$ = 16						; size = 4
??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z PROC ; std::_Immortalize_impl<std::_Iostream_error_category>, COMDAT

; 420  :     _Iostream_error_category() noexcept { // default constructor

	mov	eax, DWORD PTR __Storage_ptr$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 421  :         _Addr = _Iostream_addr;

	mov	DWORD PTR [eax+4], 5

; 496  :     ::new (_Storage_ptr) _Ty();
; 497  :     return 1;

	mov	eax, 1

; 498  : }

	ret	12					; 0000000cH
??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ENDP ; std::_Immortalize_impl<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1025 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1026 :         _Left = _STD move(_Right);
; 1027 :     } else {
; 1028 :         (void) _Left; // TRANSITION, VSO#486357
; 1029 :         (void) _Right; // TRANSITION, VSO#486357
; 1030 :     }
; 1031 : }

	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z
_TEXT	SEGMENT
__Old_size$1$ = -12					; size = 4
tv501 = -8						; size = 4
__New_ptr$1$ = -4					; size = 4
tv500 = 8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
tv499 = 16						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
tv502 = 24						; size = 4
_<_Args_2>$ = 24					; size = 1
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>, COMDAT
; _this$ = ecx

; 3809 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 3810 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3811 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3812 :         auto& _My_data            = _Get_data();
; 3813 :         const size_type _Old_size = _My_data._Mysize;
; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	push	edi
	mov	edi, DWORD PTR __Size_increase$[esp+16]
	mov	edx, DWORD PTR [esi+16]
	sub	eax, edx
	mov	DWORD PTR __Old_size$1$[esp+20], edx
	cmp	eax, edi
	jb	$LN104@Reallocate

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	push	ebx
	lea	ebx, DWORD PTR [edx+edi]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, ebx
	or	edi, 15					; 0000000fH
	push	ebp

; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	ebp, DWORD PTR [esi+20]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edi, ecx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN25@Reallocate

; 3770 :             return _Max;

	mov	edi, ecx
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, ebp
	shr	eax, 1
	sub	ecx, eax
	cmp	ebp, ecx
	jbe	SHORT $LN26@Reallocate

; 3775 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN24@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;
; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	movsx	ecx, BYTE PTR _<_Args_2>$[esp+24]
	mov	DWORD PTR tv502[esp+24], ecx
	mov	ecx, DWORD PTR __Old_size$1$[esp+28]
	mov	DWORD PTR [esi+16], ebx
	mov	ebx, DWORD PTR _<_Args_0>$[esp+24]
	sub	ecx, ebx
	inc	ecx
	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR tv500[esp+24], ecx
	mov	ecx, DWORD PTR _<_Args_1>$[esp+24]
	lea	edi, DWORD PTR [eax+ebx]
	mov	DWORD PTR __New_ptr$1$[esp+28], eax
	add	ecx, edi
	mov	DWORD PTR tv501[esp+28], edi
	mov	DWORD PTR tv499[esp+24], ecx

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	push	ebx
	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN3@Reallocate

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR _<_Args_1>$[esp+36]
	push	DWORD PTR tv502[esp+40]
	push	DWORD PTR tv501[esp+48]
	call	_memset

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv500[esp+48]

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [edi+ebx]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	DWORD PTR tv499[esp+56]
	call	_memcpy

; 3829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [ebp+1]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 36					; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN80@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN77@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN80@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3837 :         return *this;

	mov	eax, DWORD PTR __New_ptr$1$[esp+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3837 :         return *this;

	mov	DWORD PTR [esi], eax
	mov	eax, esi
	pop	ebp
	pop	ebx
	pop	edi

; 3838 :     }

	pop	esi
	add	esp, 12					; 0000000cH
	ret	20					; 00000014H
$LN3@Reallocate:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR _<_Args_1>$[esp+36]
	push	DWORD PTR tv502[esp+40]
	push	edi
	call	_memset

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv500[esp+48]

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [ebx+esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	DWORD PTR tv499[esp+56]
	call	_memcpy

; 3837 :         return *this;

	mov	eax, DWORD PTR __New_ptr$1$[esp+64]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 36					; 00000024H

; 3837 :         return *this;

	mov	DWORD PTR [esi], eax
	mov	eax, esi
	pop	ebp
	pop	ebx
	pop	edi

; 3838 :     }

	pop	esi
	add	esp, 12					; 0000000cH
	ret	20					; 00000014H
$LN104@Reallocate:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN77@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN105@Reallocate:
$LN102@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Off$ = 20						; size = 4
__Count$ = 24						; size = 4
__Ch$ = 28						; size = 1
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z PROC ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator(), COMDAT
; _this$ = ecx

; 2817 :                 const size_type _Count, const _Elem _Ch) {

	push	ebx

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	ebx, DWORD PTR __Old_ptr$[esp]

; 2817 :                 const size_type _Count, const _Elem _Ch) {

	push	ebp

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	ebp, DWORD PTR __Off$[esp+4]

; 2817 :                 const size_type _Count, const _Elem _Ch) {

	push	esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[esp+8]

; 2817 :                 const size_type _Count, const _Elem _Ch) {

	push	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ebp
	push	ebx
	push	esi
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+24]

; 2818 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2819 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);

	lea	edi, DWORD PTR [esi+ebp]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	esi, DWORD PTR __Count$[esp+24]
	push	esi
	push	eax
	push	edi
	call	_memset

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	eax, DWORD PTR __Old_size$[esp+36]
	sub	eax, ebp
	inc	eax

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [ebx+ebp]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [edi+esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	call	_memcpy
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2821 :             },

	ret	24					; 00000018H
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBEXQADQBDIIID@Z ENDP ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 1087 :                             // note that this is an optimization for debug mode codegen;
; 1088 :                             // in release mode the BE removes all of this
; 1089 :     using _Val = typename _Alloc::value_type;
; 1090 :     if
; 1091 :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Val>, _Uses_default_destroy<_Alloc, _Val*>>) {
; 1092 :             (void) _First;
; 1093 :             (void) _Last;
; 1094 :             (void) _Al;
; 1095 :         }
; 1096 :     else {
; 1097 :         for (; _First != _Last; ++_First) {
; 1098 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1099 :         }
; 1100 :     }
; 1101 : }

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
;	COMDAT ??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>, COMDAT

; 62   :         return _Val.first;

	mov	eax, DWORD PTR __Val$[esp-4]

; 63   :     }

	ret	0
??$_Kfn@$$CBHH@?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@SAABHABU?$pair@$$CBHH@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Kfn<int const ,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<int const ,int>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
	mov	DWORD PTR [eax+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 352  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 353  :         _Pnode->_Isnil = true;
; 354  :         return _Pnode;
; 355  :     }

	ret	0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<int const ,int>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Pnavail
	mov	eax, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [eax]
	cdq

; 257  :     }

	ret	0
$LN3@Pnavail:

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	xor	eax, eax
	cdq

; 257  :     }

	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 251  :         --*_IPcount;

	mov	eax, DWORD PTR [ecx+48]
	dec	DWORD PTR [eax]

; 252  :         return (*_IPnext)++;

	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edx], ecx

; 253  :     }

	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 168  :         return xsputn(_Ptr, _Count);

	push	DWORD PTR __Count$[esp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Count$[esp]
	push	DWORD PTR __Ptr$[esp+4]
	mov	eax, DWORD PTR [eax+36]
	call	eax

; 169  :     }

	ret	12					; 0000000cH
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sputc
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	test	eax, eax
	jle	SHORT $LN3@sputc

; 251  :         --*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 252  :         return (*_IPnext)++;

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	al, BYTE PTR __Ch$[esp-4]
	mov	BYTE PTR [edx], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 164  :     }

	ret	4
$LN3@sputc:

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR __Ch$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	DWORD PTR __Ch$[esp-4], eax
	jmp	edx
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 121  :         return sync();

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+52]
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,int> >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@U?$pair@$$CBHH@std@@@std@@YAPAU?$pair@$$CBHH@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 188  :                                           // <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 189  : #if defined(_M_IX86) || defined(_M_X64)
; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	ecx, DWORD PTR __Bytes$[esp-4]
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@Deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, DWORD PTR __Ptr$[esp-4]
	add	ecx, 35					; 00000023H
	mov	edx, DWORD PTR [eax-4]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN13@Deallocate
	jmp	__invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 188  :                                           // <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 189  : #if defined(_M_IX86) || defined(_M_X64)
; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	edx, DWORD PTR __Ptr$[esp-4]
$LN13@Deallocate:

; 191  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 192  :     }
; 193  : #endif // defined(_M_IX86) || defined(_M_X64)
; 194  : 
; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	DWORD PTR __Bytes$[esp-4], ecx
	mov	DWORD PTR __Ptr$[esp-4], edx
	jmp	??3@YAXPAXI@Z				; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 172  : #if defined(_M_IX86) || defined(_M_X64)
; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	ecx, DWORD PTR __Bytes$[esp-4]
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN2@Allocate

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 93   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN11@Allocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 183  : }

	ret	0
$LN11@Allocate:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	jmp	__invalid_parameter_noinfo_noreturn
$LN2@Allocate:

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN3@Allocate

; 49   :         return ::operator new(_Bytes);

	mov	DWORD PTR __Bytes$[esp-4], ecx
	jmp	??2@YAPAXI@Z				; operator new
$LN3@Allocate:

; 179  :         return _Traits::_Allocate(_Bytes);
; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	eax, eax

; 183  : }

	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
tv450 = -4						; size = 4
__New_size$1$ = -4					; size = 4
__Old$1$ = 8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 3809 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ecx

; 3810 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3811 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3812 :         auto& _My_data            = _Get_data();
; 3813 :         const size_type _Old_size = _My_data._Mysize;
; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, DWORD PTR __Size_increase$[esp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	mov	ebx, DWORD PTR [esi+16]
	sub	eax, ebx
	cmp	eax, edx
	jb	$LN104@Reallocate

; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR [esi+20]
	add	edx, ebx
	push	edi

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, edx

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[esp+16], edx

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	edi, 15					; 0000000fH

; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[esp+12], eax

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edi, ecx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN25@Reallocate

; 3770 :             return _Max;

	mov	edi, ecx
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, eax
	shr	edx, 1
	sub	ecx, edx
	cmp	eax, ecx
	jbe	SHORT $LN26@Reallocate

; 3775 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN24@Reallocate:
	push	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	ebp, eax

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR [esi+20], edi
	mov	eax, DWORD PTR __New_size$1$[esp+20]
	mov	DWORD PTR [esi+16], eax

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR _<_Args_1>$[esp+16]
	lea	edi, DWORD PTR [ebx+ebp]
	add	eax, edi

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[esp+16], 16		; 00000010H
	mov	DWORD PTR tv450[esp+20], eax
	push	ebx
	jb	SHORT $LN3@Reallocate

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebp
	call	_memcpy
	push	DWORD PTR _<_Args_1>$[esp+28]
	lea	eax, DWORD PTR [ebx+ebp]
	push	DWORD PTR _<_Args_0>$[esp+32]
	push	eax
	call	_memcpy

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv450[esp+44]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H

; 3829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[esp+16]
	inc	ecx

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN80@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN77@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN80@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3837 :         return *this;

	mov	DWORD PTR [esi], ebp
	mov	eax, esi
	pop	ebp
	pop	edi
	pop	esi

; 3838 :     }

	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN3@Reallocate:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ebp
	call	_memcpy
	push	DWORD PTR _<_Args_1>$[esp+28]
	push	DWORD PTR _<_Args_0>$[esp+32]
	push	edi
	call	_memcpy

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv450[esp+44]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 3837 :         return *this;

	mov	eax, esi
	mov	DWORD PTR [esi], ebp
	pop	ebp
	pop	edi
	pop	esi

; 3838 :     }

	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN104@Reallocate:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN77@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN105@Reallocate:
$LN102@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$ = ecx

; 2618 :                 const size_type _Count) {

	push	esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[esp]

; 2618 :                 const size_type _Count) {

	push	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	edi, DWORD PTR __Old_size$[esp+4]
	push	edi
	push	DWORD PTR __Old_ptr$[esp+8]
	push	esi
	call	_memcpy

; 2619 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2620 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	add	edi, esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __Count$[esp+16]
	push	esi
	push	DWORD PTR __Ptr$[esp+20]
	push	edi
	call	_memcpy
	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi

; 2621 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2622 :             },

	ret	20					; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z
_TEXT	SEGMENT
tv489 = -4						; size = 4
__New_size$1$ = -4					; size = 4
__Old$1$ = 8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
tv491 = 20						; size = 4
_<_Args_1>$ = 20					; size = 1
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>, COMDAT
; _this$ = ecx

; 3809 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

	push	ecx

; 3810 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3811 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3812 :         auto& _My_data            = _Get_data();
; 3813 :         const size_type _Old_size = _My_data._Mysize;
; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, DWORD PTR __Size_increase$[esp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	mov	ebx, DWORD PTR [esi+16]
	sub	eax, ebx
	cmp	eax, edx
	jb	$LN104@Reallocate

; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	eax, DWORD PTR [esi+20]
	add	edx, ebx
	push	edi

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, edx

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[esp+16], edx

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	edi, 15					; 0000000fH

; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[esp+12], eax

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	cmp	edi, ecx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN25@Reallocate

; 3770 :             return _Max;

	mov	edi, ecx
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, eax
	shr	edx, 1
	sub	ecx, edx
	cmp	eax, ecx
	jbe	SHORT $LN26@Reallocate

; 3775 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN24@Reallocate:
	push	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	ebp, eax

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR [esi+20], edi
	mov	eax, DWORD PTR __New_size$1$[esp+20]
	mov	DWORD PTR [esi+16], eax

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	movsx	eax, BYTE PTR _<_Args_1>$[esp+16]
	mov	DWORD PTR tv491[esp+16], eax
	lea	edi, DWORD PTR [ebx+ebp]
	mov	eax, DWORD PTR _<_Args_0>$[esp+16]
	add	eax, edi

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[esp+16], 16		; 00000010H
	mov	DWORD PTR tv489[esp+20], eax
	push	ebx
	jb	SHORT $LN3@Reallocate

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebp
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR _<_Args_0>$[esp+28]
	lea	eax, DWORD PTR [ebx+ebp]
	push	DWORD PTR tv491[esp+32]
	push	eax
	call	_memset

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv489[esp+44]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 24					; 00000018H

; 3829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[esp+16]
	inc	ecx

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN80@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN77@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, edx
$LN80@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3837 :         return *this;

	mov	DWORD PTR [esi], ebp
	mov	eax, esi
	pop	ebp
	pop	edi
	pop	esi

; 3838 :     }

	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN3@Reallocate:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ebp
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR _<_Args_0>$[esp+28]
	push	DWORD PTR tv491[esp+32]
	push	edi
	call	_memset

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv489[esp+44]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 3837 :         return *this;

	mov	eax, esi
	mov	DWORD PTR [esi], ebp
	pop	ebp
	pop	edi
	pop	esi

; 3838 :     }

	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN104@Reallocate:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN77@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN105@Reallocate:
$LN102@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Count$ = 20						; size = 4
__Ch$ = 24						; size = 1
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z PROC ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator(), COMDAT
; _this$ = ecx

; 2643 :                 const _Elem _Ch) {

	push	esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[esp]

; 2643 :                 const _Elem _Ch) {

	push	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	edi, DWORD PTR __Old_size$[esp+4]
	push	edi
	push	DWORD PTR __Old_ptr$[esp+8]
	push	esi
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+16]

; 2644 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2645 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	add	edi, esi

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	esi, DWORD PTR __Count$[esp+16]
	push	esi
	push	eax
	push	edi
	call	_memset
	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi

; 2646 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2647 :             },

	ret	20					; 00000014H
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBEXQADQBDIID@Z ENDP ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__New_ptr$1$ = 8					; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 3782 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebx

; 3783 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 3784 :         // _Fn(_New_ptr, _New_size, _Args...)
; 3785 :         if (_New_size > max_size()) {

	mov	ebx, DWORD PTR __New_size$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebx, 2147483647				; 7fffffffH
	ja	$LN92@Reallocate

; 3787 :         }
; 3788 : 
; 3789 :         auto& _My_data                = _Get_data();
; 3790 :         const size_type _Old_capacity = _My_data._Myres;

	push	ebp
	mov	ebp, DWORD PTR [edi+20]
	push	esi

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	esi, ebx
	or	esi, 15					; 0000000fH
	cmp	esi, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN25@Reallocate

; 3770 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, ebp
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	ebp, eax
	jbe	SHORT $LN26@Reallocate

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN24@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	mov	ecx, edi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
	push	DWORD PTR _<_Args_0>$[esp+16]

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	DWORD PTR __New_ptr$1$[esp+20], eax

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax

; 3794 :         _My_data._Orphan_all();
; 3795 :         _My_data._Mysize = _New_size;

	mov	DWORD PTR [edi+16], ebx

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR [edi+20], esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	call	_memcpy

; 343  :         _Left = _Right;

	mov	esi, DWORD PTR __New_ptr$1$[esp+24]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0

; 3797 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [ebp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN76@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN73@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN76@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3805 :         return *this;

	mov	DWORD PTR [edi], esi
	mov	eax, edi
	pop	esi
	pop	ebp
	pop	edi

; 3806 :     }

	pop	ebx
	ret	12					; 0000000cH
$LN73@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN93@Reallocate:
$LN92@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN90@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$ = ecx

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	esi, DWORD PTR __New_ptr$[esp]

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

	push	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	edi, DWORD PTR __Count$[esp+4]
	push	edi
	push	DWORD PTR __Ptr$[esp+8]
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi

; 2697 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2698 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2699 :             },

	ret	12					; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z
_TEXT	SEGMENT
__New_ptr$1$ = 8					; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>, COMDAT
; _this$ = ecx

; 3782 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

	push	ebx

; 3783 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 3784 :         // _Fn(_New_ptr, _New_size, _Args...)
; 3785 :         if (_New_size > max_size()) {

	mov	ebx, DWORD PTR __New_size$[esp]
	push	edi
	mov	edi, ecx
	cmp	ebx, 2147483647				; 7fffffffH
	ja	$LN92@Reallocate

; 3787 :         }
; 3788 : 
; 3789 :         auto& _My_data                = _Get_data();
; 3790 :         const size_type _Old_capacity = _My_data._Myres;

	push	ebp
	mov	ebp, DWORD PTR [edi+20]
	push	esi

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	esi, ebx
	or	esi, 15					; 0000000fH
	cmp	esi, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN25@Reallocate

; 3770 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, ebp
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	ebp, eax
	jbe	SHORT $LN26@Reallocate

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN24@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	mov	ecx, edi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR _<_Args_0>$[esp+12]
	push	ebx
	push	ecx
	push	eax

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	DWORD PTR __New_ptr$1$[esp+24], eax

; 3794 :         _My_data._Orphan_all();
; 3795 :         _My_data._Mysize = _New_size;

	mov	DWORD PTR [edi+16], ebx

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR [edi+20], esi

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	call	_memset

; 343  :         _Left = _Right;

	mov	esi, DWORD PTR __New_ptr$1$[esp+24]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0

; 3797 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [ebp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN76@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN73@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN76@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3805 :         return *this;

	mov	DWORD PTR [edi], esi
	mov	eax, edi
	pop	esi
	pop	ebp
	pop	edi

; 3806 :     }

	pop	ebx
	ret	12					; 0000000cH
$LN73@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN93@Reallocate:
$LN92@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN90@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z PROC ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator(), COMDAT
; _this$ = ecx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp-4]

; 2718 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {

	push	esi

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	esi, DWORD PTR __New_ptr$[esp]

; 2718 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {

	push	edi

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	edi, DWORD PTR __Count$[esp+4]
	push	edi
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi

; 2719 :                 _Traits::assign(_New_ptr, _Count, _Ch);
; 2720 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2721 :             },

	ret	12					; 0000000cH
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBEXQADID@Z ENDP ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	cmovb	eax, ecx

; 29   : }

	ret	0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 824  :         _Ptr->~_Uty();
; 825  :     }

	ret	0
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 415  :     _Tree_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 415  :     _Tree_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ecx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	ret	12					; 0000000cH
??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Lbound@H@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??$_Lbound@H@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound<int>, COMDAT
; _this$ = ecx

; 1582 :         _Nodeptr _Wherenode = _Get_data()._Myhead; // end() if search fails

	mov	edx, DWORD PTR [ecx]

; 1583 :         _Nodeptr _Pnode     = _Wherenode->_Parent;

	mov	eax, DWORD PTR [edx+4]

; 1584 : 
; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN30@Lbound
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	ecx, DWORD PTR __Keyval$[esp-4]
	mov	ecx, DWORD PTR [ecx]
$LL2@Lbound:
	cmp	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1586 :             if (_Compare(_Key(_Pnode), _Keyval)) {

	jge	SHORT $LN4@Lbound

; 1587 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 1588 :             } else { // _Pnode not less than _Keyval, remember it

	jmp	SHORT $LN5@Lbound
$LN4@Lbound:

; 1589 :                 _Wherenode = _Pnode;

	mov	edx, eax

; 1590 :                 _Pnode     = _Pnode->_Left; // descend left subtree

	mov	eax, DWORD PTR [eax]
$LN5@Lbound:

; 1584 : 
; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Lbound
$LN30@Lbound:

; 1591 :             }
; 1592 :         }
; 1593 : 
; 1594 :         return _Wherenode; // return best remembered candidate
; 1595 :     }

	mov	eax, edx
	ret	4
??$_Lbound@H@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHH@std@@@std@@SAPAU?$pair@$$CBHH@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHH@std@@@std@@SAPAU?$pair@$$CBHH@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<int const ,int> *>::pointer_to, COMDAT

; 309  :         return _STD addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 310  :     }

	ret	0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHH@std@@@std@@SAPAU?$pair@$$CBHH@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<int const ,int> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 157  :     virtual __CLR_OR_THIS_CALL ~numpunct() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 224  :         _CSTD free((void*) _Grouping);

	push	DWORD PTR [esi+8]

; 157  :     virtual __CLR_OR_THIS_CALL ~numpunct() noexcept { // destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@

; 224  :         _CSTD free((void*) _Grouping);

	call	_free

; 225  :         _CSTD free((void*) _Falsename);

	push	DWORD PTR [esi+16]
	call	_free

; 226  :         _CSTD free((void*) _Truename);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN12@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = ecx

; 223  :     void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 224  :         _CSTD free((void*) _Grouping);

	push	DWORD PTR [esi+8]
	call	_free

; 225  :         _CSTD free((void*) _Falsename);

	push	DWORD PTR [esi+16]
	call	_free

; 226  :         _CSTD free((void*) _Truename);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 12					; 0000000cH
	pop	esi

; 227  :     }

	ret	0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 219  :         return string_type(_Truename);

	mov	edx, DWORD PTR [ecx+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 218  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const { // return name for true

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 218  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const { // return name for true

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	npad	1
$LL33@do_truenam:

; 301  :         return __builtin_strlen(_First);

	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL33@do_truenam
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 219  :         return string_type(_Truename);

	pop	edi
	mov	eax, esi
	pop	esi

; 220  :     }

	ret	4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 215  :         return string_type(_Falsename);

	mov	edx, DWORD PTR [ecx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 214  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const { // return name for false

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 214  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const { // return name for false

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	npad	1
$LL33@do_falsena:

; 301  :         return __builtin_strlen(_First);

	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL33@do_falsena
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 215  :         return string_type(_Falsename);

	pop	edi
	mov	eax, esi
	pop	esi

; 216  :     }

	ret	4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 211  :         return string(_Grouping);

	mov	edx, DWORD PTR [ecx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 210  :     virtual string __CLR_OR_THIS_CALL do_grouping() const { // return grouping string

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 210  :     virtual string __CLR_OR_THIS_CALL do_grouping() const { // return grouping string

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	npad	1
$LL33@do_groupin:

; 301  :         return __builtin_strlen(_First);

	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL33@do_groupin
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 211  :         return string(_Grouping);

	pop	edi
	mov	eax, esi
	pop	esi

; 212  :     }

	ret	4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 207  :         return _Kseparator;

	mov	al, BYTE PTR [ecx+13]

; 208  :     }

	ret	0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 203  :         return _Dp;

	mov	al, BYTE PTR [ecx+12]

; 204  :     }

	ret	0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
$T1 = -44						; size = 44
$T2 = -44						; size = 44
__Lobj$ = 8						; size = 4
__Isdef$ = 12						; size = 1
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<char>::_Init, COMDAT
; _this$ = ecx

; 179  :     void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { // initialize from _Lobj

	sub	esp, 44					; 0000002cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 116  :         return localeconv();

	call	_localeconv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 180  :         const lconv* _Ptr      = _Lobj._Getlconv();

	mov	ebp, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	lea	eax, DWORD PTR $T2[esp+60]
	push	eax
	call	__Getcvt
	lea	eax, DWORD PTR $T1[esp+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 183  :         _Grouping  = nullptr;

	mov	DWORD PTR [ebx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 184  :         _Falsename = nullptr;

	mov	DWORD PTR [ebx+16], 0

; 185  :         _Truename  = nullptr;

	mov	DWORD PTR [ebx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	call	__Getcvt
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	esi, OFFSET ??_C@_00CNPNBAHC@@
	cmp	BYTE PTR __Isdef$[esp+56], 0
	jne	SHORT $LN6@Init
	mov	esi, DWORD PTR [ebp+8]
$LN6@Init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, esi
	lea	ecx, DWORD PTR [edi+1]
$LL64@Init:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL64@Init
	sub	edi, ecx
	inc	edi

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
	call	_calloc
	mov	edx, eax
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	edx, edx
	je	$LN63@Init

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	test	edi, edi
	je	SHORT $LN15@Init
	mov	ecx, edx
	sub	ecx, esi
$LL16@Init:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL16@Init
$LN15@Init:

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	DWORD PTR [ebx+8], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_05LAPONLG@false@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	SHORT $LN63@Init

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, esi
$LL25@Init:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [edx+esi-1], cl
	sub	edi, 1
	jne	SHORT $LL25@Init

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [ebx+16], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_04LOAJBDKD@true@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	SHORT $LN63@Init

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, esi
$LL33@Init:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [edx+esi-1], cl
	sub	edi, 1
	jne	SHORT $LL33@Init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	cmp	BYTE PTR __Isdef$[esp+56], 0
	mov	DWORD PTR [ebx+20], eax

; 191  :         _Guard._Target = nullptr;
; 192  : 
; 193  :         if (_Isdef) { // apply defaults for required facets

	je	SHORT $LN2@Init

; 200  :     }

	pop	edi
	pop	esi
	mov	BYTE PTR [ebx+12], 46			; 0000002eH
	mov	al, 44					; 0000002cH
	pop	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3514 :         if (_Target) {

	mov	BYTE PTR [ebx+13], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 200  :     }

	pop	ebx
	add	esp, 44					; 0000002cH
	ret	8
$LN2@Init:

; 170  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	eax, DWORD PTR [ebp]
	pop	edi

; 200  :     }

	pop	esi

; 170  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ebx+12], al

; 171  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	eax, DWORD PTR [ebp+4]

; 200  :     }

	pop	ebp

; 171  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	al, BYTE PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3514 :         if (_Target) {

	mov	BYTE PTR [ebx+13], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 200  :     }

	pop	ebx
	add	esp, 44					; 0000002cH
	ret	8
$LN63@Init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 578  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN65@Init:
	int	3
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<char>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 157  :     virtual __CLR_OR_THIS_CALL ~numpunct() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 224  :         _CSTD free((void*) _Grouping);

	push	DWORD PTR [esi+8]

; 157  :     virtual __CLR_OR_THIS_CALL ~numpunct() noexcept { // destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@

; 224  :         _CSTD free((void*) _Grouping);

	call	_free

; 225  :         _CSTD free((void*) _Falsename);

	push	DWORD PTR [esi+16]
	call	_free

; 226  :         _CSTD free((void*) _Truename);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 159  :     }

	ret	0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T1 = -144						; size = 4
$T2 = -140						; size = 52
$T3 = -88						; size = 44
$T4 = -44						; size = 44
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 149  :         const locale* _Ploc = nullptr) { // return locale category mask and construct standard facet

	sub	esp, 144				; 00000090H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Ppf$[esp+148]
	mov	DWORD PTR $T1[esp+152], 0
	push	esi
	mov	esi, DWORD PTR __Ploc$[esp+152]
	push	edi

; 150  :         if (_Ppf != nullptr && *_Ppf == nullptr) {

	test	ebp, ebp
	je	$LN6@Getcat
	cmp	DWORD PTR [ebp], 0
	jne	$LN6@Getcat

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	test	ebx, ebx
	je	$LN4@Getcat
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	jne	SHORT $LN9@Getcat
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN14@Getcat
$LN9@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN14@Getcat
	lea	eax, DWORD PTR [ecx+28]
$LN14@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	push	eax
	lea	ecx, DWORD PTR $T2[esp+164]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [ebx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 144  :         : locale::facet(_Refs) { // construct from specified locale

	mov	DWORD PTR [ebx], OFFSET ??_7?$numpunct@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 116  :         return localeconv();

	call	_localeconv

; 112  :         return ::_Getcvt();

	lea	eax, DWORD PTR $T3[esp+160]
	push	eax
	call	__Getcvt
	lea	eax, DWORD PTR $T4[esp+164]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 183  :         _Grouping  = nullptr;

	mov	DWORD PTR [ebx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 184  :         _Falsename = nullptr;

	mov	DWORD PTR [ebx+16], 0

; 185  :         _Truename  = nullptr;

	mov	DWORD PTR [ebx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	call	__Getcvt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	1
	call	_calloc
	add	esp, 16					; 00000010H

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	$LN85@Getcat

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 6

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	BYTE PTR [eax], 0

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	DWORD PTR [ebx+8], eax

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_05LAPONLG@false@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	SHORT $LN85@Getcat

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, esi
	npad	6
$LL45@Getcat:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [edx+esi-1], cl
	sub	edi, 1
	jne	SHORT $LL45@Getcat

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [ebx+16], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_04LOAJBDKD@true@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	SHORT $LN85@Getcat

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, esi
	npad	2
$LL53@Getcat:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [edx+esi-1], cl
	sub	edi, 1
	jne	SHORT $LL53@Getcat
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [ebx+20], eax

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	lea	eax, DWORD PTR [edi+1]

; 195  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);

	mov	WORD PTR [ebx+12], 11310		; 00002c2eH

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	eax, DWORD PTR $T1[esp+160]
	xor	ebx, ebx
$LN5@Getcat:
	mov	DWORD PTR [ebp], ebx
	test	al, 1
	je	SHORT $LN6@Getcat
	lea	ecx, DWORD PTR $T2[esp+160]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN6@Getcat:

; 154  :     }

	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 4
	pop	ebx
	add	esp, 144				; 00000090H
	ret	0
$LN85@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 578  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN86@Getcat:
	int	3
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<char>::_Getcat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
$T1 = -44						; size = 44
$T2 = -44						; size = 44
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
__Isdef$ = 16						; size = 1
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	eax, DWORD PTR __Refs$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 143  :     numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)

	sub	esp, 44					; 0000002cH
	push	ebx
	mov	ebx, ecx
	push	ebp
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [ebx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 144  :         : locale::facet(_Refs) { // construct from specified locale

	mov	DWORD PTR [ebx], OFFSET ??_7?$numpunct@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 116  :         return localeconv();

	call	_localeconv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 180  :         const lconv* _Ptr      = _Lobj._Getlconv();

	mov	ebp, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	lea	eax, DWORD PTR $T2[esp+60]
	push	eax
	call	__Getcvt
	lea	eax, DWORD PTR $T1[esp+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 183  :         _Grouping  = nullptr;

	mov	DWORD PTR [ebx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 184  :         _Falsename = nullptr;

	mov	DWORD PTR [ebx+16], 0

; 185  :         _Truename  = nullptr;

	mov	DWORD PTR [ebx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	call	__Getcvt
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	esi, OFFSET ??_C@_00CNPNBAHC@@
	cmp	BYTE PTR __Isdef$[esp+56], 0
	jne	SHORT $LN12@numpunct
	mov	esi, DWORD PTR [ebp+8]
$LN12@numpunct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, esi
	lea	ecx, DWORD PTR [edi+1]
	npad	3
$LL71@numpunct:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL71@numpunct
	sub	edi, ecx
	inc	edi

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
	call	_calloc
	mov	edx, eax
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	edx, edx
	je	$LN70@numpunct

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	test	edi, edi
	je	SHORT $LN21@numpunct
	mov	ecx, edx
	sub	ecx, esi
$LL22@numpunct:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL22@numpunct
$LN21@numpunct:

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	DWORD PTR [ebx+8], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_05LAPONLG@false@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	mov	edx, eax
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	edx, edx
	je	SHORT $LN70@numpunct

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	ecx, edx
	sub	ecx, esi
$LL31@numpunct:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL31@numpunct

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [ebx+16], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	esi, OFFSET ??_C@_04LOAJBDKD@true@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	mov	edx, eax
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	edx, edx
	je	SHORT $LN70@numpunct

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	ecx, edx
	sub	ecx, esi
$LL39@numpunct:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL39@numpunct
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	cmp	BYTE PTR __Isdef$[esp+56], 0
	mov	DWORD PTR [ebx+20], edx

; 191  :         _Guard._Target = nullptr;
; 192  : 
; 193  :         if (_Isdef) { // apply defaults for required facets

	je	SHORT $LN8@numpunct
	pop	edi

; 194  :             // _Grouping = _Maklocstr("", static_cast<char *>(nullptr), _Cvt);
; 195  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);
; 196  :             _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);

	mov	al, 44					; 0000002cH
	mov	BYTE PTR [ebx+12], 46			; 0000002eH

; 146  :     }

	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3514 :         if (_Target) {

	mov	BYTE PTR [ebx+13], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 146  :     }

	mov	eax, ebx
	pop	ebp
	pop	ebx
	add	esp, 44					; 0000002cH
	ret	12					; 0000000cH
$LN8@numpunct:

; 170  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	ecx, DWORD PTR [ebp]
	pop	edi

; 146  :     }

	pop	esi

; 170  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [ebx+12], cl

; 171  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	ecx, DWORD PTR [ebp+4]

; 146  :     }

	pop	ebp

; 171  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	al, BYTE PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3514 :         if (_Target) {

	mov	BYTE PTR [ebx+13], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 146  :     }

	mov	eax, ebx
	pop	ebx
	add	esp, 44					; 0000002cH
	ret	12					; 0000000cH
$LN70@numpunct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 578  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN72@numpunct:
	int	3
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<char>::numpunct<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx

; 130  :         return do_truename();

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[esp-4]
	call	DWORD PTR [edx+28]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 131  :     }

	ret	4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx

; 126  :         return do_falsename();

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[esp-4]
	call	DWORD PTR [edx+24]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 127  :     }

	ret	4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 122  :         return do_grouping();

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[esp-4]
	call	DWORD PTR [edx+20]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 123  :     }

	ret	4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 118  :         return do_thousands_sep();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	jmp	eax
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 114  :         return do_decimal_point();

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	jmp	eax
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T1 = -152						; size = 4
__Lock$2 = -152						; size = 4
__Lock$3 = -148						; size = 4
__Loc$GSCopy$1$ = -144					; size = 4
$T4 = -140						; size = 52
$T5 = -88						; size = 44
$T6 = -44						; size = 44
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 434  : { // get facet reference from locale

	sub	esp, 152				; 00000098H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Loc$[esp+160]

; 435  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	lea	ecx, DWORD PTR __Lock$2[esp+164]
	push	edi
	xor	ebx, ebx
	mov	DWORD PTR __Loc$GSCopy$1$[esp+168], esi
	push	ebx
	mov	DWORD PTR $T1[esp+172], ebx
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	mov	edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id

; 436  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	ebp, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	test	edi, edi
	jne	SHORT $LN9@use_facet

; 100  :                 _BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$3[esp+172]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 101  :                 if (_Id == 0) {

	cmp	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, ebx ; std::numpunct<char>::id
	jne	SHORT $LN10@use_facet

; 102  :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, eax ; std::numpunct<char>::id
$LN10@use_facet:

; 103  :                 }
; 104  :                 _END_LOCK()

	lea	ecx, DWORD PTR __Lock$3[esp+168]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
$LN9@use_facet:

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN17@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	test	esi, esi
	jne	$LN135@use_facet
	jmp	SHORT $LN150@use_facet
$LN17@use_facet:

; 380  :     }
; 381  : 
; 382  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	esi, esi
$LN150@use_facet:

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [ecx+20], bl
	je	SHORT $LN15@use_facet

; 385  :             return _Facptr; // found facet or not transparent
; 386  :         } else { // look in current locale
; 387  :             locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 388  :             return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] // get from current locale

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN151@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 437  : 
; 438  :     const size_t _Id         = _Facet::id;
; 439  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 440  : 
; 441  :     if (_Pf == nullptr) {

	test	esi, esi
	jne	$LN135@use_facet
$LN151@use_facet:

; 442  :         if (_Psave != nullptr) {

	test	ebp, ebp
	je	SHORT $LN3@use_facet

; 443  :             _Pf = _Psave; // lazy facet already allocated

	mov	esi, ebp

; 444  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	jmp	$LN135@use_facet
$LN3@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	$LN24@use_facet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	ecx, DWORD PTR __Loc$GSCopy$1$[esp+168]
	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	jne	SHORT $LN29@use_facet
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN34@use_facet
$LN29@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN34@use_facet
	lea	eax, DWORD PTR [ecx+28]
$LN34@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	push	eax
	lea	ecx, DWORD PTR $T4[esp+172]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 144  :         : locale::facet(_Refs) { // construct from specified locale

	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 116  :         return localeconv();

	call	_localeconv

; 112  :         return ::_Getcvt();

	lea	eax, DWORD PTR $T5[esp+168]
	push	eax
	call	__Getcvt
	lea	eax, DWORD PTR $T6[esp+172]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 183  :         _Grouping  = nullptr;

	mov	DWORD PTR [esi+8], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 184  :         _Falsename = nullptr;

	mov	DWORD PTR [esi+16], ebx

; 185  :         _Truename  = nullptr;

	mov	DWORD PTR [esi+20], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 112  :         return ::_Getcvt();

	call	__Getcvt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	1
	call	_calloc
	add	esp, 16					; 00000010H

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	$LN152@use_facet

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	BYTE PTR [eax], bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	edi, OFFSET ??_C@_05LAPONLG@false@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	ebx, 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 188  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	mov	DWORD PTR [esi+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	ebx
	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	$LN152@use_facet

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, edi
	npad	6
$LL65@use_facet:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+1]
	mov	BYTE PTR [edx+edi-1], cl
	sub	ebx, 1
	jne	SHORT $LL65@use_facet

; 573  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	ebx, 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 189  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [esi+16], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	push	1
	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	edi, OFFSET ??_C@_04LOAJBDKD@true@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 575  :     _Elem* _Ptrdest = (_Elem*) _calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__);

	call	_calloc
	add	esp, 8

; 576  : 
; 577  :     if (!_Ptrdest) {

	test	eax, eax
	je	SHORT $LN152@use_facet

; 579  :     }
; 580  : 
; 581  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	edx, eax
	sub	edx, edi
	npad	2
$LL73@use_facet:

; 582  :         *_Ptrnext = (_Elem)(unsigned char) *_Ptr;

	mov	cl, BYTE PTR [edi]
	lea	edi, DWORD PTR [edi+1]
	mov	BYTE PTR [edx+edi-1], cl
	sub	ebx, 1
	jne	SHORT $LL73@use_facet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 190  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	DWORD PTR [esi+20], eax

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	mov	ebx, 1

; 195  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);

	mov	WORD PTR [esi+12], 11310		; 00002c2eH

; 151  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	jmp	SHORT $LN25@use_facet
$LN24@use_facet:
	xor	esi, esi
$LN25@use_facet:
	test	bl, 1
	je	SHORT $LN26@use_facet
	lea	ecx, DWORD PTR $T4[esp+168]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN26@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 457  :             _Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 458  : #endif // defined(_M_CEE)
; 459  : 
; 460  :             _Pfmod->_Incref();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [edx+4]

; 461  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<char> >::_Psave
$LN135@use_facet:

; 462  :             _Pf                       = _Psave;
; 463  : 
; 464  :             (void) _Psave_guard.release();
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$2[esp+168]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 152				; 00000098H
	ret	0
$LN152@use_facet:

; 578  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN153@use_facet:
	int	3
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = ecx

; 583  :         return _Failed;

	mov	al, BYTE PTR [ecx]

; 584  :     }

	ret	0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 575  :         return *this;

	mov	eax, ecx

; 576  :     }

	ret	0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 571  :         return *this;

	mov	eax, ecx

; 572  :     }

	ret	0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 1
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = ecx

; 562  :     ostreambuf_iterator& operator=(_Elem _Right) { // store element and increment

	push	esi
	mov	esi, ecx

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN3@operator

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	test	eax, eax
	jle	SHORT $LN7@operator

; 251  :         --*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 252  :         return (*_IPnext)++;

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	al, BYTE PTR __Right$[esp]
	mov	BYTE PTR [edx], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	jmp	SHORT $LN8@operator
$LN7@operator:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR __Right$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	push	eax
	call	edx
$LN8@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	jne	SHORT $LN24@operator
$LN3@operator:

; 564  :             _Failed = true;

	mov	BYTE PTR [esi], 1
$LN24@operator:

; 565  :         }
; 566  : 
; 567  :         return *this;
; 568  :     }

	mov	eax, esi
	pop	esi
	ret	4
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 555  :         : _Failed(false), _Strbuf(_Sb) { // construct from stream buffer _Sb

	mov	eax, DWORD PTR __Sb$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 556  :     }

	mov	eax, ecx
	mov	BYTE PTR [ecx], 0
	ret	4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN10@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 1
__Count$ = 28						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1507 :     _OutIt __CLRCALL_OR_CDECL _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { // put _Count * _Ch to _Dest

	push	esi

; 1508 :         for (; 0 < _Count; --_Count, (void) ++_Dest) {

	mov	esi, DWORD PTR __Dest$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Count$[esp+4]
	test	edi, edi
	je	SHORT $LN3@Rep
	push	ebx
	mov	bl, BYTE PTR __Ch$[esp+8]
$LL4@Rep:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	test	esi, esi
	je	SHORT $LN12@Rep

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@Rep
	mov	ecx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [ecx]

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	test	eax, eax
	jle	SHORT $LN16@Rep

; 251  :         --*_IPcount;

	dec	eax
	mov	DWORD PTR [ecx], eax

; 252  :         return (*_IPnext)++;

	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	BYTE PTR [edx], bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	jmp	SHORT $LN17@Rep
$LN16@Rep:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	mov	edx, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	push	eax
	call	edx
$LN17@Rep:

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	mov	esi, DWORD PTR __Dest$[esp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	jne	SHORT $LN2@Rep
$LN12@Rep:

; 564  :             _Failed = true;

	mov	BYTE PTR __Dest$[esp+8], 1
$LN2@Rep:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1508 :         for (; 0 < _Count; --_Count, (void) ++_Dest) {

	sub	edi, 1
	jne	SHORT $LL4@Rep
	pop	ebx
$LN3@Rep:

; 1509 :             *_Dest = _Ch;
; 1510 :         }
; 1511 : 
; 1512 :         return _Dest;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 1513 :     }

	ret	0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Ch$1$ = 28						; size = 1
__Count$ = 28						; size = 4
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1499 :         _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { // put [_Ptr, _Ptr + _Count) to _Dest

	push	esi

; 1500 :         for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {

	mov	esi, DWORD PTR __Dest$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Count$[esp+4]
	test	edi, edi
	je	SHORT $LN3@Put
	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp+8]
$LL4@Put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	test	esi, esi
	je	SHORT $LN12@Put

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	eax, DWORD PTR [esi+32]

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	mov	cl, BYTE PTR [ebx]
	mov	BYTE PTR __Ch$1$[esp+8], cl

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@Put
	mov	edx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [edx]

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	test	eax, eax
	jle	SHORT $LN16@Put

; 251  :         --*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 252  :         return (*_IPnext)++;

	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	al, BYTE PTR __Ch$1$[esp+8]
	mov	BYTE PTR [edx], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	jmp	SHORT $LN17@Put
$LN16@Put:
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 163  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	ecx, esi
	push	eax
	call	edx
$LN17@Put:

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	mov	esi, DWORD PTR __Dest$[esp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 563  :         if (_Strbuf == nullptr || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	jne	SHORT $LN2@Put
$LN12@Put:

; 564  :             _Failed = true;

	mov	BYTE PTR __Dest$[esp+8], 1
$LN2@Put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1500 :         for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {

	inc	ebx
	sub	edi, 1
	jne	SHORT $LL4@Put
	pop	ebx
$LN3@Put:

; 1501 :             *_Dest = *_Ptr;
; 1502 :         }
; 1503 : 
; 1504 :         return _Dest;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 1505 :     }

	ret	0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
__Kseparator$1$ = -89					; size = 1
__Prefix$1$ = -88					; size = 4
__Pg$1$ = -84						; size = 4
__Ctype_fac$1$ = -84					; size = 4
__Count$GSCopy$2$ = -80					; size = 4
tv1357 = -80						; size = 4
$T1 = -80						; size = 8
$T2 = -80						; size = 8
$T3 = -80						; size = 8
__Iosbase$GSCopy$1$ = -72				; size = 4
__Old_capacity$1$ = -68					; size = 4
$T4 = -68						; size = 8
$T5 = -68						; size = 8
$T6 = -68						; size = 8
$T7 = -68						; size = 8
$T8 = -68						; size = 8
tv1366 = -60						; size = 4
___$ReturnUdt$GSCopy$1$ = -56				; size = 4
__Groupstring$ = -52					; size = 24
__Grouping$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1451 :         size_t _Count) const { // put formatted integer to _Dest

	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+92], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+88]
	mov	edx, DWORD PTR __Iosbase$[esp+88]
	push	ebx
	mov	ebx, DWORD PTR __Count$[esp+92]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+96], eax
	mov	DWORD PTR __Iosbase$GSCopy$1$[esp+96], edx
	push	ebp
	mov	ebp, DWORD PTR __Buf$[esp+96]
	push	esi
	push	edi

; 1452 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

	test	ebx, ebx
	je	SHORT $LN14@Iput
	mov	al, BYTE PTR [ebp]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN13@Iput
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN14@Iput
$LN13@Iput:
	mov	edi, 1
	jmp	SHORT $LN377@Iput
$LN14@Iput:
	xor	edi, edi
$LN377@Iput:

; 1453 :         if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1454 :             && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

	mov	eax, DWORD PTR [edx+20]
	and	eax, 3584				; 00000e00H
	mov	DWORD PTR __Prefix$1$[esp+108], edi
	cmp	eax, 2048				; 00000800H
	jne	SHORT $LN4@Iput
	lea	eax, DWORD PTR [edi+2]
	cmp	eax, ebx
	ja	SHORT $LN4@Iput
	cmp	BYTE PTR [edi+ebp], 48			; 00000030H
	jne	SHORT $LN4@Iput
	mov	cl, BYTE PTR [edi+ebp+1]
	cmp	cl, 120					; 00000078H
	je	SHORT $LN5@Iput
	cmp	cl, 88					; 00000058H
	jne	SHORT $LN4@Iput
$LN5@Iput:

; 1455 :             _Prefix += 2;

	mov	edi, eax
	mov	DWORD PTR __Prefix$1$[esp+108], edi
$LN4@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR [edx+48]
	mov	esi, DWORD PTR [eax+4]

; 272  :         _Ptr->_Incref();

	mov	ecx, esi
	mov	DWORD PTR $T3[esp+112], esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1458 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T3[esp+108]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$1$[esp+108], eax
	test	esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	je	SHORT $LN27@Iput

; 360  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN27@Iput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN27@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1459 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

	push	0
	push	ebx
	lea	ecx, DWORD PTR __Groupstring$[esp+116]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	mov	ecx, DWORD PTR __Ctype_fac$1$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1460 :         _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	lea	eax, DWORD PTR [ebx+ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	mov	edx, DWORD PTR [ecx]
	push	eax
	push	ebp
	call	DWORD PTR [edx+28]

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	edx, DWORD PTR __Iosbase$GSCopy$1$[esp+108]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[esp+112], ecx

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1462 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T2[esp+108]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	mov	ecx, DWORD PTR $T2[esp+116]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1462 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	add	esp, 4
	mov	ebp, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	test	ecx, ecx
	je	SHORT $LN51@Iput

; 360  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN51@Iput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN51@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 122  :         return do_grouping();

	mov	eax, DWORD PTR [ebp]
	lea	ecx, DWORD PTR __Grouping$[esp+108]
	push	ecx
	mov	ecx, ebp
	call	DWORD PTR [eax+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Grouping$[esp+128], 16	; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	esi, DWORD PTR __Grouping$[esp+108]

; 2024 :         if (_Large_string_engaged()) {

	cmovae	esi, DWORD PTR __Grouping$[esp+108]
	mov	DWORD PTR __Pg$1$[esp+108], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1465 :         if (*_Pg != CHAR_MAX && '\0' < *_Pg) { // grouping specified, add thousands separators

	mov	al, BYTE PTR [esi]
	cmp	al, 127					; 0000007fH
	je	$LN375@Iput
	test	al, al
	jle	$LN375@Iput

; 118  :         return do_thousands_sep();

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 1466 :             const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	BYTE PTR __Kseparator$1$[esp+108], al

; 1467 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && (size_t) *_Pg < _Count - _Prefix) { // insert thousands separator

	mov	al, BYTE PTR [esi]
	cmp	al, 127					; 0000007fH
	je	$LN375@Iput
	mov	ebp, DWORD PTR __Groupstring$[esp+108]
$LL2@Iput:
	test	al, al
	jle	$LN3@Iput
	movsx	ecx, al
	mov	eax, ebx
	sub	eax, edi
	cmp	ecx, eax
	jae	$LN3@Iput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2036 :         if (_Mysize < _Off) {

	mov	edi, DWORD PTR __Groupstring$[esp+124]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1468 :                 _Count -= *_Pg;

	sub	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2036 :         if (_Mysize < _Off) {

	cmp	edi, ebx
	jb	$LN369@Iput

; 2805 :         const size_type _Old_size = _My_data._Mysize;

	mov	ecx, DWORD PTR __Groupstring$[esp+128]
	mov	eax, ecx
	sub	eax, edi
	mov	DWORD PTR __Old_capacity$1$[esp+108], ecx

; 2806 :         if (_Count <= _My_data._Myres - _Old_size) {

	cmp	eax, 1
	jb	SHORT $LN71@Iput

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2807 :             _My_data._Mysize        = _Old_size + _Count;

	lea	eax, DWORD PTR [edi+1]

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	esi, DWORD PTR __Groupstring$[esp+108]

; 2807 :             _My_data._Mysize        = _Old_size + _Count;

	mov	DWORD PTR __Groupstring$[esp+124], eax

; 2015 :         if (_Large_string_engaged()) {

	cmovae	esi, ebp

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	sub	edi, ebx

; 2809 :             _Elem* const _Insert_at = _Old_ptr + _Off;

	add	esi, ebx

; 2810 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	edi

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	edi
	push	esi

; 2810 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	lea	eax, DWORD PTR [esi+1]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	eax
	call	_memmove

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Kseparator$1$[esp+120]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [esi], cl

; 2812 :             return *this;

	mov	ebp, DWORD PTR __Groupstring$[esp+108]
	jmp	$LN95@Iput
$LN71@Iput:

; 3813 :         const size_type _Old_size = _My_data._Mysize;

	mov	eax, 2147483647				; 7fffffffH
	sub	eax, edi

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	cmp	eax, 1
	jb	$LN370@Iput

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	esi, DWORD PTR [edi+1]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN116@Iput

; 3770 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN115@Iput
$LN116@Iput:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN117@Iput

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN115@Iput
$LN117@Iput:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN115@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	push	eax
	lea	ecx, DWORD PTR __Groupstring$[esp+112]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	ebp, eax

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR __Groupstring$[esp+128], esi
	lea	eax, DWORD PTR [edi+1]

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	sub	edi, ebx
	mov	DWORD PTR __Groupstring$[esp+124], eax
	movsx	eax, BYTE PTR __Kseparator$1$[esp+108]
	mov	DWORD PTR tv1366[esp+108], eax
	lea	esi, DWORD PTR [edi+1]

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	edi, DWORD PTR __Old_capacity$1$[esp+108]
	mov	DWORD PTR tv1357[esp+108], esi
	push	ebx
	cmp	edi, 16					; 00000010H
	jb	SHORT $LN94@Iput

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR __Groupstring$[esp+112]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ebp
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	cl, BYTE PTR tv1366[esp+120]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv1357[esp+120]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [ebx+esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	lea	eax, DWORD PTR [ebp+1]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	BYTE PTR [ebx+ebp], cl

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	eax, ebx
	push	eax
	call	_memcpy

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	inc	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edi, 4096				; 00001000H
	jb	SHORT $LN171@Iput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [esi-4]
	add	edi, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	$LN352@Iput

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, ecx
$LN171@Iput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edi
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3832 :         } else {

	jmp	SHORT $LN378@Iput
$LN94@Iput:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	lea	eax, DWORD PTR __Groupstring$[esp+112]
	push	eax
	push	ebp
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	cl, BYTE PTR tv1366[esp+120]
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR __Groupstring$[esp+120]
	add	eax, ebx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	BYTE PTR [ebx+ebp], cl

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	eax
	lea	eax, DWORD PTR [ebp+1]
	add	eax, ebx
	push	eax
	call	_memcpy
	add	esp, 24					; 00000018H
$LN378@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1470 :                 if ('\0' < _Pg[1]) {

	mov	DWORD PTR __Groupstring$[esp+108], ebp
$LN95@Iput:
	mov	esi, DWORD PTR __Pg$1$[esp+108]
	cmp	BYTE PTR [esi+1], 0
	lea	eax, DWORD PTR [esi+1]
	mov	edi, DWORD PTR __Prefix$1$[esp+108]
	cmovg	esi, eax
	mov	DWORD PTR __Pg$1$[esp+108], esi
	mov	al, BYTE PTR [esi]
	cmp	al, 127					; 0000007fH
	jne	$LL2@Iput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	jmp	SHORT $LN3@Iput
$LN375@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1467 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && (size_t) *_Pg < _Count - _Prefix) { // insert thousands separator

	mov	ebp, DWORD PTR __Groupstring$[esp+108]
$LN3@Iput:

; 1478 :             _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Count ? 0 : (size_t) _Iosbase.width() - _Count;

	mov	ecx, DWORD PTR __Iosbase$GSCopy$1$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3264 :         return _Get_data()._Mysize;

	mov	eax, DWORD PTR __Groupstring$[esp+124]
	mov	DWORD PTR __Count$GSCopy$2$[esp+108], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1478 :             _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Count ? 0 : (size_t) _Iosbase.width() - _Count;

	cmp	DWORD PTR [ecx+36], 0
	mov	esi, DWORD PTR [ecx+32]
	jl	SHORT $LN16@Iput
	jg	SHORT $LN374@Iput
	test	esi, esi
	je	SHORT $LN16@Iput
$LN374@Iput:
	cmp	esi, eax
	jbe	SHORT $LN16@Iput
	sub	esi, eax
	jmp	SHORT $LN17@Iput
$LN16@Iput:
	xor	esi, esi
$LN17@Iput:

; 1479 : 
; 1480 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [ecx+20]

; 1481 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

	mov	ebx, DWORD PTR _this$[esp+104]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN10@Iput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN373@Iput

; 1482 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	DWORD PTR __Fill$[esp+108]
	lea	eax, DWORD PTR $T8[esp+116]
	push	DWORD PTR __Dest$[esp+116]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	ebx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1483 :             _Fillcount = 0;

	xor	esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+152], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1484 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edi
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+132], edx
	mov	ecx, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+136]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1484 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T7[esp+148]
	mov	DWORD PTR __Dest$[esp+148], ecx
	push	eax
	push	ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 48					; 00000030H
	jmp	$LN11@Iput
$LN373@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1486 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1486 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[esp+116]
	lea	eax, DWORD PTR $T6[esp+120]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1487 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	DWORD PTR __Fill$[esp+132]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+136], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	DWORD PTR __Dest$[esp+144], eax
	lea	eax, DWORD PTR $T5[esp+144]
	push	ecx
	push	eax
	push	ebx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 48					; 00000030H

; 1488 :             _Fillcount = 0;

	xor	esi, esi

; 1489 :         } else {

	jmp	SHORT $LN11@Iput
$LN10@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1490 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1490 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[esp+116]
	lea	eax, DWORD PTR $T4[esp+120]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
$LN11@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3177 :         auto& _My_data = _Get_data();

	mov	edx, DWORD PTR [eax]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1493 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	ebp, DWORD PTR __Count$GSCopy$2$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3177 :         auto& _My_data = _Get_data();

	mov	DWORD PTR __Dest$[esp+104], edx
	mov	ecx, DWORD PTR [eax+4]

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1493 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	sub	ebp, edi
	push	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3181 :         return _My_data._Myptr()[_Off];

	add	eax, edi
	mov	DWORD PTR __Dest$[esp+112], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1493 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T1[esp+124]
	push	eax
	push	ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	edx, DWORD PTR __Iosbase$GSCopy$1$[esp+132]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1495 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	push	esi
	push	DWORD PTR __Fill$[esp+132]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+140]
	mov	DWORD PTR __Dest$[esp+136], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
	push	esi
	push	ebx
	mov	DWORD PTR __Dest$[esp+156], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR [edx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1495 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Grouping$[esp+176]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1495 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	add	esp, 48					; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN302@Iput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Grouping$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN301@Iput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN352@Iput
$LN301@Iput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN302@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Groupstring$[esp+128]

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR __Grouping$[esp+124], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR __Grouping$[esp+128], 15	; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR __Grouping$[esp+108], 0

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN356@Iput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN355@Iput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN352@Iput
$LN355@Iput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN356@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1496 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+108]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 92					; 0000005cH
	ret	0
$LN370@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN369@Iput:

; 2037 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN352@Iput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN376@Iput:
	int	3
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1423 :         char* _Ptr = _Fmt;
; 1424 :         *_Ptr++    = '%';
; 1425 : 
; 1426 :         if (_Flags & ios_base::showpos) {

	mov	eax, DWORD PTR __Flags$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Fmt$[esp]
	push	edi
	mov	BYTE PTR [esi], 37			; 00000025H
	lea	ecx, DWORD PTR [esi+1]
	test	al, 32					; 00000020H
	je	SHORT $LN2@Ifmt

; 1427 :             *_Ptr++ = '+';

	mov	BYTE PTR [ecx], 43			; 0000002bH
	inc	ecx
$LN2@Ifmt:

; 1428 :         }
; 1429 : 
; 1430 :         if (_Flags & ios_base::showbase) {

	test	al, 8
	je	SHORT $LN3@Ifmt

; 1431 :             *_Ptr++ = '#';

	mov	BYTE PTR [ecx], 35			; 00000023H
	inc	ecx
$LN3@Ifmt:

; 1432 :         }
; 1433 : 
; 1434 :         if (_Spec[0] != 'L') {

	mov	edi, DWORD PTR __Spec$[esp+4]
	lea	edx, DWORD PTR [ecx+1]
	push	ebx
	mov	bl, BYTE PTR [edi]
	cmp	bl, 76					; 0000004cH
	je	SHORT $LN4@Ifmt

; 1435 :             *_Ptr++ = _Spec[0]; // qualifier

	mov	BYTE PTR [ecx], bl

; 1436 :         } else { // change L to I64

	jmp	SHORT $LN5@Ifmt
$LN4@Ifmt:

; 1437 :             *_Ptr++ = 'I';

	mov	BYTE PTR [ecx], 73			; 00000049H

; 1438 :             *_Ptr++ = '6';

	mov	WORD PTR [edx], 13366			; 00003436H

; 1439 :             *_Ptr++ = '4';

	add	edx, 2
$LN5@Ifmt:

; 1440 :         }
; 1441 : 
; 1442 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

	mov	ecx, eax
	and	ecx, 3584				; 00000e00H
	pop	ebx

; 1443 :         *_Ptr++                       = _Basefield == ios_base::oct ? 'o'

	cmp	ecx, 1024				; 00000400H
	jne	SHORT $LN9@Ifmt
	mov	al, 111					; 0000006fH
	mov	BYTE PTR [edx], al

; 1444 :                                               : _Basefield != ios_base::hex ? _Spec[1] // 'd' or 'u'
; 1445 :                                                                             : _Flags & ios_base::uppercase ? 'X' : 'x';
; 1446 :         *_Ptr = '\0';
; 1447 :         return _Fmt;

	mov	eax, esi
	pop	edi
	mov	BYTE PTR [edx+1], 0
	pop	esi

; 1448 :     }

	ret	0
$LN9@Ifmt:

; 1443 :         *_Ptr++                       = _Basefield == ios_base::oct ? 'o'

	cmp	ecx, 2048				; 00000800H
	je	SHORT $LN7@Ifmt
	mov	al, BYTE PTR [edi+1]
	mov	BYTE PTR [edx], al

; 1444 :                                               : _Basefield != ios_base::hex ? _Spec[1] // 'd' or 'u'
; 1445 :                                                                             : _Flags & ios_base::uppercase ? 'X' : 'x';
; 1446 :         *_Ptr = '\0';
; 1447 :         return _Fmt;

	mov	eax, esi
	pop	edi
	mov	BYTE PTR [edx+1], 0
	pop	esi

; 1448 :     }

	ret	0
$LN7@Ifmt:

; 1443 :         *_Ptr++                       = _Basefield == ios_base::oct ? 'o'

	shl	al, 3
	not	al
	and	al, 32					; 00000020H
	or	al, 88					; 00000058H
	mov	BYTE PTR [edx], al

; 1444 :                                               : _Basefield != ios_base::hex ? _Spec[1] // 'd' or 'u'
; 1445 :                                                                             : _Flags & ios_base::uppercase ? 'X' : 'x';
; 1446 :         *_Ptr = '\0';
; 1447 :         return _Fmt;

	mov	eax, esi
	pop	edi
	mov	BYTE PTR [edx+1], 0
	pop	esi

; 1448 :     }

	ret	0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
_TEXT	SEGMENT
__Kseparator$1$ = -89					; size = 1
__Prefix$1$ = -88					; size = 4
tv1440 = -84						; size = 4
$T1 = -84						; size = 8
$T2 = -84						; size = 8
$T3 = -84						; size = 8
$T4 = -84						; size = 8
$T5 = -84						; size = 8
$T6 = -84						; size = 8
$T7 = -84						; size = 8
$T8 = -84						; size = 8
__Dp$ = -76						; size = 2
__Iosbase$GSCopy$1$ = -72				; size = 4
tv1448 = -68						; size = 4
__Eoff$1$ = -68						; size = 4
__Pg$1$ = -64						; size = 4
__Ctype_fac$1$ = -64					; size = 4
__Old_capacity$1$ = -60					; size = 4
___$ReturnUdt$GSCopy$1$ = -56				; size = 4
__Groupstring$ = -52					; size = 24
__Grouping$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1361 :         size_t _Count) const { // put formatted floating-point to _Dest

	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+92], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+88]
	mov	edx, DWORD PTR __Iosbase$[esp+88]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Count$[esp+100]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+104], eax
	mov	DWORD PTR __Iosbase$GSCopy$1$[esp+104], edx
	push	edi
	mov	edi, DWORD PTR __Buf$[esp+104]

; 1362 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

	test	esi, esi
	je	SHORT $LN16@Fput
	mov	al, BYTE PTR [edi]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN15@Fput
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN16@Fput
$LN15@Fput:
	mov	ecx, 1
	jmp	SHORT $LN421@Fput
$LN16@Fput:
	xor	ecx, ecx
$LN421@Fput:

; 1363 :         const char* _Exps;
; 1364 :         if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat) {

	mov	eax, DWORD PTR [edx+20]
	and	eax, 12288				; 00003000H
	mov	DWORD PTR __Prefix$1$[esp+108], ecx
	cmp	eax, 12288				; 00003000H
	je	SHORT $LN4@Fput

; 1365 :             _Exps = "eE";

	mov	edx, OFFSET ??_C@_02MDKMJEGG@eE@

; 1366 :         } else { // correct for hexadecimal floating-point

	jmp	SHORT $LN6@Fput
$LN4@Fput:

; 1367 :             _Exps = "pP";
; 1368 :             if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1369 :                 && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

	lea	eax, DWORD PTR [ecx+2]
	mov	edx, OFFSET ??_C@_02OOPEBDOJ@pP@
	cmp	eax, esi
	ja	SHORT $LN6@Fput
	cmp	BYTE PTR [edi+ecx], 48			; 00000030H
	jne	SHORT $LN6@Fput
	mov	cl, BYTE PTR [edi+ecx+1]
	cmp	cl, 120					; 00000078H
	je	SHORT $LN7@Fput
	cmp	cl, 88					; 00000058H
	jne	SHORT $LN6@Fput
$LN7@Fput:

; 1370 :                 _Prefix += 2;

	mov	DWORD PTR __Prefix$1$[esp+108], eax
$LN6@Fput:

; 1371 :             }
; 1372 :         }
; 1373 :         const size_t _Eoff = _CSTD strcspn(&_Buf[0], _Exps); // find exponent

	push	edx
	push	edi
	call	_strcspn
	mov	DWORD PTR __Eoff$1$[esp+116], eax

; 1374 :         char _Dp[2]        = {"."};

	mov	eax, 46					; 0000002eH
	mov	WORD PTR __Dp$[esp+116], ax

; 1375 :         _Dp[0]             = _CSTD localeconv()->decimal_point[0];

	call	_localeconv
	mov	eax, DWORD PTR [eax]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR __Dp$[esp+116], al

; 1376 :         const size_t _Poff = _CSTD strcspn(&_Buf[0], &_Dp[0]); // find decimal point

	lea	eax, DWORD PTR __Dp$[esp+116]
	push	eax
	push	edi
	call	_strcspn
	mov	ebx, eax
	add	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[esp+108]
	mov	eax, DWORD PTR [eax+48]
	mov	ebp, DWORD PTR [eax+4]

; 272  :         _Ptr->_Incref();

	mov	ecx, ebp
	mov	DWORD PTR $T8[esp+112], ebp
	mov	eax, DWORD PTR [ebp]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1378 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T8[esp+108]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$1$[esp+108], eax
	test	ebp, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	je	SHORT $LN29@Fput

; 360  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ebp]
	mov	ecx, ebp
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN29@Fput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN29@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1379 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

	push	0
	push	esi
	lea	ecx, DWORD PTR __Groupstring$[esp+116]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	mov	ecx, DWORD PTR __Ctype_fac$1$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1380 :         _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2155 :         return do_widen(_First, _Last, _Dest);

	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	DWORD PTR [edx+28]

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	ecx, DWORD PTR __Iosbase$GSCopy$1$[esp+108]
	mov	eax, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T7[esp+112], ecx

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1382 :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T7[esp+108]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	mov	ecx, DWORD PTR $T7[esp+116]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1382 :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	add	esp, 4
	mov	edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	test	ecx, ecx
	je	SHORT $LN53@Fput

; 360  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN53@Fput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN53@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 122  :         return do_grouping();

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR __Grouping$[esp+108]
	push	ecx
	mov	ecx, edi
	call	DWORD PTR [eax+20]

; 118  :         return do_thousands_sep();

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 1383 :         const string _Grouping  = _Punct_fac.grouping();
; 1384 :         const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	BYTE PTR __Kseparator$1$[esp+108], al

; 1385 : 
; 1386 :         if (_Poff != _Count) {

	cmp	ebx, esi
	je	SHORT $LN422@Fput

; 114  :         return do_decimal_point();

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	mov	eax, DWORD PTR [eax+12]
	call	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1387 :             _Groupstring[_Poff] = _Punct_fac.decimal_point();

	mov	cl, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1390 :         size_t _Off     = _Poff == _Count ? _Eoff : _Poff;

	cmp	ebx, esi
	mov	BYTE PTR [eax+ebx], cl
$LN422@Fput:
	cmove	ebx, DWORD PTR __Eoff$1$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Grouping$[esp+108]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Grouping$[esp+128], 16	; 00000010H

; 2024 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Grouping$[esp+108]
	mov	DWORD PTR __Pg$1$[esp+108], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1392 :         while (*_Pg != CHAR_MAX && '\0' < *_Pg && (size_t) *_Pg < _Off - _Prefix) { // add thousands separator

	mov	al, BYTE PTR [eax]
	cmp	al, 127					; 0000007fH
	je	$LN419@Fput
	npad	10
$LL2@Fput:
	mov	edx, DWORD PTR __Prefix$1$[esp+108]
	test	al, al
	jle	$LN417@Fput
	movsx	ecx, al
	mov	eax, ebx
	sub	eax, edx
	cmp	ecx, eax
	jae	$LN417@Fput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2036 :         if (_Mysize < _Off) {

	mov	edi, DWORD PTR __Groupstring$[esp+124]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1393 :             _Groupstring.insert(_Off -= *_Pg, (size_t) 1, _Kseparator);

	sub	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2036 :         if (_Mysize < _Off) {

	cmp	edi, ebx
	jb	$LN411@Fput

; 2805 :         const size_type _Old_size = _My_data._Mysize;

	mov	esi, DWORD PTR __Groupstring$[esp+128]
	mov	eax, esi
	sub	eax, edi
	mov	DWORD PTR __Old_capacity$1$[esp+108], esi

; 2806 :         if (_Count <= _My_data._Myres - _Old_size) {

	cmp	eax, 1
	jb	SHORT $LN88@Fput

; 2807 :             _My_data._Mysize        = _Old_size + _Count;

	lea	eax, DWORD PTR [edi+1]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	esi, 16					; 00000010H

; 2807 :             _My_data._Mysize        = _Old_size + _Count;

	mov	DWORD PTR __Groupstring$[esp+124], eax

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	sub	edi, ebx

; 2810 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	edi

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	edi

; 2809 :             _Elem* const _Insert_at = _Old_ptr + _Off;

	lea	esi, DWORD PTR [eax+ebx]

; 2810 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	lea	eax, DWORD PTR [esi+1]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	esi
	push	eax
	call	_memmove

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Kseparator$1$[esp+120]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [esi], cl

; 2812 :             return *this;

	jmp	$LN112@Fput
$LN88@Fput:

; 3813 :         const size_type _Old_size = _My_data._Mysize;

	mov	eax, 2147483647				; 7fffffffH
	sub	eax, edi

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	cmp	eax, 1
	jb	$LN412@Fput

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	ebp, DWORD PTR [edi+1]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	ebp, 15					; 0000000fH
	cmp	ebp, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN133@Fput

; 3770 :             return _Max;

	mov	ebp, 2147483647				; 7fffffffH
	jmp	SHORT $LN132@Fput
$LN133@Fput:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, esi
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	jbe	SHORT $LN134@Fput

; 3775 :             return _Max;

	mov	ebp, 2147483647				; 7fffffffH
	jmp	SHORT $LN132@Fput
$LN134@Fput:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [esi+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	ebp, eax
	cmovb	ebp, eax
$LN132@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [ebp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN165@Fput

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	eax, ecx
	mov	ecx, -1
	cmovbe	eax, ecx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN394@Fput

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN164@Fput
$LN165@Fput:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN166@Fput

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 179  :         return _Traits::_Allocate(_Bytes);

	mov	esi, eax
	jmp	SHORT $LN164@Fput
$LN166@Fput:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	esi, esi
$LN164@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3824 :         _My_data._Mysize      = _New_size;

	lea	eax, DWORD PTR [edi+1]

; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR __Groupstring$[esp+128], ebp

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	ebp, DWORD PTR __Old_capacity$1$[esp+108]
	sub	edi, ebx
	mov	DWORD PTR __Groupstring$[esp+124], eax
	inc	edi
	movsx	eax, BYTE PTR __Kseparator$1$[esp+108]
	mov	DWORD PTR tv1448[esp+108], eax
	mov	DWORD PTR tv1440[esp+108], edi
	push	ebx
	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN111@Fput

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR __Groupstring$[esp+112]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	esi
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	cl, BYTE PTR tv1448[esp+120]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv1440[esp+120]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [edi+ebx]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	lea	eax, DWORD PTR [ebx+1]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	BYTE PTR [esi+ebx], cl

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	eax, esi
	push	eax
	call	_memcpy

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	inc	ebp

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebp, 4096				; 00001000H
	jb	SHORT $LN214@Fput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [edi-4]
	add	ebp, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	$LN394@Fput

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, ecx
$LN214@Fput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ebp
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3832 :         } else {

	jmp	SHORT $LN423@Fput
$LN111@Fput:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	lea	eax, DWORD PTR __Groupstring$[esp+112]
	push	eax
	push	esi
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	cl, BYTE PTR tv1448[esp+120]
	movzx	eax, cl
	shl	cx, 8
	or	cx, ax

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR __Groupstring$[esp+120]
	add	eax, ebx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	BYTE PTR [esi+ebx], cl

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	eax
	lea	eax, DWORD PTR [ebx+1]
	add	eax, esi
	push	eax
	call	_memcpy
	add	esp, 24					; 00000018H
$LN423@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1394 :             if ('\0' < _Pg[1]) {

	mov	DWORD PTR __Groupstring$[esp+108], esi
$LN112@Fput:
	mov	ecx, DWORD PTR __Pg$1$[esp+108]
	cmp	BYTE PTR [ecx+1], 0
	lea	eax, DWORD PTR [ecx+1]
	cmovg	ecx, eax
	mov	DWORD PTR __Pg$1$[esp+108], ecx
	mov	al, BYTE PTR [ecx]
	cmp	al, 127					; 0000007fH
	jne	$LL2@Fput
$LN419@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3264 :         return _Get_data()._Mysize;

	mov	edx, DWORD PTR __Prefix$1$[esp+108]
$LN417@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1401 :             _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Count ? 0 : (size_t) _Iosbase.width() - _Count;

	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3264 :         return _Get_data()._Mysize;

	mov	ebx, DWORD PTR __Groupstring$[esp+124]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1401 :             _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Count ? 0 : (size_t) _Iosbase.width() - _Count;

	cmp	DWORD PTR [eax+36], 0
	mov	esi, DWORD PTR [eax+32]
	jl	SHORT $LN18@Fput
	jg	SHORT $LN416@Fput
	test	esi, esi
	je	SHORT $LN18@Fput
$LN416@Fput:
	cmp	esi, ebx
	jbe	SHORT $LN18@Fput
	sub	esi, ebx
	jmp	SHORT $LN19@Fput
$LN18@Fput:
	xor	esi, esi
$LN19@Fput:

; 1402 : 
; 1403 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [eax+20]

; 1404 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

	mov	ebp, DWORD PTR __Fill$[esp+104]
	and	eax, 448				; 000001c0H
	mov	edi, DWORD PTR _this$[esp+104]
	cmp	eax, 64					; 00000040H
	je	$LN12@Fput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN415@Fput

; 1405 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	ebp
	push	DWORD PTR __Dest$[esp+116]
	lea	eax, DWORD PTR $T6[esp+120]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	edi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1407 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	mov	ebp, DWORD PTR __Prefix$1$[esp+132]
	xor	esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+152], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1407 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	ebp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+132], edx
	mov	ecx, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+136]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1407 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T5[esp+148]
	mov	DWORD PTR __Dest$[esp+148], ecx
	push	eax
	push	edi
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 48					; 00000030H
	jmp	$LN13@Fput
$LN415@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1409 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+112]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1409 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[esp+116]
	lea	eax, DWORD PTR $T4[esp+120]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	edi
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1410 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	ebp
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+136], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	DWORD PTR __Dest$[esp+144], eax
	lea	eax, DWORD PTR $T3[esp+144]
	push	ecx
	push	eax
	push	edi
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 48					; 00000030H

; 1411 :             _Fillcount = 0;

	xor	esi, esi

; 1412 :         } else {

	jmp	SHORT $LN424@Fput
$LN12@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1413 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+112]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1413 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[esp+116]
	lea	eax, DWORD PTR $T2[esp+120]
	push	DWORD PTR __Dest$[esp+116]
	push	eax
	push	edi
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
$LN424@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3177 :         auto& _My_data = _Get_data();

	mov	ebp, DWORD PTR __Prefix$1$[esp+108]
$LN13@Fput:
	mov	edx, DWORD PTR [eax]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Groupstring$[esp+128], 16	; 00000010H

; 3177 :         auto& _My_data = _Get_data();

	mov	DWORD PTR __Dest$[esp+104], edx
	mov	ecx, DWORD PTR [eax+4]

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[esp+108]

; 2015 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1416 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	sub	ebx, ebp
	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3181 :         return _My_data._Myptr()[_Off];

	add	eax, ebp
	mov	DWORD PTR __Dest$[esp+112], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1416 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T1[esp+124]
	push	eax
	push	edi
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	edx, DWORD PTR __Iosbase$GSCopy$1$[esp+132]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1418 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	push	esi
	push	DWORD PTR __Fill$[esp+132]
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+140]
	mov	DWORD PTR __Dest$[esp+136], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __Dest$[esp+156], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR [edx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1418 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Grouping$[esp+176]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1418 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	add	esp, 48					; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN344@Fput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Grouping$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN343@Fput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN394@Fput
$LN343@Fput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN344@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Groupstring$[esp+128]

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR __Grouping$[esp+124], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR __Grouping$[esp+128], 15	; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR __Grouping$[esp+108], 0

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN398@Fput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Groupstring$[esp+108]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN397@Fput

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN394@Fput
$LN397@Fput:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN398@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1419 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+108]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 92					; 0000005cH
	ret	0
$LN412@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN411@Fput:

; 2037 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN394@Fput:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN420@Fput:
	int	3
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1326 :         char* _Ptr = _Fmt;
; 1327 :         *_Ptr++    = '%';
; 1328 : 
; 1329 :         if (_Flags & ios_base::showpos) {

	mov	edx, DWORD PTR __Flags$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Fmt$[esp]
	mov	BYTE PTR [esi], 37			; 00000025H
	lea	eax, DWORD PTR [esi+1]
	test	dl, 32					; 00000020H
	je	SHORT $LN2@Ffmt

; 1330 :             *_Ptr++ = '+';

	mov	BYTE PTR [eax], 43			; 0000002bH
	inc	eax
$LN2@Ffmt:

; 1331 :         }
; 1332 : 
; 1333 :         if (_Flags & ios_base::showpoint) {

	test	dl, 16					; 00000010H
	je	SHORT $LN3@Ffmt

; 1334 :             *_Ptr++ = '#';

	mov	BYTE PTR [eax], 35			; 00000023H
	inc	eax
$LN3@Ffmt:

; 1335 :         }
; 1336 : 
; 1337 :         *_Ptr++ = '.';
; 1338 :         *_Ptr++ = '*'; // for precision argument
; 1339 :         if (_Spec != '\0') {

	mov	cl, BYTE PTR __Spec$[esp]
	mov	WORD PTR [eax], 10798			; 00002a2eH
	add	eax, 2
	test	cl, cl
	je	SHORT $LN4@Ffmt

; 1340 :             *_Ptr++ = _Spec; // 'L' qualifier for long double only

	mov	BYTE PTR [eax], cl
	inc	eax
$LN4@Ffmt:

; 1341 :         }
; 1342 : 
; 1343 :         ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

	mov	ecx, edx
	and	ecx, 12288				; 00003000H

; 1344 :         if (_Flags & ios_base::uppercase) {

	test	dl, 4
	je	SHORT $LN5@Ffmt

; 1345 :             *_Ptr++ = _Ffl == ios_base::fixed

	cmp	ecx, 8192				; 00002000H
	je	SHORT $LN16@Ffmt
	cmp	ecx, 12288				; 00003000H
	jne	SHORT $LN8@Ffmt
	mov	cl, 65					; 00000041H

; 1351 :                           ? 'f'
; 1352 :                           : _Ffl == ios_base::hexfloat ? 'a' // added with TR1
; 1353 :                                                        : _Ffl == ios_base::scientific ? 'e' : 'g'; // specifier
; 1354 :         }
; 1355 : 
; 1356 :         *_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1357 :         return _Fmt;

	mov	eax, esi
	pop	esi

; 1358 :     }

	ret	0
$LN8@Ffmt:

; 1345 :             *_Ptr++ = _Ffl == ios_base::fixed

	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx*2+69]

; 1351 :                           ? 'f'
; 1352 :                           : _Ffl == ios_base::hexfloat ? 'a' // added with TR1
; 1353 :                                                        : _Ffl == ios_base::scientific ? 'e' : 'g'; // specifier
; 1354 :         }
; 1355 : 
; 1356 :         *_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1357 :         return _Fmt;

	mov	eax, esi
	pop	esi

; 1358 :     }

	ret	0
$LN5@Ffmt:

; 1346 :                           ? 'f'
; 1347 :                           : _Ffl == ios_base::hexfloat ? 'A' // added with TR1
; 1348 :                                                        : _Ffl == ios_base::scientific ? 'E' : 'G'; // specifier
; 1349 :         } else {
; 1350 :             *_Ptr++ = _Ffl == ios_base::fixed

	cmp	ecx, 8192				; 00002000H
	jne	SHORT $LN14@Ffmt
$LN16@Ffmt:

; 1351 :                           ? 'f'
; 1352 :                           : _Ffl == ios_base::hexfloat ? 'a' // added with TR1
; 1353 :                                                        : _Ffl == ios_base::scientific ? 'e' : 'g'; // specifier
; 1354 :         }
; 1355 : 
; 1356 :         *_Ptr = '\0';

	mov	cl, 102					; 00000066H
	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1357 :         return _Fmt;

	mov	eax, esi
	pop	esi

; 1358 :     }

	ret	0
$LN14@Ffmt:

; 1346 :                           ? 'f'
; 1347 :                           : _Ffl == ios_base::hexfloat ? 'A' // added with TR1
; 1348 :                                                        : _Ffl == ios_base::scientific ? 'E' : 'G'; // specifier
; 1349 :         } else {
; 1350 :             *_Ptr++ = _Ffl == ios_base::fixed

	cmp	ecx, 12288				; 00003000H
	jne	SHORT $LN12@Ffmt
	mov	cl, 97					; 00000061H

; 1351 :                           ? 'f'
; 1352 :                           : _Ffl == ios_base::hexfloat ? 'a' // added with TR1
; 1353 :                                                        : _Ffl == ios_base::scientific ? 'e' : 'g'; // specifier
; 1354 :         }
; 1355 : 
; 1356 :         *_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1357 :         return _Fmt;

	mov	eax, esi
	pop	esi

; 1358 :     }

	ret	0
$LN12@Ffmt:

; 1346 :                           ? 'f'
; 1347 :                           : _Ffl == ios_base::hexfloat ? 'A' // added with TR1
; 1348 :                                                        : _Ffl == ios_base::scientific ? 'E' : 'G'; // specifier
; 1349 :         } else {
; 1350 :             *_Ptr++ = _Ffl == ios_base::fixed

	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx*2+101]

; 1351 :                           ? 'f'
; 1352 :                           : _Ffl == ios_base::hexfloat ? 'a' // added with TR1
; 1353 :                                                        : _Ffl == ios_base::scientific ? 'e' : 'g'; // specifier
; 1354 :         }
; 1355 : 
; 1356 :         *_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1357 :         return _Fmt;

	mov	eax, esi
	pop	esi

; 1358 :     }

	ret	0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1316 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest

	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+68], eax
	mov	eax, DWORD PTR __Val$[esp+64]
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+68]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+72]
	push	edi

; 1317 :         char _Buf[2 * _MAX_INT_DIG];
; 1318 : 
; 1319 :         return _Iput(

	push	eax
	push	OFFSET ??_C@_02BBAHNLBA@?$CFp@
	lea	eax, DWORD PTR __Buf$[esp+88]
	mov	edi, ecx
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+100]
	push	eax
	push	DWORD PTR __Fill$[esp+100]
	push	esi
	push	DWORD PTR __Dest$[esp+112]
	push	DWORD PTR __Dest$[esp+112]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1320 :             _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
; 1321 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+128]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 68					; 00000044H
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
__Precision$ = -52					; size = 8
__Ptwo$1 = -48						; size = 4
___$ReturnUdt$GSCopy$1$ = -44				; size = 4
_this$GSCopy$1$ = -40					; size = 4
__Buf$ = -36						; size = 24
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1296 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest

	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+52], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+48]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Iosbase$[esp+56]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+60], eax
	mov	DWORD PTR _this$GSCopy$1$[esp+60], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR __Buf$[esp+76], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1299 :         bool _Isfixed         = (_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed;

	mov	eax, DWORD PTR [edi+20]

; 1300 :         streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); // desired precision

	mov	ecx, DWORD PTR [edi+28]
	and	eax, 12288				; 00003000H
	mov	esi, DWORD PTR [edi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR __Buf$[esp+80], 15		; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR __Buf$[esp+60], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1300 :         streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); // desired precision

	test	ecx, ecx
	jg	SHORT $LN4@do_put
	jl	SHORT $LN127@do_put
	test	esi, esi
	jne	SHORT $LN4@do_put
$LN127@do_put:
	cmp	eax, 8192				; 00002000H
	je	SHORT $LN4@do_put
	mov	esi, 6
	xor	ecx, ecx
$LN4@do_put:
	mov	DWORD PTR __Precision$[esp+64], ecx

; 1301 :         size_t _Bufsize       = (size_t) _Precision;

	mov	ecx, esi

; 1302 :         if (_Isfixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format

	cmp	eax, 8192				; 00002000H
	jne	SHORT $LN2@do_put
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 843  :         return fabs((double)_X);

	movsd	xmm1, QWORD PTR __Val$[esp+56]
	movaps	xmm0, xmm1
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1302 :         if (_Isfixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format

	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 864  :         return frexp((double)_X, _Y);

	lea	eax, DWORD PTR __Ptwo$1[esp+60]
	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	call	_frexp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1305 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	eax, DWORD PTR __Ptwo$1[esp+72]
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 864  :         return frexp((double)_X, _Y);

	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1305 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	cdq
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h

; 864  :         return frexp((double)_X, _Y);

	fstp	ST(0)
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1305 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	xor	eax, edx
	sub	eax, edx
	imul	ecx, eax, 30103
	mov	eax, 351843721				; 14f8b589H
	imul	ecx
	sar	edx, 13					; 0000000dH
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	ecx, esi
$LN2@do_put:

; 1306 :         }
; 1307 : 
; 1308 :         _Buf.resize(_Bufsize + 50); // add fudge factor

	lea	eax, DWORD PTR [ecx+50]
	push	0
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+68]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1309 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	push	DWORD PTR [edi+20]
	lea	eax, DWORD PTR __Fmt$[esp+64]
	push	76					; 0000004cH
	push	eax
	push	DWORD PTR _this$GSCopy$1$[esp+72]
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Buf$[esp+96], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR __Buf$[esp+76]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1309 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	movsd	xmm0, QWORD PTR __Val$[esp+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	cmovae	ecx, DWORD PTR __Buf$[esp+76]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1309 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	add	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	esi
	push	eax
	push	DWORD PTR __Buf$[esp+92]
	push	ecx
	call	_sprintf_s
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Buf$[esp+104], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR __Buf$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1312 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	cmovae	ecx, DWORD PTR __Buf$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1312 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	push	eax
	push	ecx
	push	DWORD PTR __Fill$[esp+88]
	push	edi
	push	DWORD PTR __Dest$[esp+100]
	push	DWORD PTR __Dest$[esp+100]
	push	esi
	push	DWORD PTR _this$GSCopy$1$[esp+112]
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Buf$[esp+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1312 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	add	esp, 56					; 00000038H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN114@do_put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Buf$[esp+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN113@do_put

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN130@do_put
$LN113@do_put:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN114@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1313 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+60]
	mov	eax, esi
	pop	edi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 52					; 00000034H
	ret	28					; 0000001cH
$LN130@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN128@do_put:
	int	3
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
__Precision$ = -52					; size = 8
__Ptwo$1 = -48						; size = 4
___$ReturnUdt$GSCopy$1$ = -44				; size = 4
_this$GSCopy$1$ = -40					; size = 4
__Buf$ = -36						; size = 24
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1276 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+52], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+48]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Iosbase$[esp+56]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+60], eax
	mov	DWORD PTR _this$GSCopy$1$[esp+60], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR __Buf$[esp+76], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1279 :         bool _Isfixed         = (_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed;

	mov	eax, DWORD PTR [edi+20]

; 1280 :         streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); // desired precision

	mov	ecx, DWORD PTR [edi+28]
	and	eax, 12288				; 00003000H
	mov	esi, DWORD PTR [edi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR __Buf$[esp+80], 15		; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR __Buf$[esp+60], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1280 :         streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision(); // desired precision

	test	ecx, ecx
	jg	SHORT $LN4@do_put
	jl	SHORT $LN123@do_put
	test	esi, esi
	jne	SHORT $LN4@do_put
$LN123@do_put:
	cmp	eax, 8192				; 00002000H
	je	SHORT $LN4@do_put
	mov	esi, 6
	xor	ecx, ecx
$LN4@do_put:
	mov	DWORD PTR __Precision$[esp+64], ecx

; 1281 :         size_t _Bufsize       = (size_t) _Precision;

	mov	ecx, esi

; 1282 :         if (_Isfixed && 1e10 < _CSTD fabs(_Val)) { // f or F format

	cmp	eax, 8192				; 00002000H
	jne	SHORT $LN2@do_put
	movsd	xmm1, QWORD PTR __Val$[esp+56]
	movaps	xmm0, xmm1
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put

; 1283 :             int _Ptwo;
; 1284 :             (void) _CSTD frexp(_Val, &_Ptwo);

	lea	eax, DWORD PTR __Ptwo$1[esp+60]
	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	call	_frexp

; 1285 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	eax, DWORD PTR __Ptwo$1[esp+72]
	add	esp, 12					; 0000000cH
	cdq
	fstp	ST(0)
	xor	eax, edx
	sub	eax, edx
	imul	ecx, eax, 30103
	mov	eax, 351843721				; 14f8b589H
	imul	ecx
	sar	edx, 13					; 0000000dH
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	ecx, esi
$LN2@do_put:

; 1286 :         }
; 1287 : 
; 1288 :         _Buf.resize(_Bufsize + 50); // add fudge factor

	lea	eax, DWORD PTR [ecx+50]
	push	0
	push	eax
	lea	ecx, DWORD PTR __Buf$[esp+68]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1289 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	push	DWORD PTR [edi+20]
	lea	eax, DWORD PTR __Fmt$[esp+64]
	push	0
	push	eax
	push	DWORD PTR _this$GSCopy$1$[esp+72]
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Buf$[esp+96], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR __Buf$[esp+76]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1289 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	movsd	xmm0, QWORD PTR __Val$[esp+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	cmovae	ecx, DWORD PTR __Buf$[esp+76]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1289 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	add	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	esi
	push	eax
	push	DWORD PTR __Buf$[esp+92]
	push	ecx
	call	_sprintf_s
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Buf$[esp+104], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR __Buf$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1292 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	cmovae	ecx, DWORD PTR __Buf$[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1292 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	push	eax
	push	ecx
	push	DWORD PTR __Fill$[esp+88]
	push	edi
	push	DWORD PTR __Dest$[esp+100]
	push	DWORD PTR __Dest$[esp+100]
	push	esi
	push	DWORD PTR _this$GSCopy$1$[esp+112]
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR __Buf$[esp+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1292 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	add	esp, 56					; 00000038H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN110@do_put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Buf$[esp+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN109@do_put

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN126@do_put
$LN109@do_put:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN110@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1293 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+60]
	mov	eax, esi
	pop	edi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 52					; 00000034H
	ret	28					; 0000001cH
$LN126@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN124@do_put:
	int	3
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 8
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1268 :         unsigned long long _Val) const { // put formatted unsigned long long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+76]

; 1269 :         char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1270 : 
; 1271 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+80]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+80]
	push	edi
	push	DWORD PTR __Val$[esp+88]
	mov	edi, ecx
	push	DWORD PTR __Val$[esp+88]
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02CLHGNPPK@Lu@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+100]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+112]
	push	eax
	push	DWORD PTR __Fill$[esp+112]
	push	esi
	push	DWORD PTR __Dest$[esp+124]
	push	DWORD PTR __Dest$[esp+124]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1272 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
; 1273 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+140]
	add	esp, 52					; 00000034H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 8
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1260 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+76]

; 1261 :         char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1262 : 
; 1263 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+80]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+80]
	push	edi
	push	DWORD PTR __Val$[esp+88]
	mov	edi, ecx
	push	DWORD PTR __Val$[esp+88]
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02HIKPPMOK@Ld@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+100]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+112]
	push	eax
	push	DWORD PTR __Fill$[esp+112]
	push	esi
	push	DWORD PTR __Dest$[esp+124]
	push	DWORD PTR __Dest$[esp+124]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1264 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
; 1265 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+140]
	add	esp, 52					; 00000034H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 6
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1252 :         unsigned long _Val) const { // put formatted unsigned long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+76]

; 1253 :         char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1254 : 
; 1255 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+80]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+80]
	push	edi
	push	DWORD PTR __Val$[esp+84]
	mov	edi, ecx
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02BDDLJJBK@lu@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+96]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+108]
	push	eax
	push	DWORD PTR __Fill$[esp+108]
	push	esi
	push	DWORD PTR __Dest$[esp+120]
	push	DWORD PTR __Dest$[esp+120]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1256 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
; 1257 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+136]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Fmt$ = -76						; size = 6
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1244 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp+76]

; 1245 :         char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1246 : 
; 1247 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+80]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[esp+80]
	push	edi
	push	DWORD PTR __Val$[esp+84]
	mov	edi, ecx
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02EAOCLKAK@ld@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+96]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+108]
	push	eax
	push	DWORD PTR __Fill$[esp+108]
	push	esi
	push	DWORD PTR __Dest$[esp+120]
	push	DWORD PTR __Dest$[esp+120]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1248 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
; 1249 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+136]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
__Fill$GSCopy$ = -68					; size = 1
_this$GSCopy$1$ = -64					; size = 4
$T1 = -60						; size = 8
$T2 = -60						; size = 8
$T3 = -60						; size = 8
__Str$4 = -52						; size = 24
$T5 = -28						; size = 24
$T6 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1217 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { // put formatted bool to _Dest

	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+68], eax
	mov	al, BYTE PTR __Fill$[esp+64]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+72]
	mov	ebx, ecx
	push	edi
	mov	edi, DWORD PTR __Iosbase$[esp+76]
	mov	DWORD PTR _this$GSCopy$1$[esp+80], ebx
	mov	BYTE PTR __Fill$GSCopy$[esp+80], al

; 1218 :         if (!(_Iosbase.flags() & ios_base::boolalpha)) {

	test	DWORD PTR [edi+20], 16384		; 00004000H
	jne	SHORT $LN2@do_put

; 1219 :             return do_put(_Dest, _Iosbase, _Fill, (long) _Val);

	movzx	eax, BYTE PTR __Val$[esp+76]
	mov	edx, DWORD PTR [ebx]
	push	eax
	push	DWORD PTR __Fill$GSCopy$[esp+84]
	push	edi
	push	DWORD PTR __Dest$[esp+92]
	push	DWORD PTR __Dest$[esp+92]
	push	ebp
	call	DWORD PTR [edx+36]
	jmp	$LN130@do_put
$LN2@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR [edi+48]
	push	esi
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T3[esp+88], ecx

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1221 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T3[esp+84]
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	mov	ecx, DWORD PTR $T3[esp+92]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1221 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	add	esp, 4
	mov	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	test	ecx, ecx
	je	SHORT $LN19@do_put

; 360  :             delete _Ptr->_Decref();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN19@do_put
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN19@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1223 :             if (_Val) {

	cmp	BYTE PTR __Val$[esp+80], 0
	lea	ecx, DWORD PTR $T6[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1223 :             if (_Val) {

	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR __Str$4[esp+104], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1223 :             if (_Val) {

	mov	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR __Str$4[esp+108], 15		; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR __Str$4[esp+88], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1223 :             if (_Val) {

	je	SHORT $LN4@do_put

; 130  :         return do_truename();

	call	DWORD PTR [eax+28]

; 1224 :                 _Str.assign(_Punct_fac.truename());
; 1225 :             } else {

	jmp	SHORT $LN146@do_put
$LN4@do_put:

; 126  :         return do_falsename();

	call	DWORD PTR [eax+24]
$LN146@do_put:

; 1226 :                 _Str.assign(_Punct_fac.falsename());
; 1227 :             }
; 1228 : 
; 1229 :             size_t _Fillcount = _Iosbase.width() <= 0 || (size_t) _Iosbase.width() <= _Str.size()

	lea	eax, DWORD PTR $T5[esp+84]
	push	eax
	lea	ecx, DWORD PTR __Str$4[esp+88]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T5[esp+84]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	DWORD PTR [edi+36], 0
	mov	esi, DWORD PTR [edi+32]
	mov	eax, DWORD PTR __Str$4[esp+100]
	jl	SHORT $LN8@do_put
	jg	SHORT $LN143@do_put
	test	esi, esi
	je	SHORT $LN8@do_put
$LN143@do_put:
	cmp	esi, eax
	jbe	SHORT $LN8@do_put
	sub	esi, eax
	jmp	SHORT $LN9@do_put
$LN8@do_put:
	xor	esi, esi
$LN9@do_put:

; 1230 :                                     ? 0
; 1231 :                                     : (size_t) _Iosbase.width() - _Str.size();
; 1232 : 
; 1233 :             if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill

	mov	eax, DWORD PTR [edi+20]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN144@do_put

; 1234 :                 _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	DWORD PTR __Fill$GSCopy$[esp+88]
	lea	eax, DWORD PTR $T2[esp+92]
	push	DWORD PTR __Dest$[esp+92]
	push	DWORD PTR __Dest$[esp+92]
	push	eax
	push	ebx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H

; 1235 :                 _Fillcount = 0;

	xor	esi, esi
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+80], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[esp+84], edx
	jmp	SHORT $LN6@do_put
$LN144@do_put:

; 1230 :                                     ? 0
; 1231 :                                     : (size_t) _Iosbase.width() - _Str.size();
; 1232 : 
; 1233 :             if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill

	mov	edx, DWORD PTR __Dest$[esp+84]
	mov	ecx, DWORD PTR __Dest$[esp+80]
$LN6@do_put:

; 1237 :             _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field

	push	DWORD PTR __Str$4[esp+100]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR __Str$4[esp+108], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Str$4[esp+88]

; 2024 :         if (_Large_string_engaged()) {

	mov	ebx, DWORD PTR __Str$4[esp+88]
	cmovae	eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1237 :             _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field

	push	eax
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T1[esp+100]
	push	eax
	push	DWORD PTR _this$GSCopy$1$[esp+104]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1239 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	push	esi
	push	DWORD PTR __Fill$GSCopy$[esp+112]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[esp+112], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
	push	ebp
	push	DWORD PTR _this$GSCopy$1$[esp+128]
	mov	DWORD PTR __Dest$[esp+132], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [edi+32], 0
	mov	DWORD PTR [edi+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1239 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	eax, DWORD PTR __Str$4[esp+152]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1239 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	add	esp, 48					; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	pop	esi
	cmp	eax, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN130@do_put

; 3872 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 3873 :             auto& _Al          = _Getal();
; 3874 :             _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	ecx, DWORD PTR [eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ebx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN129@do_put

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ebx, DWORD PTR [ebx-4]
	add	ecx, 35					; 00000023H
	sub	eax, ebx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN148@do_put
$LN129@do_put:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN130@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1241 :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+80]
	mov	eax, ebp
	pop	edi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 68					; 00000044H
	ret	24					; 00000018H
$LN148@do_put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN145@do_put:
	int	3
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1192 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

	push	DWORD PTR __Val$[esp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Val$[esp]
	push	DWORD PTR __Fill$[esp+4]
	push	DWORD PTR __Iosbase$[esp+8]
	push	DWORD PTR __Dest$[esp+16]
	push	DWORD PTR __Dest$[esp+16]
	push	DWORD PTR ___$ReturnUdt$[esp+20]
	call	DWORD PTR [eax+28]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1193 :     }

	ret	28					; 0000001cH
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1187 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

	push	DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Fill$[esp]
	push	DWORD PTR __Iosbase$[esp+4]
	push	DWORD PTR __Dest$[esp+12]
	push	DWORD PTR __Dest$[esp+12]
	push	DWORD PTR ___$ReturnUdt$[esp+16]
	call	DWORD PTR [eax+32]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1188 :     }

	ret	24					; 00000018H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	eax, DWORD PTR __Refs$[esp-4]
	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1170 :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	ret	8
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 1158 :     }

	ret	4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1155 :     }

	ret	0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
$T2 = -52						; size = 52
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 1143 :         const locale* _Ploc = nullptr) { // return locale category mask and construct standard facet

	sub	esp, 56					; 00000038H
	push	ebx
	push	edi

; 1144 :         if (_Ppf != nullptr && *_Ppf == nullptr) {

	mov	edi, DWORD PTR __Ppf$[esp+60]
	xor	ebx, ebx
	mov	DWORD PTR $T1[esp+64], ebx
	test	edi, edi
	je	SHORT $LN24@Getcat
	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN24@Getcat

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	push	esi
	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN4@Getcat
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	ecx, DWORD PTR __Ploc$[esp+64]
	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	jne	SHORT $LN9@Getcat
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN14@Getcat
$LN9@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN14@Getcat
	lea	eax, DWORD PTR [ecx+28]
$LN14@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	push	eax
	lea	ecx, DWORD PTR $T2[esp+72]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	mov	ebx, 1

; 1168 :         : locale::facet(_Refs) { // construct from specified locale

	mov	DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	esi, esi
$LN5@Getcat:
	mov	DWORD PTR [edi], esi
	pop	esi
	test	bl, 1
	je	SHORT $LN24@Getcat
	lea	ecx, DWORD PTR $T2[esp+64]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN24@Getcat:

; 1146 :         }
; 1147 : 
; 1148 :         return _X_NUMERIC;
; 1149 :     }

	pop	edi
	mov	eax, 4
	pop	ebx
	add	esp, 56					; 00000038H
	ret	0
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Lock$1 = -60						; size = 4
$T2 = -56						; size = 4
__Lock$3 = -56						; size = 4
$T4 = -52						; size = 52
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 434  : { // get facet reference from locale

	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	ebx, ebx

; 435  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	lea	ecx, DWORD PTR __Lock$3[esp+76]
	push	ebx
	mov	DWORD PTR $T2[esp+80], ebx
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	mov	edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id

; 436  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	ebp, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	test	edi, edi
	jne	SHORT $LN9@use_facet

; 100  :                 _BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$1[esp+80]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 101  :                 if (_Id == 0) {

	cmp	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, ebx ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	jne	SHORT $LN10@use_facet

; 102  :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN10@use_facet:

; 103  :                 }
; 104  :                 _END_LOCK()

	lea	ecx, DWORD PTR __Lock$1[esp+76]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN9@use_facet:

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	ecx, DWORD PTR __Loc$[esp+72]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN17@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	test	esi, esi
	jne	$LN84@use_facet
	jmp	SHORT $LN87@use_facet
$LN17@use_facet:

; 380  :     }
; 381  : 
; 382  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	esi, esi
$LN87@use_facet:

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [ecx+20], bl
	je	SHORT $LN15@use_facet

; 385  :             return _Facptr; // found facet or not transparent
; 386  :         } else { // look in current locale
; 387  :             locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 388  :             return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] // get from current locale

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN88@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 437  : 
; 438  :     const size_t _Id         = _Facet::id;
; 439  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 440  : 
; 441  :     if (_Pf == nullptr) {

	test	esi, esi
	jne	$LN84@use_facet
$LN88@use_facet:

; 442  :         if (_Psave != nullptr) {

	test	ebp, ebp
	je	SHORT $LN3@use_facet

; 462  :             _Pf                       = _Psave;
; 463  : 
; 464  :             (void) _Psave_guard.release();
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[esp+76]
	mov	esi, ebp
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

	add	esp, 60					; 0000003cH
	ret	0
$LN3@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN24@use_facet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	eax, DWORD PTR __Loc$[esp+72]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN29@use_facet
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN34@use_facet
$LN29@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN34@use_facet
	lea	eax, DWORD PTR [ecx+28]
$LN34@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	push	eax
	lea	ecx, DWORD PTR $T4[esp+80]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocnum

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	mov	ebx, 1

; 1168 :         : locale::facet(_Refs) { // construct from specified locale

	mov	DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1145 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	jmp	SHORT $LN25@use_facet
$LN24@use_facet:
	xor	esi, esi
$LN25@use_facet:
	test	bl, 1
	je	SHORT $LN26@use_facet
	lea	ecx, DWORD PTR $T4[esp+76]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN26@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 457  :             _Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 458  : #endif // defined(_M_CEE)
; 459  : 
; 460  :             _Pfmod->_Incref();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [edx+4]

; 461  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
$LN84@use_facet:

; 462  :             _Pf                       = _Psave;
; 463  : 
; 464  :             (void) _Psave_guard.release();
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[esp+76]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

	add	esp, 60					; 0000003cH
	ret	0
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 120  :             return _Ok;

	mov	al, BYTE PTR [ecx+4]

; 121  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 104  :         __CLR_OR_THIS_CALL ~sentry() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 105  : #if _HAS_EXCEPTIONS
; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN2@sentry

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN2@sentry:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	ecx, DWORD PTR [esi]
	pop	esi
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+8]
$LN5@sentry:

; 108  :             }
; 109  : #else // _HAS_EXCEPTIONS
; 110  :             this->_Myostr._Osfx();
; 111  : #endif // _HAS_EXCEPTIONS
; 112  :         }

	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr)

	push	esi
	mov	esi, DWORD PTR __Ostr$[esp]
	push	edi
	mov	edi, ecx

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	DWORD PTR [edi], esi

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi]
$LN5@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	ecx, DWORD PTR [edx+4]

; 321  :         return rdstate() == ios_base::goodbit;

	mov	eax, edx
	cmp	DWORD PTR [ecx+esi+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	jne	SHORT $LN2@sentry
	mov	ecx, DWORD PTR [ecx+esi+60]
	test	ecx, ecx
	je	SHORT $LN2@sentry
	cmp	ecx, esi
	je	SHORT $LN2@sentry

; 91   :                 _Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, DWORD PTR [esi]
$LN2@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 321  :         return rdstate() == ios_base::goodbit;

	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+12], 0
	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 94   :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	BYTE PTR [edi+4], al

; 95   :         }

	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 78   :             }
; 79   :         }

	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	edx, DWORD PTR __Ostr$[esp-4]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 72   :             }
; 73   :         }

	mov	eax, esi
	pop	esi
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1528 :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1528 :     }

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	ret	8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 295  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[esp-4]

; 296  : }

	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<int,std::allocator<int> >::_Construct_n_copies_of_ty<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 383  :     void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {

	push	esi

; 384  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 385  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 386  :         if (_Count != 0) {

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	je	SHORT $LN61@Construct_

; 1501 :         if (_Newcapacity > max_size()) {

	cmp	esi, 1073741823				; 3fffffffH
	ja	SHORT $LN67@Construct_

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	push	esi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	ecx, DWORD PTR [esi*4]
	mov	DWORD PTR [edi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	ecx
	push	0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	esi, DWORD PTR [ecx+eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	mov	DWORD PTR [edi+8], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 389  :             _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);

	mov	DWORD PTR [edi+4], esi
$LN61@Construct_:

; 390  :             _Guard._Target = nullptr;
; 391  :         }
; 392  : 
; 393  :         _Proxy._Release();
; 394  :     }

	pop	edi
	pop	esi
	ret	8
$LN67@Construct_:

; 1502 :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN65@Construct_:
	int	3
??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<int,std::allocator<int> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	ret	8
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
__Newvec$ = -32						; size = 4
__Newsize$1$ = -28					; size = 4
__Newcapacity$ = -24					; size = 4
tv732 = -20						; size = 4
__Whereoff$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>, COMDAT
; _this$ = ecx

; 659  :         const pointer _Whereptr, _Valty&&... _Val) { // reallocate and insert by perfectly forwarding _Val at _Whereptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 660  :                                                      // pre: !_Has_unused_capacity()
; 661  :         const size_type _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst());

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR __Whereptr$[ebp]
	sub	eax, edx
	sar	eax, 2
	mov	DWORD PTR __Whereoff$1$[ebp], eax

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2

; 662  :         _Alty& _Al                = _Getal();
; 663  :         const size_type _Oldsize  = size();
; 664  : 
; 665  :         if (_Oldsize == max_size()) {

	cmp	eax, 1073741823				; 3fffffffH
	je	$LN286@Emplace_re

; 667  :         }
; 668  : 
; 669  :         const size_type _Newsize     = _Oldsize + 1;

	lea	ebx, DWORD PTR [eax+1]
	mov	DWORD PTR __Newsize$1$[ebp], ebx

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, edx
	sar	ecx, 2

; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	edx, ecx
	shr	edx, 1
	mov	eax, 1073741823				; 3fffffffH
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN48@Emplace_re

; 1476 :             return _Newsize; // geometric growth would overflow

	mov	edi, ebx
	mov	DWORD PTR __Newcapacity$[ebp], ebx
	jmp	SHORT $LN49@Emplace_re
$LN48@Emplace_re:

; 1477 :         }
; 1478 : 
; 1479 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	edi, DWORD PTR [edx+ecx]

; 1480 : 
; 1481 :         if (_Geometric < _Newsize) {

	cmp	edi, ebx
	cmovb	edi, ebx
	mov	DWORD PTR __Newcapacity$[ebp], edi
$LN49@Emplace_re:

; 670  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 671  : 
; 672  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	push	edi
	mov	ecx, esi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	mov	ebx, eax
	mov	DWORD PTR __Newvec$[ebp], ebx

; 673  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;
; 674  :         pointer _Constructed_first      = _Constructed_last;
; 675  : 
; 676  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 677  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR __Whereoff$1$[ebp]
	lea	edx, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv732[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 680  :         if (_Whereptr == _Mylast()) { // at back, provide strong guarantee

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR __Whereptr$[ebp]
	cmp	ecx, eax
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	eax, edx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	edx
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 682  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	ecx, edx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	ecx
	push	edx
	push	ebx
	call	_memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 685  :             _Umove(_Whereptr, _Mylast(), _Newvec + _Whereoff + 1);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR tv732[ebp]
	add	ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	edx, DWORD PTR __Whereptr$[ebp]
	sub	eax, edx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	edx
	push	ecx
	call	_memmove
	add	esp, 24					; 00000018H
$LN5@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1512 :         if (_Myfirst() != pointer()) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN255@Emplace_re

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	ecx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN254@Emplace_re

; 107  :     _Bytes += _Non_user_size;

	add	ecx, 35					; 00000023H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN251@Emplace_re

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN254@Emplace_re:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN255@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1517 :         _Myfirst() = _Newvec;

	mov	DWORD PTR [esi], ebx

; 1518 :         _Mylast()  = _Newvec + _Newsize;

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	lea	ecx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR [esi+4], ecx

; 1519 :         _Myend()   = _Newvec + _Newcapacity;

	lea	ecx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [esi+8], ecx

; 691  :         _CATCH_END
; 692  : 
; 693  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 694  :         return this->_Myfirst() + _Whereoff;

	mov	eax, DWORD PTR tv732[ebp]

; 695  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z$0:

; 686  :         }
; 687  :         _CATCH_ALL
; 688  :         _Destroy(_Constructed_first, _Constructed_last);
; 689  :         _Al.deallocate(_Newvec, _Newcapacity);

	push	DWORD PTR __Newcapacity$[ebp]
	push	DWORD PTR __Newvec$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@H@std@@QAEXQAHI@Z ; std::allocator<int>::deallocate

; 690  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN286@Emplace_re:

; 666  :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN251@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN284@Emplace_re:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Args_0>$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$_Unfancy@H@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@H@std@@YAPAHPAH@Z PROC			; std::_Unfancy<int>, COMDAT

; 295  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[esp-4]

; 296  : }

	ret	0
??$_Unfancy@H@std@@YAPAHPAH@Z ENDP			; std::_Unfancy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int>, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edx, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 624  :         _Ty& _Result = *_Mylast();

	mov	eax, DWORD PTR [ecx+4]

; 625  :         ++_Mylast();

	lea	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 626  : #if _HAS_CXX17
; 627  :         return _Result;
; 628  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 629  :         (void) _Result;
; 630  : #endif // _HAS_CXX17
; 631  :     }

	ret	4
??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1298 : }

	ret	0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$emplace_back@H@?$vector@HV?$allocator@H@std@@@std@@QAEAAH$$QAH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@H@?$vector@HV?$allocator@H@std@@@std@@QAEAAH$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::emplace_back<int>, COMDAT
; _this$ = ecx

; 636  :         _Valty&&... _Val) { // insert by perfectly forwarding into element at end, provide strong guarantee

	mov	edx, ecx

; 1357 :         return _Myend() != _Mylast();

	mov	ecx, DWORD PTR [edx+4]
	cmp	DWORD PTR [edx+8], ecx

; 637  :         if (_Has_unused_capacity()) {

	je	SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR _<_Val_0>$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 624  :         _Ty& _Result = *_Mylast();

	mov	eax, DWORD PTR [edx+4]

; 625  :         ++_Mylast();

	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 642  : #if _HAS_CXX17
; 643  :         return _Result;
; 644  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 645  :         (void) _Result;
; 646  : #endif // _HAS_CXX17
; 647  :     }

	ret	4
$LN2@emplace_ba:

; 638  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 639  :         }
; 640  : 
; 641  :         _Ty& _Result = *_Emplace_reallocate(_Mylast(), _STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[esp-4]
	push	ecx
	mov	ecx, edx
	call	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>

; 642  : #if _HAS_CXX17
; 643  :         return _Result;
; 644  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 645  :         (void) _Result;
; 646  : #endif // _HAS_CXX17
; 647  :     }

	ret	4
??$emplace_back@H@?$vector@HV?$allocator@H@std@@@std@@QAEAAH$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::emplace_back<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AAH@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAH@std@@YA$$QAHAAH@Z PROC			; std::move<int &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	eax, DWORD PTR __Arg$[esp-4]

; 1310 : }

	ret	0
??$move@AAH@std@@YA$$QAHAAH@Z ENDP			; std::move<int &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
;	COMDAT ??$try_emplace@$$V@?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
$T2 = 12						; size = 4
__Keyval$ = 12						; size = 4
??$try_emplace@$$V@?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@ABH@Z PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::try_emplace<>, COMDAT
; _this$ = ecx

; 202  :         _Mappedty&&... _Mapval) { // fail if _Keyval present, else emplace

	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1585 :         while (!_Pnode->_Isnil) {

	mov	ebx, DWORD PTR __Keyval$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 202  :         _Mappedty&&... _Mapval) { // fail if _Keyval present, else emplace

	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1582 :         _Nodeptr _Wherenode = _Get_data()._Myhead; // end() if search fails

	mov	edi, DWORD PTR [ebp]
	mov	esi, edi

; 1583 :         _Nodeptr _Pnode     = _Wherenode->_Parent;

	mov	eax, DWORD PTR [esi+4]

; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN20@try_emplac
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	ecx, DWORD PTR [ebx]
	npad	6
$LL19@try_emplac:
	cmp	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1586 :             if (_Compare(_Key(_Pnode), _Keyval)) {

	jge	SHORT $LN21@try_emplac

; 1587 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 1588 :             } else { // _Pnode not less than _Keyval, remember it

	jmp	SHORT $LN22@try_emplac
$LN21@try_emplac:

; 1589 :                 _Wherenode = _Pnode;

	mov	esi, eax

; 1590 :                 _Pnode     = _Pnode->_Left; // descend left subtree

	mov	eax, DWORD PTR [eax]
$LN22@try_emplac:

; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL19@try_emplac
$LN20@try_emplac:

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	je	SHORT $LN271@try_emplac
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	jl	SHORT $LN271@try_emplac
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	xor	cl, cl
	mov	DWORD PTR [eax], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 204  :     }

	mov	BYTE PTR [eax+4], cl
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN271@try_emplac:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	ecx, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	mov	ecx, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples

	mov	DWORD PTR [eax+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 364  :         _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	edx

; 369  :         _Newnode._Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	lea	eax, DWORD PTR $T2[esp+20]
	push	esi
	push	eax
	call	??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_hint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	ecx, DWORD PTR $T2[esp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 204  :     }

	pop	edi
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	DWORD PTR [eax], ecx
	mov	cl, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 204  :     }

	pop	ebp
	mov	BYTE PTR [eax+4], cl
	pop	ebx
	ret	8
??$try_emplace@$$V@?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@_N@1@ABH@Z ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::try_emplace<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 681  :     void _Erase_head(_Alnode& _Al) noexcept { // delete a _Tree head node and subtree

	push	esi
	push	edi
	mov	edi, ecx

; 682  :         this->_Orphan_all();
; 683  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+4]

; 674  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [esi+13], 0
	jne	SHORT $LN7@Erase_head
	push	ebx
	mov	ebx, DWORD PTR __Al$[esp+8]
$LL6@Erase_head:

; 675  :             _Erase_tree(_Al, _Rootnode->_Right);

	push	DWORD PTR [esi+8]
	mov	ecx, edi
	push	ebx
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, esi

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 674  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL6@Erase_head
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, DWORD PTR [edi]
	pop	ebx
$LN7@Erase_head:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	pop	edi
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 685  :     }

	ret	4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 282  : }

	ret	0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 672  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

	push	ebx
	push	esi

; 674  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	mov	esi, DWORD PTR __Rootnode$[esp+4]
	mov	ebx, ecx
	cmp	BYTE PTR [esi+13], 0
	jne	SHORT $LN3@Erase_tree
	push	edi
	mov	edi, DWORD PTR __Al$[esp+8]
$LL2@Erase_tree:

; 675  :             _Erase_tree(_Al, _Rootnode->_Right);

	push	DWORD PTR [esi+8]
	mov	ecx, ebx
	push	edi
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, esi

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 674  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL2@Erase_tree
	pop	edi
$LN3@Erase_tree:
	pop	esi

; 676  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 677  :         }
; 678  :     }

	pop	ebx
	ret	8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
;	COMDAT _main
_TEXT	SEGMENT
_rands$ = -5040						; size = 12
_end$1 = -5028						; size = 8
$T2 = -5028						; size = 4
_map$ = -5020						; size = 8
$T3 = -5012						; size = 8
$T4 = -5012						; size = 8
_start$5 = -5012					; size = 8
_re$ = -5004						; size = 5000
__$ArrayPad$ = -4					; size = 4
_main	PROC						; COMDAT

; 67   : int main() {

	mov	eax, 5040				; 000013b0H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+5040], eax
	push	esi
	push	edi

; 68   : 	default_random_engine re(0); 

	push	0
	lea	ecx, DWORD PTR _re$[esp+5052]
	call	??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	push	10000					; 00002710H
	lea	ecx, DWORD PTR _rands$[esp+5052]

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR _rands$[esp+5052], 0
	mov	DWORD PTR _rands$[esp+5056], 0
	mov	DWORD PTR _rands$[esp+5060], 0

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	mov	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	40000					; 00009c40H
	push	0
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	ecx, DWORD PTR [esi+40000]
	mov	DWORD PTR _rands$[esp+5060], esi
	mov	DWORD PTR _rands$[esp+5068], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	_memset

; 332  :     return _Zero_range(_First, _First + _Count);

	lea	eax, DWORD PTR [esi+40000]

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 389  :             _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);

	mov	DWORD PTR _rands$[esp+5052], eax
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 68   : 	default_random_engine re(0); 

	mov	esi, 10000				; 00002710H
	mov	edi, 100000001				; 05f5e101H
	npad	1
$LL123@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	lea	ecx, DWORD PTR _re$[esp+5048]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
	mov	ecx, eax

; 3292 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

	mov	eax, -1412663563			; abcc76f5H
	mul	ecx
	shr	edx, 26					; 0000001aH
	cmp	edx, 42					; 0000002aH
	jae	SHORT $LL123@main

; 3293 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, ecx
	xor	edx, edx
	div	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1887 :         return _Ty(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	ecx, DWORD PTR [edx-2147483648]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 73   : 		rands.push_back(dist(re));

	cmp	ecx, -2147483648			; 80000000H
	lea	eax, DWORD PTR [ecx-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1357 :         return _Myend() != _Mylast();

	mov	ecx, DWORD PTR _rands$[esp+5052]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 73   : 		rands.push_back(dist(re));

	cmovae	eax, edx
	mov	DWORD PTR $T2[esp+5048], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1357 :         return _Myend() != _Mylast();

	cmp	DWORD PTR _rands$[esp+5056], ecx

; 637  :         if (_Has_unused_capacity()) {

	je	SHORT $LN150@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 625  :         ++_Mylast();

	add	DWORD PTR _rands$[esp+5052], 4

; 638  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN2@main
$LN150@main:

; 639  :         }
; 640  : 
; 641  :         _Ty& _Result = *_Emplace_reallocate(_Mylast(), _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T2[esp+5048]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR _rands$[esp+5056]
	call	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
$LN2@main:
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 72   : 	for (int i=0; i < size; ++i){

	sub	esi, 1
	jne	SHORT $LL123@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 415  :     _Tree_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR _map$[esp+5056], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
	mov	DWORD PTR [eax+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 352  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1795 :         _My_data._Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR _map$[esp+5052], eax
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 55   : 	auto start = chrono::high_resolution_clock::now();

	lea	eax, DWORD PTR _start$5[esp+5052]
	push	eax
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now

; 56   : 	fn(rands, map);

	lea	eax, DWORD PTR _map$[esp+5056]
	push	eax
	lea	eax, DWORD PTR _rands$[esp+5060]
	push	eax
	call	?map_access@@YAXABV?$vector@HV?$allocator@H@std@@@std@@PAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@2@@Z ; map_access

; 57   : 	auto end = chrono::high_resolution_clock::now();

	lea	eax, DWORD PTR _end$1[esp+5064]
	push	eax
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 249  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	mov	ecx, DWORD PTR _end$1[esp+5068]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 57   : 	auto end = chrono::high_resolution_clock::now();

	add	esp, 20					; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 249  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	sub	ecx, DWORD PTR _start$5[esp+5048]
	mov	eax, DWORD PTR _end$1[esp+5052]
	sbb	eax, DWORD PTR _start$5[esp+5052]

; 372  :         return _Num_is_one && _Den_is_one

	push	esi
	push	1000000					; 000f4240H
	push	eax
	push	ecx
	call	__alldiv
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 59   : 	cout << "cold cache took time: " << duration << " milliseconds" << endl;

	push	OFFSET ??_C@_0BH@KLJDGFCF@cold?5cache?5took?5time?3?5@
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 372  :         return _Num_is_one && _Den_is_one

	mov	edi, eax
	mov	esi, edx
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 59   : 	cout << "cold cache took time: " << duration << " milliseconds" << endl;

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	push	OFFSET ??_C@_0O@IALHGEAH@?5milliseconds@
	push	esi
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 172  :         return (*_Pfn)(*this);

	push	eax
	call	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 60   : 	start = chrono::high_resolution_clock::now();

	lea	eax, DWORD PTR $T4[esp+5060]
	push	eax
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]

; 61   : 	fn(rands, map);

	lea	eax, DWORD PTR _map$[esp+5064]
	push	eax
	lea	eax, DWORD PTR _rands$[esp+5068]
	push	eax
	call	?map_access@@YAXABV?$vector@HV?$allocator@H@std@@@std@@PAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@2@@Z ; map_access

; 62   : 	end = chrono::high_resolution_clock::now();

	lea	eax, DWORD PTR $T3[esp+5072]
	push	eax
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	sub	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 372  :         return _Num_is_one && _Den_is_one

	push	0
	push	1000000					; 000f4240H
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 62   : 	end = chrono::high_resolution_clock::now();

	sbb	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 372  :         return _Num_is_one && _Den_is_one

	push	eax
	push	ecx
	call	__alldiv
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 64   : 	cout << "warm cache took time: " << duration << " milliseconds" << endl;

	push	OFFSET ??_C@_0BH@BJIMNNC@warm?5cache?5took?5time?3?5@
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 372  :         return _Num_is_one && _Den_is_one

	mov	edi, eax
	mov	esi, edx
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 64   : 	cout << "warm cache took time: " << duration << " milliseconds" << endl;

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	push	OFFSET ??_C@_0O@IALHGEAH@?5milliseconds@
	push	esi
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 172  :         return (*_Pfn)(*this);

	push	eax
	call	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _map$[esp+5048]
	call	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	mov	edx, DWORD PTR _rands$[esp+5048]
	pop	edi
	pop	esi
	test	edx, edx
	je	SHORT $LN405@main

; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	ecx, DWORD PTR _rands$[esp+5048]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	sub	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	ecx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN445@main

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [edx-4]
	add	ecx, 35					; 00000023H
	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN480@main
$LN445@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN405@main:
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 78   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+5040]
	xor	eax, eax
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 5040				; 000013b0H
	ret	0
$LN480@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN478@main:
	int	3
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = 8							; size = 1
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 901  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

	sub	esp, 8
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	esi, DWORD PTR __Ostr$[esp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 901  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+esi+48]
	mov	edi, DWORD PTR [eax+4]

; 272  :         _Ptr->_Incref();

	mov	ecx, edi
	mov	DWORD PTR $T1[esp+20], edi
	mov	eax, DWORD PTR [edi]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 111  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	mov	ecx, eax
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2150 :         return do_widen(_Byte);

	mov	eax, DWORD PTR [ecx]
	push	10					; 0000000aH
	mov	eax, DWORD PTR [eax+32]
	call	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 111  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

	mov	BYTE PTR $T2[esp+12], al
	test	edi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	je	SHORT $LN14@endl

; 360  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN14@endl
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN14@endl:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 902  :     _Ostr.put(_Ostr.widen('\n'));

	push	DWORD PTR $T2[esp+12]
	mov	ecx, esi
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put

; 903  :     _Ostr.flush();

	mov	ecx, esi
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 904  :     return _Ostr;

	pop	edi
	mov	eax, esi
	pop	esi

; 905  : }

	add	esp, 8
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dur$ = 12						; size = 4
??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z PROC ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,1000000000>,void>, COMDAT

; 365  :         using _CF = ratio_divide<_Period, typename _To::period>;
; 366  : 
; 367  :         using _ToRep = typename _To::rep;
; 368  :         using _CR    = common_type_t<_ToRep, _Rep, intmax_t>;
; 369  : 
; 370  :         constexpr bool _Num_is_one = _CF::num == 1;
; 371  :         constexpr bool _Den_is_one = _CF::den == 1;
; 372  :         return _Num_is_one && _Den_is_one

	mov	eax, DWORD PTR __Dur$[esp-4]
	push	0
	push	1000000					; 000f4240H
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	__alldiv
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], edx

; 373  :                    ? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
; 374  :                    : !_Num_is_one && _Den_is_one
; 375  :                          ? static_cast<_To>(
; 376  :                                static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)))
; 377  :                          : _Num_is_one && !_Den_is_one
; 378  :                                ? static_cast<_To>(
; 379  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) / static_cast<_CR>(_CF::den)))
; 380  :                                : static_cast<_To>(
; 381  :                                      static_cast<_ToRep>(static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
; 382  :                                                          / static_cast<_CR>(_CF::den)));
; 383  :     }

	ret	0
??$duration_cast@V?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@_JU?$ratio@$00$0DLJKMKAA@@3@X@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DOI@@std@@@01@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@@Z ENDP ; std::chrono::duration_cast<std::chrono::duration<__int64,std::ratio<1,1000> >,__int64,std::ratio<1,1000000000>,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z PROC ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT

; 188  :             return _MyDur;

	mov	ecx, DWORD PTR __Left$[esp-4]
	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	sbb	ecx, DWORD PTR [eax+4]

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 475  :         return _Left.time_since_epoch() - _Right.time_since_epoch();
; 476  :     }

	ret	0
??$?GUsteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@V312@@chrono@std@@YA?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@01@ABV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@01@0@Z ENDP ; std::chrono::operator-<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> >,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
;	COMDAT ?time@@YAXP6AXABV?$vector@HV?$allocator@H@std@@@std@@PAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@2@@Z01@Z
_TEXT	SEGMENT
_end$ = -16						; size = 8
$T1 = -8						; size = 8
$T2 = -8						; size = 8
_start$ = -8						; size = 8
_fn$ = 8						; size = 4
_rands$ = 12						; size = 4
_map$ = 16						; size = 4
?time@@YAXP6AXABV?$vector@HV?$allocator@H@std@@@std@@PAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@2@@Z01@Z PROC ; time, COMDAT

; 54   : void time(void (*fn)(const std::vector<int>&, std::map<int, int>*), const std::vector<int>& rands, std::map<int, int>* map){

	sub	esp, 16					; 00000010H
	push	esi

; 55   : 	auto start = chrono::high_resolution_clock::now();

	lea	eax, DWORD PTR _start$[esp+20]
	push	edi
	push	eax
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now

; 56   : 	fn(rands, map);

	push	DWORD PTR _map$[esp+24]
	push	DWORD PTR _rands$[esp+28]
	call	DWORD PTR _fn$[esp+32]

; 57   : 	auto end = chrono::high_resolution_clock::now();

	lea	eax, DWORD PTR _end$[esp+36]
	push	eax
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 249  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	mov	ecx, DWORD PTR _end$[esp+40]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 57   : 	auto end = chrono::high_resolution_clock::now();

	add	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 249  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	sub	ecx, DWORD PTR _start$[esp+24]
	mov	eax, DWORD PTR _end$[esp+28]
	sbb	eax, DWORD PTR _start$[esp+28]

; 372  :         return _Num_is_one && _Den_is_one

	push	0
	push	1000000					; 000f4240H
	push	eax
	push	ecx
	call	__alldiv
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 59   : 	cout << "cold cache took time: " << duration << " milliseconds" << endl;

	push	OFFSET ??_C@_0BH@KLJDGFCF@cold?5cache?5took?5time?3?5@
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 372  :         return _Num_is_one && _Den_is_one

	mov	edi, eax
	mov	esi, edx
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 59   : 	cout << "cold cache took time: " << duration << " milliseconds" << endl;

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	push	OFFSET ??_C@_0O@IALHGEAH@?5milliseconds@
	push	esi
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 172  :         return (*_Pfn)(*this);

	push	eax
	call	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 60   : 	start = chrono::high_resolution_clock::now();

	lea	eax, DWORD PTR $T2[esp+36]
	push	eax
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now

; 61   : 	fn(rands, map);

	push	DWORD PTR _map$[esp+36]
	push	DWORD PTR _rands$[esp+40]
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	call	DWORD PTR _fn$[esp+44]

; 62   : 	end = chrono::high_resolution_clock::now();

	lea	eax, DWORD PTR $T1[esp+48]
	push	eax
	call	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
	add	esp, 28					; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 249  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	sub	ecx, esi

; 372  :         return _Num_is_one && _Den_is_one

	push	0
	push	1000000					; 000f4240H

; 249  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	sbb	eax, edi

; 372  :         return _Num_is_one && _Den_is_one

	push	eax
	push	ecx
	call	__alldiv
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 64   : 	cout << "warm cache took time: " << duration << " milliseconds" << endl;

	push	OFFSET ??_C@_0BH@BJIMNNC@warm?5cache?5took?5time?3?5@
	push	OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 372  :         return _Num_is_one && _Den_is_one

	mov	edi, eax
	mov	esi, edx
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 64   : 	cout << "warm cache took time: " << duration << " milliseconds" << endl;

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	push	OFFSET ??_C@_0O@IALHGEAH@?5milliseconds@
	push	esi
	push	edi
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 172  :         return (*_Pfn)(*this);

	push	eax
	call	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 65   : }

	add	esp, 16					; 00000010H
	ret	0
?time@@YAXP6AXABV?$vector@HV?$allocator@H@std@@@std@@PAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@2@@Z01@Z ENDP ; time
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@X@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V21@@Z
_TEXT	SEGMENT
__Successor$1 = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@X@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V21@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,void>, COMDAT
; _this$ = ecx

; 1090 :     iterator erase(iterator _Where) { // erase element at _Where

	push	ecx
	push	esi

; 1101 :         const_iterator _Successor = _Where;

	mov	esi, DWORD PTR __Where$[esp+4]

; 1090 :     iterator erase(iterator _Where) { // erase element at _Where

	push	edi
	mov	edi, ecx

; 1101 :         const_iterator _Successor = _Where;

	mov	DWORD PTR __Successor$1[esp+12], esi

; 1102 :         ++_Successor; // save successor iterator for return

	lea	ecx, DWORD PTR __Successor$1[esp+12]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++

; 1103 :         _Nodeptr _Erasednode = _My_data._Extract(_Where); // node to erase

	push	esi
	mov	ecx, edi
	call	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Extract
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	ecx, DWORD PTR __Successor$1[esp+12]

; 1091 :         return erase(const_iterator{_Where});

	pop	edi

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	DWORD PTR [eax], ecx

; 1091 :         return erase(const_iterator{_Where});

	pop	esi

; 1092 :     }

	pop	ecx
	ret	8
??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@X@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V21@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--, COMDAT
; _this$ = ecx

; 295  :     _Tree_iterator& operator--() { // predecrement

	push	esi
	mov	esi, ecx

; 296  :         --static_cast<_Mybase&>(*this);

	call	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--

; 297  :         return *this;

	mov	eax, esi
	pop	esi

; 298  :     }

	ret	0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++, COMDAT
; _this$ = ecx

; 290  :         _Tree_iterator _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], edx

; 285  :         ++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++

; 291  :         ++*this;
; 292  :         return _Tmp;

	mov	eax, esi
	pop	esi

; 293  :     }

	ret	8
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++, COMDAT
; _this$ = ecx

; 284  :     _Tree_iterator& operator++() { // preincrement

	push	esi
	mov	esi, ecx

; 285  :         ++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++

; 286  :         return *this;

	mov	eax, esi
	pop	esi

; 287  :     }

	ret	0
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator->, COMDAT
; _this$ = ecx

; 184  :         return this->_Ptr->_Myval;

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 281  :         return pointer_traits<pointer>::pointer_to(**this);
; 282  :     }

	ret	0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator*, COMDAT
; _this$ = ecx

; 184  :         return this->_Ptr->_Myval;

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 277  :         return (reference) * *(_Mybase*) this;
; 278  :     }

	ret	0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >, COMDAT
; _this$ = ecx

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 273  :         : _Mybase(_Pnode, _Plist) { // construct with node pointer _Pnode
; 274  :     }

	mov	eax, ecx
	ret	8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator!=, COMDAT
; _this$ = ecx

; 235  :         return !(*this == _Right);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 236  :     }

	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator==, COMDAT
; _this$ = ecx

; 227  : #if _ITERATOR_DEBUG_LEVEL != 0
; 228  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 229  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 230  : 
; 231  :         return this->_Ptr == _Right._Ptr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 232  :     }

	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--, COMDAT
; _this$ = ecx

; 207  :     _Tree_const_iterator& operator--() { // predecrement

	push	esi
	mov	esi, ecx

; 70   :         if (_Ptr->_Isnil) {

	mov	edx, DWORD PTR [esi]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LN6@operator

; 71   :             _Ptr = _Ptr->_Right; // end() ==> rightmost

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi], eax

; 208  : #if _ITERATOR_DEBUG_LEVEL == 0
; 209  :         --static_cast<_Mybase&>(*this);
; 210  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 211  :         _STL_ASSERT(this->_Getcont(), "cannot decrement value-initialized map/set iterator");
; 212  :         _Nodeptr _Ptrsav = this->_Ptr;
; 213  :         --static_cast<_Mybase&>(*this);
; 214  :         _STL_VERIFY(_Ptrsav != this->_Ptr, "cannot decrement begin map/set iterator");
; 215  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 216  : 
; 217  :         return *this;
; 218  :     }

	mov	eax, esi
	pop	esi
	ret	0
$LN6@operator:

; 72   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree

	mov	ecx, DWORD PTR [edx]
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN8@operator

; 73   :             _Nodeptr _Pnode;
; 74   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {

	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN25@operator
	push	edi
	push	ebx
	mov	ecx, edx
	mov	edi, edx
	push	ebp
	npad	4
$LL4@operator:
	mov	ebx, eax
	mov	ebp, eax
	mov	edx, edi
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN27@operator

; 75   :                 _Ptr = _Pnode; // ==> parent while left subtree

	mov	DWORD PTR [esi], eax
	mov	ecx, eax
	mov	eax, DWORD PTR [eax+4]
	mov	edi, ebp
	mov	edx, ebx
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@operator
$LN27@operator:
	pop	ebp
	pop	ebx
	pop	edi
$LN25@operator:

; 76   :             }
; 77   : 
; 78   :             if (!_Ptr->_Isnil) { // decrement non-begin()

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN29@operator

; 79   :                 _Ptr = _Pnode; // ==> parent if not head

	mov	DWORD PTR [esi], eax

; 208  : #if _ITERATOR_DEBUG_LEVEL == 0
; 209  :         --static_cast<_Mybase&>(*this);
; 210  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 211  :         _STL_ASSERT(this->_Getcont(), "cannot decrement value-initialized map/set iterator");
; 212  :         _Nodeptr _Ptrsav = this->_Ptr;
; 213  :         --static_cast<_Mybase&>(*this);
; 214  :         _STL_VERIFY(_Ptrsav != this->_Ptr, "cannot decrement begin map/set iterator");
; 215  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 216  : 
; 217  :         return *this;
; 218  :     }

	mov	eax, esi
	pop	esi
	ret	0
$LN8@operator:

; 424  :         while (!_Pnode->_Right->_Isnil) {

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN14@operator
$LL13@operator:

; 425  :             _Pnode = _Pnode->_Right;

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL13@operator
$LN14@operator:

; 82   :             _Ptr = _Mytree::_Max(_Ptr->_Left); // ==> largest of left subtree

	mov	DWORD PTR [esi], ecx
$LN29@operator:

; 208  : #if _ITERATOR_DEBUG_LEVEL == 0
; 209  :         --static_cast<_Mybase&>(*this);
; 210  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 211  :         _STL_ASSERT(this->_Getcont(), "cannot decrement value-initialized map/set iterator");
; 212  :         _Nodeptr _Ptrsav = this->_Ptr;
; 213  :         --static_cast<_Mybase&>(*this);
; 214  :         _STL_VERIFY(_Ptrsav != this->_Ptr, "cannot decrement begin map/set iterator");
; 215  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 216  : 
; 217  :         return *this;
; 218  :     }

	mov	eax, esi
	pop	esi
	ret	0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++, COMDAT
; _this$ = ecx

; 191  :     _Tree_const_iterator& operator++() { // preincrement

	push	esi
	mov	esi, ecx
	push	edi

; 49   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR [edx+8]
	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN6@operator

; 50   :             _Nodeptr _Pnode;
; 51   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN21@operator
$LL4@operator:
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN21@operator

; 52   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	DWORD PTR [esi], eax
	mov	edx, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@operator
$LN21@operator:

; 192  : #if _ITERATOR_DEBUG_LEVEL != 0
; 193  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 194  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 196  : 
; 197  :         ++static_cast<_Mybase&>(*this);
; 198  :         return *this;

	mov	DWORD PTR [esi], eax

; 199  :     }

	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
$LN6@operator:

; 432  :         while (!_Pnode->_Left->_Isnil) {

	mov	ecx, DWORD PTR [edi]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN11@operator
	npad	7
$LL10@operator:
	mov	eax, DWORD PTR [ecx]

; 433  :             _Pnode = _Pnode->_Left;

	mov	edi, ecx
	mov	ecx, eax
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL10@operator
$LN11@operator:

; 192  : #if _ITERATOR_DEBUG_LEVEL != 0
; 193  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 194  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 195  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 196  : 
; 197  :         ++static_cast<_Mybase&>(*this);
; 198  :         return *this;

	mov	DWORD PTR [esi], edi

; 199  :     }

	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator*, COMDAT
; _this$ = ecx

; 178  : #if _ITERATOR_DEBUG_LEVEL != 0
; 179  :         const auto _Mycont = static_cast<const _Mytree*>(this->_Getcont());
; 180  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized map/set iterator");
; 181  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");
; 182  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 183  : 
; 184  :         return this->_Ptr->_Myval;

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 185  :     }

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHH@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >, COMDAT
; _this$ = ecx

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 174  :         : _Mybase(_Pnode, _Plist) { // construct with node pointer _Pnode
; 175  :     }

	mov	eax, ecx
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >, COMDAT
; _this$ = ecx

; 32   :     _Tree_unchecked_const_iterator() : _Ptr() { // construct with null node pointer

	mov	DWORD PTR [ecx], 0

; 171  :     }

	mov	eax, ecx
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 69   :     _Tree_unchecked_const_iterator& operator--() { // predecrement

	push	esi
	mov	esi, ecx

; 70   :         if (_Ptr->_Isnil) {

	mov	edx, DWORD PTR [esi]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LN4@operator

; 71   :             _Ptr = _Ptr->_Right; // end() ==> rightmost

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi], eax

; 83   :         }
; 84   : 
; 85   :         return *this;
; 86   :     }

	mov	eax, esi
	pop	esi
	ret	0
$LN4@operator:

; 72   :         } else if (_Ptr->_Left->_Isnil) { // climb looking for left subtree

	mov	ecx, DWORD PTR [edx]
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN6@operator

; 73   :             _Nodeptr _Pnode;
; 74   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {

	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN23@operator
	push	edi
	push	ebx
	mov	ecx, edx
	mov	edi, edx
	push	ebp
	npad	4
$LL2@operator:
	mov	ebx, eax
	mov	ebp, eax
	mov	edx, edi
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN25@operator

; 75   :                 _Ptr = _Pnode; // ==> parent while left subtree

	mov	DWORD PTR [esi], eax
	mov	ecx, eax
	mov	eax, DWORD PTR [eax+4]
	mov	edi, ebp
	mov	edx, ebx
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN25@operator:
	pop	ebp
	pop	ebx
	pop	edi
$LN23@operator:

; 76   :             }
; 77   : 
; 78   :             if (!_Ptr->_Isnil) { // decrement non-begin()

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN27@operator

; 79   :                 _Ptr = _Pnode; // ==> parent if not head

	mov	DWORD PTR [esi], eax

; 83   :         }
; 84   : 
; 85   :         return *this;
; 86   :     }

	mov	eax, esi
	pop	esi
	ret	0
$LN6@operator:

; 424  :         while (!_Pnode->_Right->_Isnil) {

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN12@operator
$LL11@operator:

; 425  :             _Pnode = _Pnode->_Right;

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL11@operator
$LN12@operator:

; 80   :             }
; 81   :         } else {
; 82   :             _Ptr = _Mytree::_Max(_Ptr->_Left); // ==> largest of left subtree

	mov	DWORD PTR [esi], ecx
$LN27@operator:

; 83   :         }
; 84   : 
; 85   :         return *this;
; 86   :     }

	mov	eax, esi
	pop	esi
	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 48   :     _Tree_unchecked_const_iterator& operator++() { // preincrement

	push	esi
	mov	esi, ecx
	push	edi

; 49   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR [edx+8]
	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN4@operator

; 50   :             _Nodeptr _Pnode;
; 51   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN19@operator
$LL2@operator:
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN19@operator

; 52   :                 _Ptr = _Pnode; // ==> parent while right subtree

	mov	DWORD PTR [esi], eax
	mov	edx, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN19@operator:

; 53   :             }
; 54   : 
; 55   :             _Ptr = _Pnode; // ==> parent (head if end())
; 56   :         } else {
; 57   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 58   :         }
; 59   : 
; 60   :         return *this;

	mov	DWORD PTR [esi], eax

; 61   :     }

	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
$LN4@operator:

; 432  :         while (!_Pnode->_Left->_Isnil) {

	mov	ecx, DWORD PTR [edi]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN9@operator
	npad	7
$LL8@operator:
	mov	eax, DWORD PTR [ecx]

; 433  :             _Pnode = _Pnode->_Left;

	mov	edi, ecx
	mov	ecx, eax
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL8@operator
$LN9@operator:

; 53   :             }
; 54   : 
; 55   :             _Ptr = _Pnode; // ==> parent (head if end())
; 56   :         } else {
; 57   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 58   :         }
; 59   : 
; 60   :         return *this;

	mov	DWORD PTR [esi], edi

; 61   :     }

	mov	eax, esi
	pop	edi
	pop	esi
	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [ecx], eax

; 37   :         this->_Adopt(_Plist);
; 38   :     }

	mov	eax, ecx
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 32   :     _Tree_unchecked_const_iterator() : _Ptr() { // construct with null node pointer

	mov	DWORD PTR [ecx], 0

; 33   :     }

	mov	eax, ecx
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@QBEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z
_TEXT	SEGMENT
__Umin$1$ = -16						; size = 4
__Rng$1 = -12						; size = 12
__Eng$ = 8						; size = 4
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@QBEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z PROC ; std::uniform_int<int>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >, COMDAT
; _this$ = ecx

; 1840 :     _NODISCARD result_type operator()(_Engine& _Eng) const { // return next value

	sub	esp, 16					; 00000010H

; 1841 :         return _Eval(_Eng, _Par._Min, _Par._Max);

	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	cmp	ecx, -2147483648			; 80000000H

; 1840 :     _NODISCARD result_type operator()(_Engine& _Eng) const { // return next value

	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	ebx, DWORD PTR __Eng$[esp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1840 :     _NODISCARD result_type operator()(_Engine& _Eng) const { // return next value

	push	ebp

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	lea	eax, DWORD PTR [ecx-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$1[esp+24], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	lea	ebp, DWORD PTR [ecx-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$1[esp+28], 32		; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1876 :         const _Uty _Umin = _Adjust(_Uty(_Min));

	cmovae	ebp, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$1[esp+32], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1840 :     _NODISCARD result_type operator()(_Engine& _Eng) const { // return next value

	push	esi

; 1877 :         const _Uty _Umax = _Adjust(_Uty(_Max));

	cmp	edx, -2147483648			; 80000000H
	mov	DWORD PTR __Umin$1$[esp+28], ebp
	lea	eax, DWORD PTR [edx-2147483648]
	lea	esi, DWORD PTR [edx-2147483648]
	cmovae	esi, eax

; 1878 : 
; 1879 :         _Uty _Uret;
; 1880 : 
; 1881 :         if (_Umax - _Umin == _Uty(-1)) {

	sub	esi, ebp
	cmp	esi, -1
	jne	SHORT $LN4@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3304 :             _Ret |= _Get_bits();

	lea	ecx, DWORD PTR __Rng$1[esp+28]
	call	?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1882 :             _Uret = static_cast<_Uty>(_Rng._Get_all_bits());

	mov	edx, eax

; 1883 :         } else {

	jmp	SHORT $LN35@operator
$LN4@operator:

; 1884 :             _Uret = static_cast<_Uty>(_Rng(static_cast<_Uty>(_Umax - _Umin + 1)));

	lea	ebp, DWORD PTR [esi+1]
	push	edi
	npad	7
$LL34@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3279 :             _Udiff _Ret  = 0; // random bits

	xor	edi, edi

; 3280 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

	xor	eax, eax

; 3281 : 
; 3282 :             while (_Mask < _Udiff(_Index - 1)) { // need more random bits

	test	esi, esi
	je	SHORT $LN38@operator

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	mov	ecx, ebx
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
	mov	edi, eax

; 3288 :                 _Mask |= _Bmask;

	or	eax, -1
$LN38@operator:

; 3289 :             }
; 3290 : 
; 3291 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3292 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

	xor	edx, edx
	div	ebp
	mov	ecx, eax
	mov	ebx, edx
	xor	edx, edx
	mov	eax, edi
	div	ebp
	cmp	eax, ecx
	jb	SHORT $LN63@operator
	cmp	ebx, esi
	mov	ebx, DWORD PTR __Eng$[esp+28]
	jne	SHORT $LL34@operator
$LN63@operator:

; 3293 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, edi
	xor	edx, edx
	div	ebp
	mov	ebp, DWORD PTR __Umin$1$[esp+32]
	pop	edi
$LN35@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1887 :         return _Ty(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	ecx, DWORD PTR [edx+ebp]

; 1841 :         return _Eval(_Eng, _Par._Min, _Par._Max);

	pop	esi
	cmp	ecx, -2147483648			; 80000000H
	lea	edx, DWORD PTR [ecx-2147483648]
	lea	eax, DWORD PTR [ecx-2147483648]
	pop	ebp
	cmovae	eax, edx
	pop	ebx

; 1842 :     }

	add	esp, 16					; 00000010H
	ret	4
??$?RV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@?$uniform_int@H@std@@QBEHAAV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@1@@Z ENDP ; std::uniform_int<int>::operator()<std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??0?$uniform_int_distribution@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0?$uniform_int_distribution@H@std@@QAE@HH@Z PROC	; std::uniform_int_distribution<int>::uniform_int_distribution<int>, COMDAT
; _this$ = ecx

; 1798 :             _Min = _Min0;

	mov	eax, DWORD PTR __Min0$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1799 :             _Max = _Max0;

	mov	eax, DWORD PTR __Max0$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 1945 :         : _Mybase(_Min0, _Max0) { // construct from parameters
; 1946 :     }

	mov	eax, ecx
	ret	8
??0?$uniform_int_distribution@H@std@@QAE@HH@Z ENDP	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z PROC	; std::uniform_int<int>::param_type::_Init, COMDAT
; _this$ = ecx

; 1797 :             _STL_ASSERT(_Min0 <= _Max0, "invalid min and max arguments for uniform_int");
; 1798 :             _Min = _Min0;

	mov	eax, DWORD PTR __Min0$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1799 :             _Max = _Max0;

	mov	eax, DWORD PTR __Max0$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 1800 :         }

	ret	8
?_Init@param_type@?$uniform_int@H@std@@QAEXHH@Z ENDP	; std::uniform_int<int>::param_type::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??0param_type@?$uniform_int@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0param_type@?$uniform_int@H@std@@QAE@HH@Z PROC	; std::uniform_int<int>::param_type::param_type, COMDAT
; _this$ = ecx

; 1798 :             _Min = _Min0;

	mov	eax, DWORD PTR __Min0$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1799 :             _Max = _Max0;

	mov	eax, DWORD PTR __Max0$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 1777 :             _Init(_Min0, _Max0);
; 1778 :         }

	mov	eax, ecx
	ret	8
??0param_type@?$uniform_int@H@std@@QAE@HH@Z ENDP	; std::uniform_int<int>::param_type::param_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Uval$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z PROC ; std::uniform_int<int>::_Adjust, COMDAT

; 1895 :         const _Uty _Adjuster = (_Uty(-1) >> 1) + 1; // 2^(N-1)
; 1896 : 
; 1897 :         if (_Uval < _Adjuster) {

	mov	eax, DWORD PTR __Uval$[esp-4]

; 1898 :             return static_cast<_Uty>(_Uval + _Adjuster);
; 1899 :         } else {
; 1900 :             return static_cast<_Uty>(_Uval - _Adjuster);
; 1901 :         }
; 1902 :     }

	add	eax, -2147483648			; 80000000H
	ret	0
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ENDP ; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAII@Z
_TEXT	SEGMENT
__Uval$ = 8						; size = 4
?_Adjust@?$uniform_int@H@std@@CAII@Z PROC		; std::uniform_int<int>::_Adjust, COMDAT

; 1891 :         return _Adjust(_Uval, is_signed<_Ty>());

	mov	ecx, DWORD PTR __Uval$[esp-4]
	cmp	ecx, -2147483648			; 80000000H
	lea	edx, DWORD PTR [ecx-2147483648]
	lea	eax, DWORD PTR [ecx-2147483648]
	cmovae	eax, edx

; 1892 :     }

	ret	0
?_Adjust@?$uniform_int@H@std@@CAII@Z ENDP		; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??0?$uniform_int@H@std@@QAE@HH@Z
_TEXT	SEGMENT
__Min0$ = 8						; size = 4
__Max0$ = 12						; size = 4
??0?$uniform_int@H@std@@QAE@HH@Z PROC			; std::uniform_int<int>::uniform_int<int>, COMDAT
; _this$ = ecx

; 1798 :             _Min = _Min0;

	mov	eax, DWORD PTR __Min0$[esp-4]
	mov	DWORD PTR [ecx], eax

; 1799 :             _Max = _Max0;

	mov	eax, DWORD PTR __Max0$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 1807 :     }

	mov	eax, ecx
	ret	8
??0?$uniform_int@H@std@@QAE@HH@Z ENDP			; std::uniform_int<int>::uniform_int<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?max@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ
_TEXT	SEGMENT
?max@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::max, COMDAT

; 1306 :         return _Mybase::_WMSK;

	or	eax, -1

; 1307 :     }

	ret	0
?max@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?min@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ
_TEXT	SEGMENT
?min@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::min, COMDAT

; 1302 :         return 0;

	xor	eax, eax

; 1303 :     }

	ret	0
?min@?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@SAIXZ ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z PROC ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>, COMDAT
; _this$ = ecx

; 1101 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

	mov	edx, DWORD PTR __X0$[esp-4]

; 1257 :     explicit mersenne_twister_engine(result_type _X0 = default_seed)

	push	esi
	push	edi

; 1090 :         : _Dxval(_Dxarg) { // construct with specified seed

	mov	DWORD PTR [ecx+4996], -1
	lea	edi, DWORD PTR [ecx+8]

; 1101 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

	mov	DWORD PTR [ecx+4], edx

; 1090 :         : _Dxval(_Dxarg) { // construct with specified seed

	mov	esi, 1
	npad	5
$LL8@mersenne_t:

; 1103 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	eax, edx
	lea	edi, DWORD PTR [edi+4]
	shr	eax, 30					; 0000001eH
	xor	eax, edx
	imul	edx, eax, 1812433253
	add	edx, esi
	inc	esi
	mov	DWORD PTR [edi-4], edx
	cmp	esi, 624				; 00000270H
	jl	SHORT $LL8@mersenne_t

; 1258 :         : _Mybase(_X0, _Dx, _Fx) { // construct with default seed
; 1259 :     }

	pop	edi

; 1106 :         this->_Idx = _Nx;

	mov	DWORD PTR [ecx], 624			; 00000270H

; 1258 :         : _Mybase(_X0, _Dx, _Fx) { // construct with default seed
; 1259 :     }

	mov	eax, ecx
	pop	esi
	ret	4
??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z ENDP ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ
_TEXT	SEGMENT
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper, COMDAT
; _this$ = ecx

; 1176 :     void _Refill_upper() { // compute values for the upper half of the history array

	push	esi

; 1177 :         int _Ix;
; 1178 :         for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { // fill in values

	lea	eax, DWORD PTR [ecx+8]
	mov	esi, 624				; 00000270H
	npad	7
$LL4@Refill_upp:

; 1179 :             _Ty _Tmp       = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + 1] & _LMSK);

	mov	edx, DWORD PTR [eax-4]
	lea	eax, DWORD PTR [eax+4]
	xor	edx, DWORD PTR [eax-4]
	and	edx, 2147483647				; 7fffffffH
	xor	edx, DWORD PTR [eax-8]

; 1180 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	ecx, edx
	and	cl, 1
	movzx	ecx, cl
	neg	ecx
	sbb	ecx, ecx
	shr	edx, 1
	and	ecx, -1727483681			; 9908b0dfH
	xor	ecx, DWORD PTR [eax+1580]
	xor	ecx, edx
	mov	DWORD PTR [eax+2488], ecx
	sub	esi, 1
	jne	SHORT $LL4@Refill_upp

; 1181 :         }
; 1182 :     }

	pop	esi
	ret	0
?_Refill_upper@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_upper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ
_TEXT	SEGMENT
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower, COMDAT
; _this$ = ecx

; 1159 :         void _Refill_lower() { // compute values for the lower half of the history array

	push	ebx
	push	ebp
	mov	ebx, ecx

; 1160 :         int _Ix;
; 1161 :         for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix) { // fill in lower region

	mov	ebp, 227				; 000000e3H
	mov	eax, DWORD PTR [ebx+2500]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebx+2500]
$LL4@Refill_low:

; 1162 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [edi+4]
	xor	ecx, eax
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1163 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [edi+1588]
	xor	eax, ecx
	mov	DWORD PTR [edi-2496], eax
	lea	edi, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL4@Refill_low

; 1164 :         }
; 1165 : 
; 1166 :         for (; _Ix < _Nx - 1; ++_Ix) { // fill in upper region (avoids modulus operation)

	mov	eax, DWORD PTR [ebx+3408]
	lea	edi, DWORD PTR [ebx+3408]
	mov	ebp, 396				; 0000018cH
$LL7@Refill_low:

; 1167 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [edi+4]
	xor	ecx, eax
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1168 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [edi-3404]
	xor	eax, ecx
	mov	DWORD PTR [edi-2496], eax
	lea	edi, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL7@Refill_low

; 1169 :         }
; 1170 : 
; 1171 :         _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

	mov	ecx, DWORD PTR [ebx+4992]
	xor	ecx, DWORD PTR [ebx+4]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, DWORD PTR [ebx+4992]

; 1172 :         this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax

; 1173 :         this->_Idx     = 0;

	pop	edi
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [ebx+1588]
	pop	esi
	xor	eax, ecx
	mov	DWORD PTR [ebx+2496], eax
	pop	ebp
	mov	DWORD PTR [ebx], 0
	pop	ebx

; 1174 :     }

	ret	0
?_Refill_lower@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@IAEXXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::_Refill_lower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ
_TEXT	SEGMENT
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator(), COMDAT
; _this$ = ecx

; 1135 :     _NODISCARD result_type operator()() { // return next value

	push	esi
	push	edi
	mov	edi, ecx

; 1136 :         if (this->_Idx == _Nx) {

	mov	eax, DWORD PTR [edi]
	cmp	eax, 624				; 00000270H
	jne	SHORT $LN2@operator

; 1178 :         for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix) { // fill in values

	lea	edx, DWORD PTR [edi+8]
	mov	esi, eax
$LL9@operator:

; 1179 :             _Ty _Tmp       = (this->_Ax[_Ix - _Nx] & _HMSK) | (this->_Ax[_Ix - _Nx + 1] & _LMSK);

	mov	ecx, DWORD PTR [edx-4]
	lea	edx, DWORD PTR [edx+4]
	xor	ecx, DWORD PTR [edx-4]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, DWORD PTR [edx-8]

; 1180 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [edx+1580]
	xor	eax, ecx
	mov	DWORD PTR [edx+2488], eax
	sub	esi, 1
	jne	SHORT $LL9@operator

; 1181 :         }
; 1182 :     }

	mov	eax, DWORD PTR [edi]
	jmp	$LN4@operator
$LN2@operator:

; 1137 :             _Refill_upper();
; 1138 :         } else if (2 * _Nx <= this->_Idx) {

	cmp	eax, 1248				; 000004e0H
	jb	$LN4@operator

; 1161 :         for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix) { // fill in lower region

	mov	eax, DWORD PTR [edi+2500]
	push	ebx
	lea	ebx, DWORD PTR [edi+2500]
	push	ebp
	mov	ebp, 227				; 000000e3H
	npad	2
$LL14@operator:

; 1162 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR [ebx+4]
	xor	ecx, eax
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1163 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [ebx+1588]
	xor	eax, ecx
	mov	DWORD PTR [ebx-2496], eax
	lea	ebx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL14@operator

; 1164 :         }
; 1165 : 
; 1166 :         for (; _Ix < _Nx - 1; ++_Ix) { // fill in upper region (avoids modulus operation)

	mov	eax, DWORD PTR [edi+3408]
	lea	ebx, DWORD PTR [edi+3408]
	mov	ebp, 396				; 0000018cH
	npad	6
$LL17@operator:

; 1167 :             _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[_Ix + _Nx + 1] & _LMSK);

	mov	ecx, eax
	lea	edx, DWORD PTR [ebx+4]
	xor	ecx, DWORD PTR [edx]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, eax

; 1168 :             this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [ebx-3404]
	xor	eax, ecx
	mov	DWORD PTR [ebx-2496], eax
	lea	ebx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx]
	sub	ebp, 1
	jne	SHORT $LL17@operator

; 1169 :         }
; 1170 : 
; 1171 :         _Ty _Tmp       = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

	mov	ecx, DWORD PTR [edi+4992]
	xor	ecx, DWORD PTR [edi+4]
	and	ecx, 2147483647				; 7fffffffH
	xor	ecx, DWORD PTR [edi+4992]

; 1172 :         this->_Ax[_Ix] = (_Tmp >> 1) ^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];

	mov	eax, ecx
	and	al, 1
	movzx	eax, al
	neg	eax

; 1173 :         this->_Idx     = 0;

	pop	ebp
	sbb	eax, eax
	shr	ecx, 1
	and	eax, -1727483681			; 9908b0dfH
	xor	eax, DWORD PTR [edi+1588]
	xor	eax, ecx
	mov	DWORD PTR [edi+2496], eax
	xor	eax, eax
	mov	DWORD PTR [edi], 0
	pop	ebx
$LN4@operator:

; 1139 :             _Refill_lower();
; 1140 :         }
; 1141 : 
; 1142 :         _Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

	mov	edx, DWORD PTR [edi+eax*4+4]
	inc	eax
	mov	DWORD PTR [edi], eax

; 1143 :         _Res ^= (_Res >> _Ux) & _Dxval;

	mov	ecx, edx
	mov	eax, DWORD PTR [edi+4996]
	shr	ecx, 11					; 0000000bH
	and	eax, ecx
	xor	edx, eax

; 1144 :         _Res ^= (_Res << _Sx) & _Bx;

	mov	eax, edx
	and	eax, -12953427				; ff3a58adH
	shl	eax, 7
	xor	edx, eax

; 1145 :         _Res ^= (_Res << _Tx) & _Cx;

	mov	eax, edx
	and	eax, -8308				; ffffdf8cH
	shl	eax, 15					; 0000000fH
	xor	edx, eax

; 1146 :         _Res ^= (_Res & _WMSK) >> _Lx;

	mov	eax, edx
	shr	eax, 18					; 00000012H

; 1147 :         return _Res;

	pop	edi
	xor	eax, edx
	pop	esi

; 1148 :     }

	ret	0
??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
__Fx$ = 12						; size = 4
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed, COMDAT
; _this$ = ecx

; 1101 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

	mov	edx, DWORD PTR __X0$[esp-4]
	mov	eax, 1
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Fx$[esp+8]
	mov	DWORD PTR [ebx+4], edx
	lea	esi, DWORD PTR [ebx+8]
$LL4@seed:

; 1102 :         for (int _Ix = 1; _Ix < _Nx; ++_Ix) {
; 1103 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	ecx, edx
	lea	esi, DWORD PTR [esi+4]
	shr	ecx, 30					; 0000001eH
	xor	edx, ecx
	imul	edx, edi
	add	edx, eax
	inc	eax
	mov	DWORD PTR [esi-4], edx
	cmp	eax, 624				; 00000270H
	jl	SHORT $LL4@seed

; 1104 :         }
; 1105 : 
; 1106 :         this->_Idx = _Nx;

	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], 624			; 00000270H
	pop	ebx

; 1107 :     }

	ret	8
?seed@?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEXII@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::seed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
;	COMDAT ??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z
_TEXT	SEGMENT
__X0$ = 8						; size = 4
__Dxarg$ = 12						; size = 4
__Fxarg$ = 16						; size = 4
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z PROC ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>, COMDAT
; _this$ = ecx

; 1089 :         _Ty _Fxarg = (_Ty) 1812433253)
; 1090 :         : _Dxval(_Dxarg) { // construct with specified seed

	mov	eax, DWORD PTR __Dxarg$[esp-4]

; 1101 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

	mov	edx, DWORD PTR __X0$[esp-4]

; 1088 :     explicit mersenne_twister(_Ty _X0 = default_seed, _Ty _Dxarg = _WMSK,

	push	ebx

; 1089 :         _Ty _Fxarg = (_Ty) 1812433253)
; 1090 :         : _Dxval(_Dxarg) { // construct with specified seed

	mov	ebx, DWORD PTR __Fxarg$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+4996], eax
	lea	esi, DWORD PTR [edi+8]

; 1101 :         _Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

	mov	DWORD PTR [edi+4], edx

; 1089 :         _Ty _Fxarg = (_Ty) 1812433253)
; 1090 :         : _Dxval(_Dxarg) { // construct with specified seed

	mov	eax, 1
$LL6@mersenne_t:

; 1103 :             _Prev = this->_Ax[_Ix] = (_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

	mov	ecx, edx
	lea	esi, DWORD PTR [esi+4]
	shr	ecx, 30					; 0000001eH
	xor	edx, ecx
	imul	edx, ebx
	add	edx, eax
	inc	eax
	mov	DWORD PTR [esi-4], edx
	cmp	eax, 624				; 00000270H
	jl	SHORT $LL6@mersenne_t

; 1104 :         }
; 1105 : 
; 1106 :         this->_Idx = _Nx;

	mov	DWORD PTR [edi], 624			; 00000270H

; 1091 :         seed(_X0, _Fxarg);
; 1092 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	ret	12					; 0000000cH
??0?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAE@III@Z ENDP ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Pad$ = -40						; size = 8
__Ok$$sroa$273$ = -32					; size = 4
__Count$1$ = -28					; size = 4
tv790 = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 696  :     const char* _Val) { // insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 697  :     using _Elem = char;
; 698  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 699  : 
; 700  :     ios_base::iostate _State = ios_base::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	ecx, DWORD PTR __Val$[ebp]
	lea	edx, DWORD PTR [ecx+1]
$LL107@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL107@operator
	sub	ecx, edx
	mov	DWORD PTR __Count$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 702  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 389  :         return _Wide;

	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+edx+32]
	mov	edi, DWORD PTR [eax+edx+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 702  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN109@operator
	test	esi, esi
	je	SHORT $LN17@operator
	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN109@operator
	cmp	esi, ecx
	jbe	SHORT $LN17@operator
$LN109@operator:
	sub	esi, ecx
	sbb	edi, ebx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	edi, DWORD PTR __Pad$[ebp+4]
	mov	esi, DWORD PTR __Pad$[ebp]
$LN18@operator:

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	DWORD PTR __Ok$$sroa$273$[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	ecx, DWORD PTR [eax+edx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	test	ecx, ecx
	je	SHORT $LN116@operator

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Ostr$[ebp]
$LN116@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, edx
	mov	DWORD PTR tv790[ebp], eax
	mov	eax, ecx

; 321  :         return rdstate() == ios_base::goodbit;

	mov	edx, DWORD PTR tv790[ebp]
	cmp	DWORD PTR [edx+12], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	mov	edx, DWORD PTR __Ostr$[ebp]
	jne	SHORT $LN32@operator
	mov	edx, DWORD PTR tv790[ebp]
	cmp	DWORD PTR [edx+60], ebx
	mov	edx, DWORD PTR __Ostr$[ebp]
	je	SHORT $LN32@operator
	mov	ebx, DWORD PTR tv790[ebp]
	mov	ecx, DWORD PTR [ebx+60]
	cmp	ecx, edx
	mov	ebx, 0
	je	SHORT $LN32@operator

; 91   :                 _Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
$LN32@operator:

; 703  :     const typename _Myos::sentry _Ok(_Ostr);
; 704  : 
; 705  :     if (!_Ok) {

	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+edx+12], 0
	je	SHORT $LN8@operator

; 706  :         _State |= ios_base::badbit;

	mov	ebx, 4

; 707  :     } else { // state okay, insert

	jmp	$LN21@operator
$LN8@operator:

; 708  :         _TRY_IO_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 709  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	ecx, DWORD PTR [edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 352  :         return _Fmtfl;

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+edx+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 709  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN103@operator
$LL4@operator:

; 710  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	edi, edi
	jl	SHORT $LN3@operator
	jg	SHORT $LN110@operator
	test	esi, esi
	je	SHORT $LN3@operator
$LN110@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]

; 97   :         return _Fillch;

	mov	al, BYTE PTR [eax+edx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 711  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	push	eax
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 711  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	je	SHORT $LN111@operator

; 710  :             for (; 0 < _Pad; --_Pad) { // pad on left

	add	esi, -1
	mov	DWORD PTR __Pad$[ebp], esi
	adc	edi, -1
	mov	DWORD PTR __Pad$[ebp+4], edi
	mov	edx, DWORD PTR __Ostr$[ebp]
	jmp	SHORT $LL4@operator
$LN3@operator:

; 718  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	mov	ecx, DWORD PTR [edx]
$LN103@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 718  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	push	0
	push	DWORD PTR __Count$1$[ebp]
	push	DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+edx+56]
	call	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
	cmp	eax, DWORD PTR __Count$1$[ebp]
	jne	SHORT $LN111@operator
	test	edx, edx
	jne	SHORT $LN111@operator
$LL113@operator:

; 719  :             _State |= ios_base::badbit;
; 720  :         }
; 721  : 
; 722  :         if (_State == ios_base::goodbit) {
; 723  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	edi, edi
	jl	SHORT $LN6@operator
	jg	SHORT $LN112@operator
	test	esi, esi
	je	SHORT $LN6@operator
$LN112@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]

; 97   :         return _Fillch;

	mov	al, BYTE PTR [eax+edx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 724  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	push	eax
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 724  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	je	SHORT $LN111@operator

; 719  :             _State |= ios_base::badbit;
; 720  :         }
; 721  : 
; 722  :         if (_State == ios_base::goodbit) {
; 723  :             for (; 0 < _Pad; --_Pad) { // pad on right

	add	esi, -1
	mov	DWORD PTR __Pad$[ebp], esi
	adc	edi, -1
	mov	DWORD PTR __Pad$[ebp+4], edi
	jmp	SHORT $LL113@operator
$LN111@operator:

; 725  :                     _State |= ios_base::badbit; // insertion failed, quit
; 726  :                     break;
; 727  :                 }
; 728  :             }
; 729  :         }
; 730  : 
; 731  :         _Ostr.width(0);

	mov	ebx, 4
	mov	DWORD PTR __State$[ebp], ebx
$LN6@operator:
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	DWORD PTR [eax+edx+32], 0
	mov	DWORD PTR [eax+edx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN21@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 732  :         _CATCH_IO_(ios_base, _Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	push	1
	push	4
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN22@operator
	ret	0
$LN22@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	ebx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR __Ostr$[ebp]
$LN21@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 733  :     }
; 734  : 
; 735  :     _Ostr.setstate(_State);

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 50   :         clear(rdstate() | _State, _Reraise);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, ebx

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	0
	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	mov	esi, DWORD PTR __Ok$$sroa$273$[ebp]
	test	al, al
	jne	SHORT $LN88@operator

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, esi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN88@operator:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+esi+56]
	test	ecx, ecx
	je	SHORT $LN114@operator

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN114@operator:

; 736  :     return _Ostr;
; 737  : }

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
__Ok$1 = -8						; size = 8
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 507  :     basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 508  :         if (_Myios::rdbuf() != nullptr) { // buffer exists, flush it

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+56], 0
	je	SHORT $LN56@flush

; 509  :             const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$1[esp+16]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 511  :             if (_Ok && _Myios::rdbuf()->pubsync() == -1) {

	cmp	BYTE PTR __Ok$1[esp+16], 0
	je	SHORT $LN3@flush
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 121  :         return sync();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+52]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 511  :             if (_Ok && _Myios::rdbuf()->pubsync() == -1) {

	cmp	eax, -1
	jne	SHORT $LN3@flush

; 512  :                 _Myios::setstate(ios_base::badbit); // sync failed

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 512  :                 _Myios::setstate(ios_base::badbit); // sync failed

	mov	ecx, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	mov	eax, DWORD PTR [ecx+esi+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 512  :                 _Myios::setstate(ios_base::badbit); // sync failed

	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	or	eax, 4
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN3@flush:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN46@flush

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, DWORD PTR __Ok$1[esp+12]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN46@flush:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	ecx, DWORD PTR __Ok$1[esp+12]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN56@flush

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN56@flush:

; 513  :             }
; 514  :         }
; 515  :         return *this;
; 516  :     }

	mov	eax, esi
	pop	esi
	add	esp, 8
	ret	0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ch$ = 8						; size = 1
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::put, COMDAT
; _this$ = ecx

; 470  :     basic_ostream& __CLR_OR_THIS_CALL put(_Elem _Ch) { // insert a character

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 471  :         ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __State$[ebp], edi

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	mov	edx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	test	ecx, ecx
	je	SHORT $LN15@put

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi]
$LN15@put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, edx

; 321  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [ecx+esi+12], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	jne	SHORT $LN12@put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 67   :         return _Tiestr;

	mov	ecx, DWORD PTR [ecx+esi+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	test	ecx, ecx
	je	SHORT $LN12@put
	cmp	ecx, esi
	je	SHORT $LN12@put

; 91   :                 _Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, DWORD PTR [esi]
$LN12@put:

; 472  :         const sentry _Ok(*this);
; 473  : 
; 474  :         if (!_Ok) {

	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+12], edi
	je	SHORT $LN2@put

; 475  :             _State |= ios_base::badbit;

	mov	edi, 4

; 476  :         } else { // state okay, insert character

	jmp	SHORT $LN9@put
$LN2@put:

; 477  :             _TRY_IO_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 478  :             if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch))) {

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, DWORD PTR [eax+esi+56]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 478  :             if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch))) {

	cmove	edi, ecx
	mov	DWORD PTR __State$[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN9@put
__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0:

; 479  :                 _State |= ios_base::badbit;
; 480  :             }
; 481  :             _CATCH_IO_END

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	push	1
	push	4
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN10@put
	ret	0
$LN10@put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN9@put:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 482  :         }
; 483  : 
; 484  :         _Myios::setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 50   :         clear(rdstate() | _State, _Reraise);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, edi

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	0
	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN52@put

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, esi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN52@put:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN61@put

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN61@put:

; 485  :         return *this;
; 486  :     }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::put
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
_TEXT	SEGMENT
__State$ = -32						; size = 4
_this$ = -28						; size = 4
$T2 = -24						; size = 8
$T3 = -24						; size = 8
__Nput_fac$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
$T4 = 8							; size = 8
__Val$ = 8						; size = 8
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 323  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(long long _Val) { // insert a long long

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 324  :         ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __State$[ebp], edi

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	mov	edx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	test	ecx, ecx
	je	SHORT $LN14@operator

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi]
$LN14@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, edx

; 321  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [ecx+esi+12], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	jne	SHORT $LN11@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 67   :         return _Tiestr;

	mov	ecx, DWORD PTR [ecx+esi+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	test	ecx, ecx
	je	SHORT $LN11@operator
	cmp	ecx, esi
	je	SHORT $LN11@operator

; 91   :                 _Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, DWORD PTR [esi]
$LN11@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 327  :         if (_Ok) { // state okay, use facet to insert

	cmp	DWORD PTR [eax+esi+12], edi
	jne	$LN8@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 399  :         return *_Ploc;

	mov	eax, DWORD PTR [eax+esi+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR $T3[ebp+4], edi

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 328  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	mov	edx, eax
	mov	DWORD PTR __Nput_fac$1$[ebp], edx
	test	edi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	je	SHORT $LN43@operator

; 360  :             delete _Ptr->_Decref();

	mov	edx, DWORD PTR [edi]
	mov	ecx, edi
	mov	edx, DWORD PTR [edx+8]
	call	edx
	test	eax, eax
	je	SHORT $LN72@operator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	1
	mov	ecx, eax
	call	edx
$LN72@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 330  :             _TRY_IO_BEGIN

	mov	edx, DWORD PTR __Nput_fac$1$[ebp]
$LN43@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 97   :         return _Fillch;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR [eax+esi]
	mov	al, BYTE PTR [ecx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 555  :         : _Failed(false), _Strbuf(_Sb) { // construct from stream buffer _Sb

	mov	BYTE PTR $T2[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 331  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {

	push	DWORD PTR __Val$[ebp+4]
	push	DWORD PTR __Val$[ebp]
	push	eax
	push	ecx
	push	DWORD PTR [ecx+56]
	push	DWORD PTR $T2[ebp]
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, edx
	call	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 583  :         return _Failed;

	mov	al, BYTE PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 331  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {

	xor	edi, edi
	mov	ecx, 4
	test	al, al
	cmovne	edi, ecx
	mov	DWORD PTR __State$[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN8@operator
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z$0:

; 332  :                 _State |= ios_base::badbit;
; 333  :             }
; 334  :             _CATCH_IO_END

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	push	1
	push	4
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN9@operator
	ret	0
$LN9@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN8@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 335  :         }
; 336  : 
; 337  :         _Myios::setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 50   :         clear(rdstate() | _State, _Reraise);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, edi

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	0
	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN62@operator

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, esi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN62@operator:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN71@operator

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN71@operator:

; 338  :         return *this;
; 339  :     }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@_J@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
_TEXT	SEGMENT
__State$ = -32						; size = 4
_this$ = -28						; size = 4
$T2 = -24						; size = 8
$T3 = -24						; size = 8
$T4 = -24						; size = 8
__Nput_fac$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 269  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(unsigned int _Val) { // insert an unsigned int

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 270  :         ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __State$[ebp], edi

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	mov	edx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	test	ecx, ecx
	je	SHORT $LN14@operator

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi]
$LN14@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, edx

; 321  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [ecx+esi+12], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	jne	SHORT $LN11@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 67   :         return _Tiestr;

	mov	ecx, DWORD PTR [ecx+esi+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	test	ecx, ecx
	je	SHORT $LN11@operator
	cmp	ecx, esi
	je	SHORT $LN11@operator

; 91   :                 _Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, DWORD PTR [esi]
$LN11@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 273  :         if (_Ok) { // state okay, use facet to insert

	cmp	DWORD PTR [eax+esi+12], edi
	jne	$LN8@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 399  :         return *_Ploc;

	mov	eax, DWORD PTR [eax+esi+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR $T4[ebp+4], edi

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 274  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	mov	edx, eax
	mov	DWORD PTR __Nput_fac$1$[ebp], edx
	test	edi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	je	SHORT $LN43@operator

; 360  :             delete _Ptr->_Decref();

	mov	edx, DWORD PTR [edi]
	mov	ecx, edi
	mov	edx, DWORD PTR [edx+8]
	call	edx
	test	eax, eax
	je	SHORT $LN72@operator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	1
	mov	ecx, eax
	call	edx
$LN72@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 276  :             _TRY_IO_BEGIN

	mov	edx, DWORD PTR __Nput_fac$1$[ebp]
$LN43@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 97   :         return _Fillch;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR [eax+esi]
	mov	al, BYTE PTR [ecx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 555  :         : _Failed(false), _Strbuf(_Sb) { // construct from stream buffer _Sb

	mov	BYTE PTR $T3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 277  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long) _Val).failed()) {

	push	DWORD PTR __Val$[ebp]
	push	eax
	push	ecx
	push	DWORD PTR [ecx+56]
	push	DWORD PTR $T3[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, edx
	call	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 583  :         return _Failed;

	mov	al, BYTE PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 277  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), (unsigned long) _Val).failed()) {

	xor	edi, edi
	mov	ecx, 4
	test	al, al
	cmovne	edi, ecx
	mov	DWORD PTR __State$[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN8@operator
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z$0:

; 278  :                 _State |= ios_base::badbit;
; 279  :             }
; 280  :             _CATCH_IO_END

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	push	1
	push	4
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $LN9@operator
	ret	0
$LN9@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN8@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 281  :         }
; 282  : 
; 283  :         _Myios::setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 50   :         clear(rdstate() | _State, _Reraise);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, edi

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	0
	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN62@operator

; 107  :                 this->_Myostr._Osfx();

	mov	ecx, esi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN62@operator:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN71@operator

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN71@operator:

; 284  :         return *this;
; 285  :     }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
_TEXT	SEGMENT
__Pfn$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 172  :         return (*_Pfn)(*this);

	push	ecx
	call	DWORD PTR __Pfn$[esp]
	add	esp, 4

; 173  :     }

	ret	4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 142  :     void __CLR_OR_THIS_CALL _Osfx() { // perform any wrapup

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 143  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]

; 321  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [eax+esi+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 144  :         if (this->good() && this->flags() & ios_base::unitbuf) {

	jne	SHORT $LN9@Osfx
	test	BYTE PTR [eax+esi+20], 2
	je	SHORT $LN9@Osfx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 121  :         return sync();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+52]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 145  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

	cmp	eax, -1
	jne	SHORT $LN9@Osfx

; 146  :                 _Myios::setstate(ios_base::badbit);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	push	0
	push	4
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
$LN9@Osfx:

; 151  :     }

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 147  :             }
; 148  :         }
; 149  :         _CATCH_ALL
; 150  :         _CATCH_END

	mov	eax, $LN9@Osfx
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Byte$ = 8						; size = 1
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT
; _this$ = ecx

; 110  :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // convert _Byte to character using imbued locale

	sub	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR [ecx+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 110  :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // convert _Byte to character using imbued locale

	push	ebx
	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	esi, DWORD PTR [eax+4]

; 272  :         _Ptr->_Incref();

	mov	ecx, esi
	mov	DWORD PTR $T1[esp+20], esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 111  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2150 :         return do_widen(_Byte);

	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR __Byte$[esp+12]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, eax
	call	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 111  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

	mov	bl, al
	test	esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	je	SHORT $LN15@widen

; 360  :             delete _Ptr->_Decref();

	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN15@widen
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN15@widen:
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 112  :     }

	mov	al, bl
	pop	ebx
	add	esp, 8
	ret	4
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 97   :         return _Fillch;

	mov	al, BYTE PTR [ecx+64]

; 98   :     }

	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 77   :         return _Mystrbuf;

	mov	eax, DWORD PTR [ecx+56]

; 78   :     }

	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 67   :         return _Tiestr;

	mov	eax, DWORD PTR [ecx+60]

; 68   :     }

	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 50   :         clear(rdstate() | _State, _Reraise);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, DWORD PTR __State$[esp-4]

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	push	DWORD PTR __Reraise$[esp-4]
	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear

; 51   :     }

	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 39   :         ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);

	mov	edx, DWORD PTR __State$[esp-4]
	push	DWORD PTR __Reraise$[esp-4]
	or	edx, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	edx, DWORD PTR __State$[esp]
	push	edx
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear

; 40   :     }

	ret	8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	jmp	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
;	COMDAT ??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z
_TEXT	SEGMENT
$T2 = 8							; size = 4
__Keyval$ = 8						; size = 4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[], COMDAT
; _this$ = ecx

; 287  :     mapped_type& operator[](const key_type& _Keyval) { // find element matching _Keyval or insert with default mapped

	push	ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1585 :         while (!_Pnode->_Isnil) {

	mov	ebx, DWORD PTR __Keyval$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 287  :     mapped_type& operator[](const key_type& _Keyval) { // find element matching _Keyval or insert with default mapped

	push	ebp
	mov	ebp, ecx
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1582 :         _Nodeptr _Wherenode = _Get_data()._Myhead; // end() if search fails

	mov	edi, DWORD PTR [ebp]
	mov	esi, edi

; 1583 :         _Nodeptr _Pnode     = _Wherenode->_Parent;

	mov	eax, DWORD PTR [esi+4]

; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN22@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	ecx, DWORD PTR [ebx]
	npad	6
$LL21@operator:
	cmp	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1586 :             if (_Compare(_Key(_Pnode), _Keyval)) {

	jge	SHORT $LN23@operator

; 1587 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 1588 :             } else { // _Pnode not less than _Keyval, remember it

	jmp	SHORT $LN24@operator
$LN23@operator:

; 1589 :                 _Wherenode = _Pnode;

	mov	esi, eax

; 1590 :                 _Pnode     = _Pnode->_Left; // descend left subtree

	mov	eax, DWORD PTR [eax]
$LN24@operator:

; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL21@operator
$LN22@operator:

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	je	SHORT $LN284@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	jl	SHORT $LN284@operator

; 288  :         return try_emplace(_Keyval).first->second;

	lea	eax, DWORD PTR [esi+20]

; 289  :     }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN284@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	ecx, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	mov	ecx, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples

	mov	DWORD PTR [eax+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 364  :         _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	edx

; 369  :         _Newnode._Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	lea	eax, DWORD PTR $T2[esp+20]
	push	esi
	push	eax
	call	??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_hint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	eax, DWORD PTR $T2[esp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 289  :     }

	pop	edi
	pop	esi
	pop	ebp
	add	eax, 20					; 00000014H
	pop	ebx
	ret	4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
;	COMDAT ??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 100  :     map() : _Mybase(key_compare()) { // construct empty map from defaults

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 415  :     _Tree_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
	mov	DWORD PTR [eax+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 352  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1795 :         _My_data._Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 101  :     }

	mov	eax, esi
	pop	esi
	ret	0
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1541 :         return *this;

	mov	eax, ecx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@H@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@H@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1541 :         return *this;

	mov	eax, ecx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Orphan_ptr, COMDAT
; _this$ = ecx

; 642  : #if _ITERATOR_DEBUG_LEVEL == 2
; 643  :         _Lockit _Lock(_LOCK_DEBUG);
; 644  :         const_iterator** _Pnext = (const_iterator**) this->_Getpfirst();
; 645  :         if (_Pnext != nullptr) {
; 646  :             while (*_Pnext != nullptr) {
; 647  :                 if ((*_Pnext)->_Ptr == _Myhead || (_Ptr != nullptr && (*_Pnext)->_Ptr != _Ptr)) {
; 648  :                     _Pnext = (const_iterator**) (*_Pnext)->_Getpnext();
; 649  :                 } else { // orphan the iterator
; 650  :                     (*_Pnext)->_Clrcont();
; 651  :                     *_Pnext = *(const_iterator**) (*_Pnext)->_Getpnext();
; 652  :                 }
; 653  :             }
; 654  :         }
; 655  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 656  :         (void) _Ptr;
; 657  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 658  :     }

	ret	4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Orphan_ptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv1125 = -4						; size = 4
$T1 = -4						; size = 4
__Where$ = 8						; size = 4
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Extract, COMDAT
; _this$ = ecx

; 495  :     _Nodeptr _Extract(const_iterator _Where) { // extract node at _Where

	push	ecx
	push	ebx
	push	ebp

; 496  : #if _ITERATOR_DEBUG_LEVEL == 2
; 497  :         _STL_VERIFY(_Where._Getcont() == this && !_Where._Ptr->_Isnil, "map/set erase iterator outside range");
; 498  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 499  : 
; 500  :         _Nodeptr _Erasednode = _Where._Ptr; // node to erase

	mov	ebp, DWORD PTR __Where$[esp+8]
	mov	ebx, ecx
	push	esi
	push	edi

; 501  :         ++_Where; // save successor iterator for return

	lea	ecx, DWORD PTR __Where$[esp+16]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++

; 502  : 
; 503  :         _Nodeptr _Fixnode; // the node to recolor as needed
; 504  :         _Nodeptr _Fixnodeparent; // parent of _Fixnode (which may be nil)
; 505  :         _Nodeptr _Pnode = _Erasednode;
; 506  : 
; 507  :         if (_Pnode->_Left->_Isnil) {

	mov	eax, DWORD PTR [ebp]
	mov	edi, DWORD PTR [ebp+8]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN94@Extract

; 508  :             _Fixnode = _Pnode->_Right; // stitch up right subtree
; 509  :         } else if (_Pnode->_Right->_Isnil) {

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN7@Extract

; 510  :             _Fixnode = _Pnode->_Left; // stitch up left subtree

	mov	edi, eax

; 511  :         } else { // two subtrees, must lift successor node to replace erased

	jmp	SHORT $LN94@Extract
$LN7@Extract:

; 512  :             _Pnode   = _Where._Ptr; // _Pnode is successor node

	mov	ecx, DWORD PTR __Where$[esp+16]

; 513  :             _Fixnode = _Pnode->_Right; // _Fixnode is only subtree

	mov	edi, DWORD PTR [ecx+8]
	cmp	ecx, ebp

; 514  :         }
; 515  : 
; 516  :         if (_Pnode == _Erasednode) { // at most one subtree, relink it

	jne	SHORT $LN9@Extract
$LN94@Extract:

; 517  :             _Fixnodeparent = _Erasednode->_Parent;
; 518  :             if (!_Fixnode->_Isnil) {

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [ebp+4]
	jne	SHORT $LN11@Extract

; 519  :                 _Fixnode->_Parent = _Fixnodeparent; // link up

	mov	DWORD PTR [edi+4], esi
$LN11@Extract:

; 440  :         return _Myhead->_Parent;

	mov	eax, DWORD PTR [ebx]

; 520  :             }
; 521  : 
; 522  :             if (_Root() == _Erasednode) {

	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN12@Extract

; 523  :                 _Root() = _Fixnode; // link down from root

	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN15@Extract
$LN12@Extract:

; 524  :             } else if (_Fixnodeparent->_Left == _Erasednode) {

	cmp	DWORD PTR [esi], ebp
	jne	SHORT $LN14@Extract

; 525  :                 _Fixnodeparent->_Left = _Fixnode; // link down to left

	mov	DWORD PTR [esi], edi

; 526  :             } else {

	jmp	SHORT $LN15@Extract
$LN14@Extract:

; 527  :                 _Fixnodeparent->_Right = _Fixnode; // link down to right

	mov	DWORD PTR [esi+8], edi
$LN15@Extract:

; 444  :         return _Myhead->_Left;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR $T1[esp+20], eax

; 528  :             }
; 529  : 
; 530  :             if (_Lmost() == _Erasednode) {

	cmp	DWORD PTR [eax], ebp
	jne	SHORT $LN16@Extract

; 531  :                 _Lmost() = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN42@Extract
	mov	ecx, esi
	jmp	SHORT $LN43@Extract
$LN42@Extract:
	push	edi
	call	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Min
	mov	ecx, eax
	add	esp, 4
	mov	eax, DWORD PTR $T1[esp+20]
$LN43@Extract:
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR $T1[esp+20], eax
$LN16@Extract:

; 532  :                                             : _Min(_Fixnode); // smallest in relinked subtree
; 533  :             }
; 534  : 
; 535  :             if (_Rmost() == _Erasednode) {

	cmp	DWORD PTR [eax+8], ebp
	jne	SHORT $LN17@Extract

; 536  :                 _Rmost() = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN44@Extract
	mov	ecx, esi
	mov	DWORD PTR [eax+8], ecx

; 537  :                                             : _Max(_Fixnode); // largest in relinked subtree
; 538  :             }
; 539  :         } else { // erased has two subtrees, _Pnode is successor to erased

	mov	dl, BYTE PTR [ebp+12]
	jmp	SHORT $LN10@Extract
$LN44@Extract:

; 536  :                 _Rmost() = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

	push	edi
	call	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Max
	mov	ecx, eax
	add	esp, 4
	mov	eax, DWORD PTR $T1[esp+20]
	mov	DWORD PTR [eax+8], ecx
$LN17@Extract:

; 537  :                                             : _Max(_Fixnode); // largest in relinked subtree
; 538  :             }
; 539  :         } else { // erased has two subtrees, _Pnode is successor to erased

	mov	dl, BYTE PTR [ebp+12]
	jmp	SHORT $LN10@Extract
$LN9@Extract:

; 540  :             _Erasednode->_Left->_Parent = _Pnode; // link left up

	mov	DWORD PTR [eax+4], ecx

; 541  :             _Pnode->_Left               = _Erasednode->_Left; // link successor down

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [ecx], eax

; 542  : 
; 543  :             if (_Pnode == _Erasednode->_Right) {

	cmp	ecx, DWORD PTR [ebp+8]
	jne	SHORT $LN18@Extract

; 544  :                 _Fixnodeparent = _Pnode; // successor is next to erased

	mov	esi, ecx

; 545  :             } else { // successor further down, link in place of erased

	jmp	SHORT $LN19@Extract
$LN18@Extract:

; 546  :                 _Fixnodeparent = _Pnode->_Parent; // parent is successor's
; 547  :                 if (!_Fixnode->_Isnil) {

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [ecx+4]
	jne	SHORT $LN20@Extract

; 548  :                     _Fixnode->_Parent = _Fixnodeparent; // link fix up

	mov	DWORD PTR [edi+4], esi
$LN20@Extract:

; 549  :                 }
; 550  : 
; 551  :                 _Fixnodeparent->_Left        = _Fixnode; // link fix down

	mov	DWORD PTR [esi], edi

; 552  :                 _Pnode->_Right               = _Erasednode->_Right; // link next down

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [ecx+8], eax

; 553  :                 _Erasednode->_Right->_Parent = _Pnode; // right up

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+4], ecx
$LN19@Extract:

; 440  :         return _Myhead->_Parent;

	mov	eax, DWORD PTR [ebx]

; 554  :             }
; 555  : 
; 556  :             if (_Root() == _Erasednode) {

	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $LN21@Extract

; 557  :                 _Root() = _Pnode; // link down from root

	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN24@Extract
$LN21@Extract:

; 558  :             } else if (_Erasednode->_Parent->_Left == _Erasednode) {

	mov	eax, DWORD PTR [ebp+4]
	cmp	DWORD PTR [eax], ebp
	jne	SHORT $LN23@Extract

; 559  :                 _Erasednode->_Parent->_Left = _Pnode; // link down to left

	mov	DWORD PTR [eax], ecx

; 560  :             } else {

	jmp	SHORT $LN24@Extract
$LN23@Extract:

; 561  :                 _Erasednode->_Parent->_Right = _Pnode; // link down to right

	mov	DWORD PTR [eax+8], ecx
$LN24@Extract:

; 564  :             _Pnode->_Parent = _Erasednode->_Parent; // link successor up

	mov	eax, DWORD PTR [ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 54   :     _Ty _Tmp = _STD move(_Left);

	mov	dl, BYTE PTR [ecx+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 564  :             _Pnode->_Parent = _Erasednode->_Parent; // link successor up

	mov	DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 55   :     _Left    = _STD move(_Right);

	mov	al, BYTE PTR [ebp+12]
	mov	BYTE PTR [ecx+12], al

; 56   :     _Right   = _STD move(_Tmp);

	mov	BYTE PTR [ebp+12], dl
$LN10@Extract:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 568  :         if (_Erasednode->_Color == _Black) { // erasing black link, must recolor/rebalance tree

	cmp	dl, 1
	jne	$LN25@Extract

; 569  :             for (; _Fixnode != _Root() && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

	mov	eax, DWORD PTR [ebx]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN3@Extract
	npad	6
$LL4@Extract:
	cmp	BYTE PTR [edi+12], 1
	mov	DWORD PTR tv1125[esp+20], esi
	jne	$LN3@Extract

; 570  :                 if (_Fixnode == _Fixnodeparent->_Left) { // fixup left subtree

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	$LN26@Extract

; 571  :                     _Pnode = _Fixnodeparent->_Right;

	mov	ecx, DWORD PTR [esi+8]

; 572  :                     if (_Pnode->_Color == _Red) { // rotate red up from right subtree

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN95@Extract

; 573  :                         _Pnode->_Color         = _Black;

	mov	BYTE PTR [ecx+12], 1

; 452  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	ecx, DWORD PTR [esi+8]

; 574  :                         _Fixnodeparent->_Color = _Red;

	mov	BYTE PTR [esi+12], 0

; 453  :         _Wherenode->_Right = _Pnode->_Left;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+8], eax

; 454  : 
; 455  :         if (!_Pnode->_Left->_Isnil) {

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN73@Extract

; 456  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], esi
$LN73@Extract:

; 457  :         }
; 458  : 
; 459  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax

; 460  : 
; 461  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ebx]
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LN74@Extract

; 462  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN77@Extract
$LN74@Extract:

; 463  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	eax, DWORD PTR [esi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN76@Extract

; 464  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], ecx

; 465  :         } else {

	jmp	SHORT $LN77@Extract
$LN76@Extract:

; 466  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], ecx
$LN77@Extract:

; 467  :         }
; 468  : 
; 469  :         _Pnode->_Left       = _Wherenode;

	mov	DWORD PTR [ecx], esi

; 470  :         _Wherenode->_Parent = _Pnode;

	mov	DWORD PTR [esi+4], ecx

; 575  :                         _Lrotate(_Fixnodeparent);
; 576  :                         _Pnode = _Fixnodeparent->_Right;

	mov	ecx, DWORD PTR [esi+8]
$LN95@Extract:

; 577  :                     }
; 578  : 
; 579  :                     if (_Pnode->_Isnil) {

	cmp	BYTE PTR [ecx+13], 0
	jne	$LN2@Extract

; 580  :                         _Fixnode = _Fixnodeparent; // shouldn't happen
; 581  :                     } else if (_Pnode->_Left->_Color == _Black
; 582  :                                && _Pnode->_Right->_Color == _Black) { // redden right subtree with black children

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+12], 1
	jne	SHORT $LN97@Extract
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	je	$LN101@Extract
$LN97@Extract:

; 583  :                         _Pnode->_Color = _Red;
; 584  :                         _Fixnode       = _Fixnodeparent;
; 585  :                     } else { // must rearrange right subtree
; 586  :                         if (_Pnode->_Right->_Color == _Black) { // rotate red up from left sub-subtree

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN33@Extract

; 587  :                             _Pnode->_Left->_Color = _Black;

	mov	BYTE PTR [edx+12], 1

; 588  :                             _Pnode->_Color        = _Red;

	mov	BYTE PTR [ecx+12], 0

; 589  :                             _Rrotate(_Pnode);

	push	ecx
	mov	ecx, ebx
	call	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Rrotate

; 590  :                             _Pnode = _Fixnodeparent->_Right;

	mov	ecx, DWORD PTR [esi+8]
$LN33@Extract:

; 591  :                         }
; 592  : 
; 593  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 594  :                         _Fixnodeparent->_Color = _Black;

	mov	BYTE PTR [esi+12], 1

; 595  :                         _Pnode->_Right->_Color = _Black;

	mov	eax, DWORD PTR [ecx+8]

; 596  :                         _Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Lrotate

; 597  :                         break; // tree now recolored/rebalanced

	jmp	SHORT $LN3@Extract
$LN26@Extract:

; 598  :                     }
; 599  :                 } else { // fixup right subtree
; 600  :                     _Pnode = _Fixnodeparent->_Left;
; 601  :                     if (_Pnode->_Color == _Red) { // rotate red up from left subtree

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN96@Extract

; 602  :                         _Pnode->_Color         = _Black;

	mov	BYTE PTR [ecx+12], 1

; 474  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	ecx, DWORD PTR [esi]

; 603  :                         _Fixnodeparent->_Color = _Red;

	mov	BYTE PTR [esi+12], 0

; 475  :         _Wherenode->_Left = _Pnode->_Right;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi], eax

; 476  : 
; 477  :         if (!_Pnode->_Right->_Isnil) {

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN80@Extract

; 478  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], esi
$LN80@Extract:

; 479  :         }
; 480  : 
; 481  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax

; 482  : 
; 483  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ebx]
	cmp	esi, DWORD PTR [eax+4]
	jne	SHORT $LN81@Extract

; 484  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN84@Extract
$LN81@Extract:

; 485  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	eax, DWORD PTR [esi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN83@Extract

; 486  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], ecx

; 487  :         } else {

	jmp	SHORT $LN84@Extract
$LN83@Extract:

; 488  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], ecx
$LN84@Extract:

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Right      = _Wherenode;

	mov	DWORD PTR [ecx+8], esi

; 492  :         _Wherenode->_Parent = _Pnode;

	mov	DWORD PTR [esi+4], ecx

; 604  :                         _Rrotate(_Fixnodeparent);
; 605  :                         _Pnode = _Fixnodeparent->_Left;

	mov	ecx, DWORD PTR [esi]
$LN96@Extract:

; 606  :                     }
; 607  : 
; 608  :                     if (_Pnode->_Isnil) {

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@Extract

; 609  :                         _Fixnode = _Fixnodeparent; // shouldn't happen
; 610  :                     } else if (_Pnode->_Right->_Color == _Black
; 611  :                                && _Pnode->_Left->_Color == _Black) { // redden left subtree with black children

	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+12], 1
	jne	SHORT $LN98@Extract
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN98@Extract
$LN101@Extract:

; 569  :             for (; _Fixnode != _Root() && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

	mov	BYTE PTR [ecx+12], 0
$LN2@Extract:
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR tv1125[esp+20]
	mov	edi, ecx
	mov	esi, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	$LL4@Extract
$LN3@Extract:

; 626  :                         break; // tree now recolored/rebalanced
; 627  :                     }
; 628  :                 }
; 629  :             }
; 630  : 
; 631  :             _Fixnode->_Color = _Black; // stopping node is black

	mov	BYTE PTR [edi+12], 1
$LN25@Extract:

; 632  :         }
; 633  : 
; 634  :         if (0 < _Mysize) {

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, ebp
	test	ecx, ecx
	je	SHORT $LN40@Extract

; 635  :             --_Mysize;

	dec	ecx
	mov	DWORD PTR [ebx+4], ecx
$LN40@Extract:

; 636  :         }
; 637  : 
; 638  :         return _Erasednode;
; 639  :     }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	4
$LN98@Extract:

; 612  :                         _Pnode->_Color = _Red;
; 613  :                         _Fixnode       = _Fixnodeparent;
; 614  :                     } else { // must rearrange left subtree
; 615  :                         if (_Pnode->_Left->_Color == _Black) { // rotate red up from right sub-subtree

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN39@Extract

; 616  :                             _Pnode->_Right->_Color = _Black;

	mov	BYTE PTR [edx+12], 1

; 617  :                             _Pnode->_Color         = _Red;

	mov	BYTE PTR [ecx+12], 0

; 618  :                             _Lrotate(_Pnode);

	push	ecx
	mov	ecx, ebx
	call	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Lrotate

; 619  :                             _Pnode = _Fixnodeparent->_Left;

	mov	ecx, DWORD PTR [esi]
$LN39@Extract:

; 620  :                         }
; 621  : 
; 622  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 623  :                         _Fixnodeparent->_Color = _Black;

	mov	BYTE PTR [esi+12], 1

; 624  :                         _Pnode->_Left->_Color  = _Black;

	mov	eax, DWORD PTR [ecx]

; 625  :                         _Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Rrotate
	jmp	SHORT $LN3@Extract
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Rrotate, COMDAT
; _this$ = ecx

; 474  :         _Nodeptr _Pnode   = _Wherenode->_Left;

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx]

; 475  :         _Wherenode->_Left = _Pnode->_Right;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], eax

; 476  : 
; 477  :         if (!_Pnode->_Right->_Isnil) {

	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Rrotate

; 478  :             _Pnode->_Right->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 479  :         }
; 480  : 
; 481  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 482  : 
; 483  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Rrotate

; 484  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Right      = _Wherenode;
; 492  :         _Wherenode->_Parent = _Pnode;
; 493  :     }

	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
$LN3@Rrotate:

; 485  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

	mov	eax, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN5@Rrotate

; 486  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Right      = _Wherenode;
; 492  :         _Wherenode->_Parent = _Pnode;
; 493  :     }

	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
$LN5@Rrotate:

; 487  :         } else {
; 488  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], esi

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Right      = _Wherenode;
; 492  :         _Wherenode->_Parent = _Pnode;
; 493  :     }

	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Lrotate, COMDAT
; _this$ = ecx

; 452  :         _Nodeptr _Pnode    = _Wherenode->_Right;

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx+8]

; 453  :         _Wherenode->_Right = _Pnode->_Left;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], eax

; 454  : 
; 455  :         if (!_Pnode->_Left->_Isnil) {

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Lrotate

; 456  :             _Pnode->_Left->_Parent = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 457  :         }
; 458  : 
; 459  :         _Pnode->_Parent = _Wherenode->_Parent;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 460  : 
; 461  :         if (_Wherenode == _Myhead->_Parent) {

	mov	eax, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Lrotate

; 462  :             _Myhead->_Parent = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 467  :         }
; 468  : 
; 469  :         _Pnode->_Left       = _Wherenode;
; 470  :         _Wherenode->_Parent = _Pnode;
; 471  :     }

	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
$LN3@Lrotate:

; 463  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

	mov	eax, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@Lrotate

; 464  :             _Wherenode->_Parent->_Left = _Pnode;

	mov	DWORD PTR [eax], esi

; 467  :         }
; 468  : 
; 469  :         _Pnode->_Left       = _Wherenode;
; 470  :         _Wherenode->_Parent = _Pnode;
; 471  :     }

	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
$LN5@Lrotate:

; 465  :         } else {
; 466  :             _Wherenode->_Parent->_Right = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 467  :         }
; 468  : 
; 469  :         _Pnode->_Left       = _Wherenode;
; 470  :         _Wherenode->_Parent = _Pnode;
; 471  :     }

	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [edx+4], esi
	pop	esi
	ret	4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Rmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Rmost, COMDAT
; _this$ = ecx

; 448  :         return _Myhead->_Right;

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 449  :     }

	ret	0
?_Rmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Lmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Lmost, COMDAT
; _this$ = ecx

; 444  :         return _Myhead->_Left;

	mov	eax, DWORD PTR [ecx]

; 445  :     }

	ret	0
?_Lmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Root@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Root, COMDAT
; _this$ = ecx

; 440  :         return _Myhead->_Parent;

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 441  :     }

	ret	0
?_Root@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Min, COMDAT

; 432  :         while (!_Pnode->_Left->_Isnil) {

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@Min
	npad	4
$LL2@Min:
	mov	eax, DWORD PTR [ecx]

; 433  :             _Pnode = _Pnode->_Left;

	mov	edx, ecx
	mov	ecx, eax
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Min

; 434  :         }
; 435  : 
; 436  :         return _Pnode;

	mov	eax, edx
$LN3@Min:

; 437  :     }

	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Max, COMDAT

; 424  :         while (!_Pnode->_Right->_Isnil) {

	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN9@Max
	npad	3
$LL2@Max:

; 425  :             _Pnode = _Pnode->_Right;

	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Max
$LN9@Max:

; 426  :         }
; 427  : 
; 428  :         return _Pnode;
; 429  :     }

	mov	eax, ecx
	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 415  :     _Tree_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [ecx], 0

; 416  :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [eax]
	setl	al

; 125  :     }

	ret	8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Get_data@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 1839 :         return _Mypair._Get_second()._Get_second();

	mov	eax, ecx

; 1840 :     }

	ret	0
?_Get_data@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Get_data@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 1835 :         return _Mypair._Get_second()._Get_second();

	mov	eax, ecx

; 1836 :     }

	ret	0
?_Get_data@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 1831 :         return _Mypair._Get_second()._Get_first();

	mov	eax, ecx

; 1832 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 1827 :         return _Mypair._Get_second()._Get_first();

	mov	eax, ecx

; 1828 :     }

	ret	0
?_Getal@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABU?$less@H@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 1823 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1824 :     }

	ret	0
?_Getcomp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAU?$less@H@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 1819 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1820 :     }

	ret	0
?_Getcomp@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEAAU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1791 :     void _Alloc_sentinel_and_proxy() { // construct head node, proxy

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1791 :     void _Alloc_sentinel_and_proxy() { // construct head node, proxy

	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
	mov	DWORD PTR [eax+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 352  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1792 :         auto& _My_data  = _Get_data();
; 1793 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1794 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, _My_data);
; 1795 :         _My_data._Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi], eax
	pop	esi

; 1796 :         _Proxy._Release();
; 1797 :     }

	ret	0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 62   :         return _Val.first;

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1621 :     }

	ret	4
?_Key@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Kfn, COMDAT
; _this$ = ecx

; 1616 :         return _Traits::_Kfn(_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 1617 :     }

	ret	4
?_Kfn@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEABHABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Compare@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?_Compare@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBE_NABH0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Compare, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [eax]
	setl	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1573 :     }

	ret	8
?_Compare@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBE_NABH0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?_Destroy_if_node@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_node@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Destroy_if_node, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	DWORD PTR __Newnode$[esp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1265 :     }

	ret	4
?_Destroy_if_node@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Destroy_if_node
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1582 :         _Nodeptr _Wherenode = _Get_data()._Myhead; // end() if search fails

	mov	edx, DWORD PTR [ecx]

; 1583 :         _Nodeptr _Pnode     = _Wherenode->_Parent;

	mov	eax, DWORD PTR [edx+4]

; 1584 : 
; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN48@lower_boun
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	ecx, DWORD PTR __Keyval$[esp-4]
	mov	ecx, DWORD PTR [ecx]
$LL12@lower_boun:
	cmp	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1586 :             if (_Compare(_Key(_Pnode), _Keyval)) {

	jge	SHORT $LN14@lower_boun

; 1587 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 1588 :             } else { // _Pnode not less than _Keyval, remember it

	jmp	SHORT $LN15@lower_boun
$LN14@lower_boun:

; 1589 :                 _Wherenode = _Pnode;

	mov	edx, eax

; 1590 :                 _Pnode     = _Pnode->_Left; // descend left subtree

	mov	eax, DWORD PTR [eax]
$LN15@lower_boun:

; 1584 : 
; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL12@lower_boun
$LN48@lower_boun:

; 1180 :         // find leftmost node not less than _Keyval in mutable tree
; 1181 :         return iterator(_Lbound(_Keyval), _STD addressof(_Get_data()));
; 1182 :     }

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx
	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 1142 :     _NODISCARD iterator find(const key_type& _Keyval) { // find an element in mutable sequence that matches _Keyval

	push	esi

; 1582 :         _Nodeptr _Wherenode = _Get_data()._Myhead; // end() if search fails

	mov	esi, DWORD PTR [ecx]
	mov	ecx, esi

; 1142 :     _NODISCARD iterator find(const key_type& _Keyval) { // find an element in mutable sequence that matches _Keyval

	push	edi

; 1585 :         while (!_Pnode->_Isnil) {

	mov	edi, DWORD PTR __Keyval$[esp+4]
	mov	edx, esi
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@find
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	edx, DWORD PTR [edi]
$LL16@find:
	cmp	DWORD PTR [eax+16], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1586 :             if (_Compare(_Key(_Pnode), _Keyval)) {

	jge	SHORT $LN18@find

; 1587 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 1588 :             } else { // _Pnode not less than _Keyval, remember it

	jmp	SHORT $LN19@find
$LN18@find:

; 1589 :                 _Wherenode = _Pnode;

	mov	ecx, eax

; 1590 :                 _Pnode     = _Pnode->_Left; // descend left subtree

	mov	eax, DWORD PTR [eax]
$LN19@find:

; 1583 :         _Nodeptr _Pnode     = _Wherenode->_Parent;
; 1584 : 
; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL16@find
	mov	edx, esi
$LN17@find:

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	ecx, edx

; 1144 :         return _Where == end() || _DEBUG_LT_PRED(_Getcomp(), _Keyval, _Key(_Where._Ptr)) ? end() : _Where;

	je	SHORT $LN3@find
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [ecx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1144 :         return _Where == end() || _DEBUG_LT_PRED(_Getcomp(), _Keyval, _Key(_Where._Ptr)) ? end() : _Where;

	jl	SHORT $LN3@find
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi

; 1145 :     }

	pop	esi
	mov	DWORD PTR [eax], ecx
	ret	8
$LN3@find:

; 1144 :         return _Where == end() || _DEBUG_LT_PRED(_Getcomp(), _Keyval, _Key(_Where._Ptr)) ? end() : _Where;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], esi

; 1145 :     }

	pop	esi
	ret	8
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 1131 :     void clear() noexcept { // erase all

	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 1132 :         auto& _My_data = _Get_data();
; 1133 :         _My_data._Orphan_ptr(nullptr);
; 1134 :         auto _Head = _My_data._Myhead;

	mov	edi, DWORD PTR [ebx]

; 1135 :         _My_data._Erase_tree(_Getal(), _Head->_Parent);

	mov	esi, DWORD PTR [edi+4]

; 674  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [esi+13], 0
	jne	SHORT $LN19@clear
$LL18@clear:

; 675  :             _Erase_tree(_Al, _Rootnode->_Right);

	push	DWORD PTR [esi+8]
	mov	ecx, ebx
	push	ebx
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, esi

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 674  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL18@clear
$LN19@clear:

; 1136 :         _Head->_Parent   = _Head;

	mov	DWORD PTR [edi+4], edi

; 1137 :         _Head->_Left     = _Head;

	mov	DWORD PTR [edi], edi

; 1138 :         _Head->_Right    = _Head;

	mov	DWORD PTR [edi+8], edi

; 1139 :         _My_data._Mysize = 0;

	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+4], 0
	pop	ebx

; 1140 :     }

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Successor$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 1094 :     iterator erase(const_iterator _Where) { // erase element at _Where

	push	ecx
	push	esi

; 1095 :         auto& _My_data = _Get_data();
; 1096 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1097 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_My_data) && !_Where._Ptr->_Isnil,
; 1098 :             "map/set erase iterator outside range");
; 1099 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1100 : 
; 1101 :         const_iterator _Successor = _Where;

	mov	esi, DWORD PTR __Where$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR __Successor$[esp+12], esi

; 1102 :         ++_Successor; // save successor iterator for return

	lea	ecx, DWORD PTR __Successor$[esp+12]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++

; 1103 :         _Nodeptr _Erasednode = _My_data._Extract(_Where); // node to erase

	push	esi
	mov	ecx, edi
	call	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Extract
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	ecx, DWORD PTR __Successor$[esp+12]

; 1104 :         _My_data._Orphan_ptr(_Erasednode);
; 1105 :         _Node::_Freenode(_Getal(), _Erasednode); // delete erased node
; 1106 :         return iterator(_Successor._Ptr, _STD addressof(_My_data)); // return successor iterator

	pop	edi

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	DWORD PTR [eax], ecx

; 1104 :         _My_data._Orphan_ptr(_Erasednode);
; 1105 :         _Node::_Freenode(_Getal(), _Erasednode); // delete erased node
; 1106 :         return iterator(_Successor._Ptr, _STD addressof(_My_data)); // return successor iterator

	pop	esi

; 1107 :     }

	pop	ecx
	ret	8
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1026 :         return _Alnode_traits::max_size(_Getal());

	mov	eax, 178956970				; 0aaaaaaaH

; 1027 :     }

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size, COMDAT
; _this$ = ecx

; 1022 :         return _Get_data()._Mysize;

	mov	eax, DWORD PTR [ecx+4]

; 1023 :     }

	ret	0
?size@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end, COMDAT
; _this$ = ecx

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 959  :         auto& _My_data = _Get_data();
; 960  :         return iterator(_My_data._Myhead, _STD addressof(_My_data));
; 961  :     }

	ret	4
?end@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 444  :         return _Myhead->_Left;

	mov	eax, DWORD PTR [ecx]

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 949  :         auto& _My_data = _Get_data();
; 950  :         return iterator(_My_data._Lmost(), _STD addressof(_My_data));
; 951  :     }

	ret	4
?begin@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 902  :     ~_Tree() noexcept { // destroy tree

	push	esi
	push	edi
	mov	edi, ecx

; 683  :         _Erase_tree(_Al, _Myhead->_Parent);

	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax+4]

; 674  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [esi+13], 0
	jne	SHORT $LN21@Tree
	npad	1
$LL20@Tree:

; 675  :             _Erase_tree(_Al, _Rootnode->_Right);

	push	DWORD PTR [esi+8]
	mov	ecx, edi
	push	edi
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, esi

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 674  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL20@Tree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, DWORD PTR [edi]
$LN21@Tree:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	pop	edi
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 908  :     }

	ret	0
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 771  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t(), _Parg, _Zero_then_variadic_args_t()) {

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 415  :     _Tree_val() : _Myhead(), _Mysize(0) { // initialize data

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], eax
	mov	DWORD PTR [eax+4], eax
	mov	DWORD PTR [eax+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 352  :         _Pnode->_Color = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 1795 :         _My_data._Myhead = _Node::_Buyheadnode(_Getal());

	mov	DWORD PTR [esi], eax

; 772  :         // construct empty tree from comparator
; 773  :         _Alloc_sentinel_and_proxy();
; 774  :     }

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::max_size, COMDAT

; 828  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 178956970				; 0aaaaaaaH

; 829  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::deallocate, COMDAT

; 813  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 814  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	shl	ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 815  :     }

	ret	0
$LN12@deallocate:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	jmp	__invalid_parameter_noinfo_noreturn
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::allocate, COMDAT
; _this$ = ecx

; 25   :     size_t _Result                 = _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 3

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	cmp	eax, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN4@allocate

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	or	ecx, -1

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN27@allocate
$LN4@allocate:
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN7@allocate
$LN27@allocate:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 93   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN16@allocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN7@allocate:

; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN8@allocate

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN8@allocate:

; 182  :     return nullptr;

	xor	eax, eax

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN16@allocate:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	__invalid_parameter_noinfo_noreturn
$LN28@allocate:
	int	3
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 924  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Ptr$[esp-4]
	shl	ecx, 3

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 926  :     }

	ret	8
$LN12@deallocate:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >, COMDAT
; _this$ = ecx

; 916  :     }

	mov	eax, ecx
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >::allocator<std::_Tree_node<std::pair<int const ,int>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1541 :         return *this;

	mov	eax, ecx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [ecx], 0

; 319  :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myend@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ
_TEXT	SEGMENT
?_Myend@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ PROC ; std::vector<int,std::allocator<int> >::_Myend, COMDAT
; _this$ = ecx

; 1635 :         return _Get_data()._Myend;

	lea	eax, DWORD PTR [ecx+8]

; 1636 :     }

	ret	0
?_Myend@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myend@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ
_TEXT	SEGMENT
?_Myend@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ PROC ; std::vector<int,std::allocator<int> >::_Myend, COMDAT
; _this$ = ecx

; 1631 :         return _Get_data()._Myend;

	lea	eax, DWORD PTR [ecx+8]

; 1632 :     }

	ret	0
?_Myend@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Mylast@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ
_TEXT	SEGMENT
?_Mylast@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ PROC ; std::vector<int,std::allocator<int> >::_Mylast, COMDAT
; _this$ = ecx

; 1627 :         return _Get_data()._Mylast;

	lea	eax, DWORD PTR [ecx+4]

; 1628 :     }

	ret	0
?_Mylast@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Mylast@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ
_TEXT	SEGMENT
?_Mylast@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ PROC ; std::vector<int,std::allocator<int> >::_Mylast, COMDAT
; _this$ = ecx

; 1623 :         return _Get_data()._Mylast;

	lea	eax, DWORD PTR [ecx+4]

; 1624 :     }

	ret	0
?_Mylast@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ
_TEXT	SEGMENT
?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ PROC ; std::vector<int,std::allocator<int> >::_Myfirst, COMDAT
; _this$ = ecx

; 1619 :         return _Get_data()._Myfirst;

	mov	eax, ecx

; 1620 :     }

	ret	0
?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@ABEABQAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ
_TEXT	SEGMENT
?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ PROC ; std::vector<int,std::allocator<int> >::_Myfirst, COMDAT
; _this$ = ecx

; 1615 :         return _Get_data()._Myfirst;

	mov	eax, ecx

; 1616 :     }

	ret	0
?_Myfirst@?$vector@HV?$allocator@H@std@@@std@@AAEAAPAHXZ ENDP ; std::vector<int,std::allocator<int> >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Get_data@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Get_data, COMDAT
; _this$ = ecx

; 1601 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1602 :     }

	ret	0
?_Get_data@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Get_data@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Get_data, COMDAT
; _this$ = ecx

; 1597 :         return _Mypair._Get_second();

	mov	eax, ecx

; 1598 :     }

	ret	0
?_Get_data@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1593 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1594 :     }

	ret	0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1589 :         return _Mypair._Get_first();

	mov	eax, ecx

; 1590 :     }

	ret	0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Orphan_all@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ PROC ; std::vector<int,std::allocator<int> >::_Orphan_all, COMDAT
; _this$ = ecx

; 1581 :         _Get_data()._Orphan_all();
; 1582 :     }

	ret	0
?_Orphan_all@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ENDP ; std::vector<int,std::allocator<int> >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1545 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1546 :         _Lockit _Lock(_LOCK_DEBUG);
; 1547 : 
; 1548 :         const_iterator** _Pnext = reinterpret_cast<const_iterator**>(_Getpfirst());
; 1549 : 
; 1550 :         if (_Pnext) {
; 1551 :             while (*_Pnext) {
; 1552 :                 if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr) { // skip the iterator
; 1553 :                     _Pnext = reinterpret_cast<const_iterator**>((*_Pnext)->_Getpnext());
; 1554 :                 } else { // orphan the iterator
; 1555 :                     (*_Pnext)->_Clrcont();
; 1556 :                     *_Pnext = *reinterpret_cast<const_iterator**>((*_Pnext)->_Getpnext());
; 1557 :                 }
; 1558 :             }
; 1559 :         }
; 1560 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1561 :         (void) _First;
; 1562 :         (void) _Last;
; 1563 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1564 :     }

	ret	8
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1537 :         _Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN3@Xlength:
	int	3
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1522 :     void _Tidy() noexcept { // free all storage

	push	esi
	mov	esi, ecx

; 1523 :         _Orphan_all();
; 1524 :         auto& _My_data    = _Get_data();
; 1525 :         const auto _First = _My_data._Myfirst;

	mov	eax, DWORD PTR [esi]

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN2@Tidy

; 1527 :             _Destroy(_First, _My_data._Mylast);
; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	edx, DWORD PTR [esi+8]
	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	edx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN42@Tidy

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN39@Tidy

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN42@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1530 :             _My_data._Myfirst = pointer();

	mov	DWORD PTR [esi], 0

; 1531 :             _My_data._Mylast  = pointer();

	mov	DWORD PTR [esi+4], 0

; 1532 :             _My_data._Myend   = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1534 :     }

	pop	esi
	ret	0
$LN39@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN46@Tidy:
	int	3
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z PROC ; std::vector<int,std::allocator<int> >::_Change_array, COMDAT
; _this$ = ecx

; 1509 :         const size_type _Newcapacity) { // orphan all iterators, discard old array, acquire new array

	push	esi
	mov	esi, ecx

; 1510 :         _Orphan_all();
; 1511 : 
; 1512 :         if (_Myfirst() != pointer()) { // destroy and deallocate old array

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN77@Change_arr

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	edx, DWORD PTR [esi+8]
	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	edx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN76@Change_arr

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN73@Change_arr

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN76@Change_arr:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN77@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1517 :         _Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[esp]

; 1518 :         _Mylast()  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[esp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1519 :         _Myend()   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[esp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1520 :     }

	ret	12					; 0000000cH
$LN73@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN98@Change_arr:
	int	3
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ENDP ; std::vector<int,std::allocator<int> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1498 :     void _Buy_nonzero(const size_type _Newcapacity) { // allocate array with _Newcapacity elements

	push	esi
	push	edi

; 1499 :                                                       // pre: *this is _Tidy
; 1500 :                                                       // pre: _Newcapacity != 0
; 1501 :         if (_Newcapacity > max_size()) {

	mov	edi, DWORD PTR __Newcapacity$[esp+4]
	mov	esi, ecx
	cmp	edi, 1073741823				; 3fffffffH
	ja	SHORT $LN28@Buy_nonzer

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	push	edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	mov	DWORD PTR [esi], eax

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;

	mov	DWORD PTR [esi+4], eax

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	eax, DWORD PTR [eax+edi*4]
	pop	edi
	mov	DWORD PTR [esi+8], eax

; 1503 :         }
; 1504 : 
; 1505 :         _Buy_raw(_Newcapacity);
; 1506 :     }

	pop	esi
	ret	4
$LN28@Buy_nonzer:

; 1502 :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN26@Buy_nonzer:
	int	3
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1489 :     void _Buy_raw(const size_type _Newcapacity) { // allocate array with _Newcapacity elements

	push	esi

; 1490 :                                                   // pre: *this is _Tidy
; 1491 :                                                   // pre: _Newcapacity is in (0, max_size()]
; 1492 :         auto& _My_data    = _Get_data();
; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	mov	esi, DWORD PTR __Newcapacity$[esp]
	push	edi
	push	esi
	mov	edi, ecx
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	mov	DWORD PTR [edi], eax

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;

	mov	DWORD PTR [edi+4], eax

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi

; 1496 :     }

	ret	4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z PROC ; std::vector<int,std::allocator<int> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	edx, DWORD PTR [ecx+8]

; 1473 :         const size_type _Oldcapacity = capacity();
; 1474 : 
; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	eax, 1073741823				; 3fffffffH

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	sub	edx, DWORD PTR [ecx]
	sar	edx, 2

; 1473 :         const size_type _Oldcapacity = capacity();
; 1474 : 
; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	ja	SHORT $LN31@Calculate_

; 1476 :             return _Newsize; // geometric growth would overflow
; 1477 :         }
; 1478 : 
; 1479 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1480 : 
; 1481 :         if (_Geometric < _Newsize) {

	cmp	eax, DWORD PTR __Newsize$[esp-4]
	jae	SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1482 :             return _Newsize; // geometric growth would be insufficient

	mov	eax, DWORD PTR __Newsize$[esp-4]
$LN1@Calculate_:

; 1483 :         }
; 1484 : 
; 1485 :         return _Geometric; // geometric growth is sufficient
; 1486 :     }

	ret	4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1468 :         _Destroy_range(_First, _Last, _Getal());
; 1469 :     }

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	eax, ecx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[esp+4]
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1465 :     }

	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	eax, ecx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	eax
	push	ecx
	push	DWORD PTR __Dest$[esp+4]
	call	_memmove
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1454 :     }

	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Umove@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __First$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1447 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1447 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, eax

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 1767 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1448 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

	pop	edi
	pop	esi

; 1449 :     }

	ret	12					; 0000000cH
?_Umove@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAHIU_Value_init_tag@2@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAHIU_Value_init_tag@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 332  :     return _Zero_range(_First, _First + _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1438 :         _Value_init_tag) { // fill raw _Dest with _Count value-initialized objects, using allocator

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	esi, DWORD PTR __Dest$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1438 :         _Value_init_tag) { // fill raw _Dest with _Count value-initialized objects, using allocator

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 332  :     return _Zero_range(_First, _First + _Count);

	lea	edi, DWORD PTR [eax*4]

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	edi
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 332  :     return _Zero_range(_First, _First + _Count);

	lea	eax, DWORD PTR [edi+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1439 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

	pop	edi
	pop	esi

; 1440 :     }

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAHIU_Value_init_tag@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Has_unused_capacity@?$vector@HV?$allocator@H@std@@@std@@ABE_NXZ
_TEXT	SEGMENT
?_Has_unused_capacity@?$vector@HV?$allocator@H@std@@@std@@ABE_NXZ PROC ; std::vector<int,std::allocator<int> >::_Has_unused_capacity, COMDAT
; _this$ = ecx

; 1357 :         return _Myend() != _Mylast();

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [ecx+4]
	setne	al

; 1358 :     }

	ret	0
?_Has_unused_capacity@?$vector@HV?$allocator@H@std@@@std@@ABE_NXZ ENDP ; std::vector<int,std::allocator<int> >::_Has_unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1349 :     }

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 1343 :         return _Min_value(

	mov	eax, 1073741823				; 3fffffffH

; 1344 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1345 :     }

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1340 :     }

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QBEPBHXZ
_TEXT	SEGMENT
?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QBEPBHXZ PROC ; std::vector<int,std::allocator<int> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1331 :         return _Mylast();

	mov	eax, DWORD PTR [ecx+4]

; 1332 :     }

	ret	0
?_Unchecked_end@?$vector@HV?$allocator@H@std@@@std@@QBEPBHXZ ENDP ; std::vector<int,std::allocator<int> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QBEPBHXZ
_TEXT	SEGMENT
?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QBEPBHXZ PROC ; std::vector<int,std::allocator<int> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1323 :         return _Myfirst();

	mov	eax, DWORD PTR [ecx]

; 1324 :     }

	ret	0
?_Unchecked_begin@?$vector@HV?$allocator@H@std@@@std@@QBEPBHXZ ENDP ; std::vector<int,std::allocator<int> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 1357 :         return _Myend() != _Mylast();

	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [ecx+8], edx

; 637  :         if (_Has_unused_capacity()) {

	je	SHORT $LN6@push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 625  :         ++_Mylast();

	add	DWORD PTR [ecx+4], 4

; 654  :         emplace_back(_STD move(_Val));
; 655  :     }

	ret	4
$LN6@push_back:

; 641  :         _Ty& _Result = *_Emplace_reallocate(_Mylast(), _STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[esp-4]
	push	edx
	call	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>

; 654  :         emplace_back(_STD move(_Val));
; 655  :     }

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 609  :     ~vector() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 1525 :         const auto _First = _My_data._Myfirst;

	mov	eax, DWORD PTR [esi]

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	test	eax, eax
	je	SHORT $LN4@vector

; 1527 :             _Destroy(_First, _My_data._Mylast);
; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	edx, DWORD PTR [esi+8]
	sub	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	edx, -4					; fffffffcH

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN44@vector

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	edx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN41@vector

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN44@vector:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1530 :             _My_data._Myfirst = pointer();

	mov	DWORD PTR [esi], 0

; 1531 :             _My_data._Mylast  = pointer();

	mov	DWORD PTR [esi+4], 0

; 1532 :             _My_data._Myend   = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 615  :     }

	ret	0
$LN41@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN49@vector:
	int	3
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@IABV?$allocator@H@1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@IABV?$allocator@H@1@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 397  :     explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al = _Alloc())

	push	esi

; 386  :         if (_Count != 0) {

	mov	esi, DWORD PTR __Count$[esp]

; 397  :     explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al = _Alloc())

	push	edi
	mov	edi, ecx

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 0

; 386  :         if (_Count != 0) {

	test	esi, esi
	je	SHORT $LN69@vector

; 1501 :         if (_Newcapacity > max_size()) {

	cmp	esi, 1073741823				; 3fffffffH
	ja	SHORT $LN76@vector

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	push	esi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	ecx, DWORD PTR [esi*4]
	mov	DWORD PTR [edi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	ecx
	push	0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	esi, DWORD PTR [ecx+eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	mov	DWORD PTR [edi+8], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	_memset
	add	esp, 12					; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 389  :             _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);

	mov	DWORD PTR [edi+4], esi
$LN69@vector:

; 398  :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Count * _Ty(), optional allocator
; 399  :         _Construct_n_copies_of_ty(_Count, _Value_init_tag{});
; 400  :     }

	mov	eax, edi
	pop	edi
	pop	esi
	ret	8
$LN76@vector:

; 1502 :             _Xlength();

	call	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN74@vector:
	int	3
??0?$vector@HV?$allocator@H@std@@@std@@QAE@IABV?$allocator@H@1@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::max_size, COMDAT

; 828  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 1073741823				; 3fffffffH

; 829  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 25   :     size_t _Result                 = _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax*4]

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN4@allocate

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	or	ecx, -1

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN27@allocate
$LN4@allocate:
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN7@allocate
$LN27@allocate:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 93   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN16@allocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN7@allocate:

; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN8@allocate

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN8@allocate:

; 182  :     return nullptr;

	xor	eax, eax

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN16@allocate:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	__invalid_parameter_noinfo_noreturn
$LN28@allocate:
	int	3
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXQAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXQAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 924  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[esp-4]
	lea	ecx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Ptr$[esp-4]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 926  :     }

	ret	8
$LN12@deallocate:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@H@std@@QAEXQAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 916  :     }

	mov	eax, ecx
	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp
;	COMDAT ?map_access@@YAXABV?$vector@HV?$allocator@H@std@@@std@@PAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@2@@Z
_TEXT	SEGMENT
tv3789 = -5040						; size = 4
_<end>$L1$1$ = -5040					; size = 4
_i$1$ = -5040						; size = 4
$T4 = -5040						; size = 4
_it$5 = -5040						; size = 4
_map$GSCopy$1$ = -5036					; size = 4
tv3788 = -5029						; size = 1
_<end>$L0$1$ = -5028					; size = 4
$T6 = -5028						; size = 4
_key$7 = -5028						; size = 4
_distribution$$sroa$2011$1$ = -5024			; size = 4
tv3793 = -5024						; size = 4
__Rng$8 = -5020						; size = 12
__Rng$9 = -5020						; size = 12
$T10 = -5008						; size = 4
_real$ = -5004						; size = 5000
__$ArrayPad$ = -4					; size = 4
_rands$ = 8						; size = 4
_map$ = 12						; size = 4
?map_access@@YAXABV?$vector@HV?$allocator@H@std@@@std@@PAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@2@@Z PROC ; map_access, COMDAT

; 9    : void map_access(const std::vector<int>& rands, std::map<int, int>* map){

	mov	eax, 5040				; 000013b0H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+5040], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1323 :         return _Myfirst();

	mov	eax, DWORD PTR _rands$[esp+5036]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 9    : void map_access(const std::vector<int>& rands, std::map<int, int>* map){

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _map$[esp+5044]
	push	esi
	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1323 :         return _Myfirst();

	mov	edi, DWORD PTR [eax]

; 1331 :         return _Mylast();

	mov	eax, DWORD PTR [eax+4]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 9    : void map_access(const std::vector<int>& rands, std::map<int, int>* map){

	mov	DWORD PTR _map$GSCopy$1$[esp+5056], ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1331 :         return _Mylast();

	mov	DWORD PTR _<end>$L0$1$[esp+5056], eax
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 11   : 	for (const auto& elem: rands) {

	cmp	edi, eax
	je	$LN3@map_access
	npad	1
$LL4@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1582 :         _Nodeptr _Wherenode = _Get_data()._Myhead; // end() if search fails

	mov	ebx, DWORD PTR [ebp]
	mov	esi, ebx

; 1585 :         while (!_Pnode->_Isnil) {

	mov	ecx, ebx
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN1419@map_access
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	ecx, DWORD PTR [edi]
$LL56@map_access:
	cmp	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1586 :             if (_Compare(_Key(_Pnode), _Keyval)) {

	jge	SHORT $LN58@map_access

; 1587 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 1588 :             } else { // _Pnode not less than _Keyval, remember it

	jmp	SHORT $LN59@map_access
$LN58@map_access:

; 1589 :                 _Wherenode = _Pnode;

	mov	esi, eax

; 1590 :                 _Pnode     = _Pnode->_Left; // descend left subtree

	mov	eax, DWORD PTR [eax]
$LN59@map_access:

; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL56@map_access
	mov	ecx, ebx
$LN1419@map_access:

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	je	SHORT $LN1420@map_access
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	jge	SHORT $LN42@map_access
$LN1420@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	ecx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	mov	ecx, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples

	mov	DWORD PTR [eax+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 364  :         _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	edx

; 369  :         _Newnode._Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	lea	eax, DWORD PTR $T4[esp+5064]
	push	esi
	push	eax
	call	??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_hint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	esi, DWORD PTR $T4[esp+5056]
$LN42@map_access:
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 11   : 	for (const auto& elem: rands) {

	add	edi, 4

; 12   : 		(*map)[elem] = 0;

	mov	DWORD PTR [esi+20], 0
	cmp	edi, DWORD PTR _<end>$L0$1$[esp+5056]
	jne	SHORT $LL4@map_access
$LN3@map_access:

; 13   : 	}
; 14   : 
; 15   : 	std::cerr << map->size() << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [ebp+4]
	mov	ecx, OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 16   : 
; 17   : 	default_random_engine real(0); 

	lea	ecx, DWORD PTR _real$[esp+5056]
	push	0
	call	??0?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@QAE@I@Z ; std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1799 :             _Max = _Max0;

	mov	ecx, DWORD PTR [ebp+4]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 21   : 	for (int i=0; i < map->size();){

	xor	ebx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1799 :             _Max = _Max0;

	mov	DWORD PTR _distribution$$sroa$2011$1$[esp+5056], ecx
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 21   : 	for (int i=0; i < map->size();){

	mov	eax, ecx
	mov	DWORD PTR _i$1$[esp+5056], ebx
	test	ecx, ecx
	je	$LN6@map_access
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	lea	eax, DWORD PTR _real$[esp+5056]
	mov	DWORD PTR __Rng$9[esp+5060], 32		; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1877 :         const _Uty _Umax = _Adjust(_Uty(_Max));

	cmp	ecx, -2147483648			; 80000000H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$9[esp+5056], eax
	lea	eax, DWORD PTR [ecx-2147483648]
	mov	DWORD PTR __Rng$9[esp+5064], -1
	lea	edi, DWORD PTR [ecx-2147483648]
	cmovae	edi, eax
	sub	edi, -2147483648			; 80000000H
	npad	3
$LL5@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1881 :         if (_Umax - _Umin == _Uty(-1)) {

	cmp	edi, -1
	jne	SHORT $LN351@map_access
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3304 :             _Ret |= _Get_bits();

	lea	ecx, DWORD PTR __Rng$9[esp+5056]
	call	?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1882 :             _Uret = static_cast<_Uty>(_Rng._Get_all_bits());

	mov	edx, eax

; 1883 :         } else {

	jmp	SHORT $LN382@map_access
$LN351@map_access:

; 1884 :             _Uret = static_cast<_Uty>(_Rng(static_cast<_Uty>(_Umax - _Umin + 1)));

	lea	ebp, DWORD PTR [edi+1]
$LL381@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3279 :             _Udiff _Ret  = 0; // random bits

	xor	esi, esi

; 3280 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

	xor	eax, eax

; 3281 : 
; 3282 :             while (_Mask < _Udiff(_Index - 1)) { // need more random bits

	test	edi, edi
	je	SHORT $LN385@map_access

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	lea	ecx, DWORD PTR _real$[esp+5056]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
	mov	esi, eax

; 3288 :                 _Mask |= _Bmask;

	or	eax, -1
$LN385@map_access:

; 3289 :             }
; 3290 : 
; 3291 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3292 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

	xor	edx, edx
	div	ebp
	mov	ecx, eax
	mov	ebx, edx
	xor	edx, edx
	mov	eax, esi
	div	ebp
	cmp	eax, ecx
	jb	SHORT $LN1363@map_access
	cmp	ebx, edi
	jne	SHORT $LL381@map_access
$LN1363@map_access:
	mov	ebx, DWORD PTR _i$1$[esp+5056]

; 3293 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, esi
	xor	edx, edx
	div	ebp
	mov	ebp, DWORD PTR _map$GSCopy$1$[esp+5056]
$LN382@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1887 :         return _Ty(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	eax, DWORD PTR [edx-2147483648]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 22   : 		int pos = distribution(real);

	cmp	eax, -2147483648			; 80000000H
	lea	esi, DWORD PTR [eax-2147483648]

; 23   : 		if (pos < map->size()){

	mov	eax, DWORD PTR [ebp+4]
	cmovae	esi, edx
	cmp	esi, eax
	jae	SHORT $LN1421@map_access
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 444  :         return _Myhead->_Left;

	mov	eax, DWORD PTR [ebp]

; 36   :         : _Ptr(_Pnode) { // construct with node pointer _Pnode

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _it$5[esp+5056], eax
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 25   : 			for (int z = 0; z < pos; z++){

	test	esi, esi
	jle	SHORT $LN9@map_access
$LL10@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 285  :         ++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR _it$5[esp+5056]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > > >::operator++
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 25   : 			for (int z = 0; z < pos; z++){

	sub	esi, 1
	jne	SHORT $LL10@map_access
	mov	eax, DWORD PTR _it$5[esp+5056]
$LN9@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1103 :         _Nodeptr _Erasednode = _My_data._Extract(_Where); // node to erase

	push	eax
	mov	ecx, ebp
	call	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Extract
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 29   : 			++i;

	mov	eax, DWORD PTR [ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 29   : 			++i;

	inc	ebx
	mov	DWORD PTR _i$1$[esp+5056], ebx
$LN1421@map_access:

; 21   : 	for (int i=0; i < map->size();){

	cmp	ebx, eax
	jb	$LL5@map_access
$LN6@map_access:

; 33   : 	std::cerr << map->size() << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	eax
	mov	ecx, OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1134 :         auto _Head = _My_data._Myhead;

	mov	edi, DWORD PTR [ebp]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 33   : 	std::cerr << map->size() << "\n";

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1135 :         _My_data._Erase_tree(_Getal(), _Head->_Parent);

	mov	esi, DWORD PTR [edi+4]

; 674  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [esi+13], 0
	jne	SHORT $LN530@map_access
$LL529@map_access:

; 675  :             _Erase_tree(_Al, _Rootnode->_Right);

	push	DWORD PTR [esi+8]
	mov	ecx, ebp
	push	ebp
	call	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 526  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, esi

; 527  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	esi, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	24					; 00000018H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 674  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL529@map_access
$LN530@map_access:
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 35   : 	std::cerr << map->size() << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1136 :         _Head->_Parent   = _Head;

	mov	DWORD PTR [edi+4], edi
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 35   : 	std::cerr << map->size() << "\n";

	mov	ecx, OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1137 :         _Head->_Left     = _Head;

	mov	DWORD PTR [edi], edi

; 1138 :         _Head->_Right    = _Head;

	mov	DWORD PTR [edi+8], edi
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 35   : 	std::cerr << map->size() << "\n";

	push	0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1139 :         _My_data._Mysize = 0;

	mov	DWORD PTR [ebp+4], 0
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 35   : 	std::cerr << map->size() << "\n";

	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1323 :         return _Myfirst();

	mov	eax, DWORD PTR _rands$[esp+5060]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 35   : 	std::cerr << map->size() << "\n";

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1323 :         return _Myfirst();

	mov	edi, DWORD PTR [eax]

; 1331 :         return _Mylast();

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _<end>$L1$1$[esp+5056], eax
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 37   : 	for (const auto& elem: rands) {

	cmp	edi, eax
	je	$LN12@map_access
$LL13@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1582 :         _Nodeptr _Wherenode = _Get_data()._Myhead; // end() if search fails

	mov	ebx, DWORD PTR [ebp]
	mov	esi, ebx

; 1585 :         while (!_Pnode->_Isnil) {

	mov	ecx, ebx
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN620@map_access
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	ecx, DWORD PTR [edi]
$LL619@map_access:
	cmp	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1586 :             if (_Compare(_Key(_Pnode), _Keyval)) {

	jge	SHORT $LN621@map_access

; 1587 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 1588 :             } else { // _Pnode not less than _Keyval, remember it

	jmp	SHORT $LN622@map_access
$LN621@map_access:

; 1589 :                 _Wherenode = _Pnode;

	mov	esi, eax

; 1590 :                 _Pnode     = _Pnode->_Left; // descend left subtree

	mov	eax, DWORD PTR [eax]
$LN622@map_access:

; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL619@map_access
	mov	ecx, ebx
$LN620@map_access:

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	je	SHORT $LN1422@map_access
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	jge	SHORT $LN605@map_access
$LN1422@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	ecx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	mov	ecx, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples

	mov	DWORD PTR [eax+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 364  :         _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	edx

; 369  :         _Newnode._Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	lea	eax, DWORD PTR $T6[esp+5064]
	push	esi
	push	eax
	call	??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_hint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	esi, DWORD PTR $T6[esp+5056]
$LN605@map_access:
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 37   : 	for (const auto& elem: rands) {

	add	edi, 4

; 38   : 		(*map)[elem] = 0;

	mov	DWORD PTR [esi+20], 0
	cmp	edi, DWORD PTR _<end>$L1$1$[esp+5056]
	jne	SHORT $LL13@map_access
$LN12@map_access:
	mov	ecx, DWORD PTR _distribution$$sroa$2011$1$[esp+5056]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	lea	eax, DWORD PTR _real$[esp+5056]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1877 :         const _Uty _Umax = _Adjust(_Uty(_Max));

	cmp	ecx, -2147483648			; 80000000H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3271 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(_Udiff(-1)) { // construct from URNG

	mov	DWORD PTR __Rng$8[esp+5056], eax
	mov	DWORD PTR __Rng$8[esp+5060], 32		; 00000020H
	mov	DWORD PTR __Rng$8[esp+5064], -1
	lea	eax, DWORD PTR [ecx-2147483648]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 42   : 	for (int i=0; i < 10; i++){

	mov	DWORD PTR tv3789[esp+5056], 10		; 0000000aH
	lea	ebx, DWORD PTR [ecx-2147483648]
	cmovae	ebx, eax
	sub	ebx, -2147483648			; 80000000H
	mov	DWORD PTR tv3793[esp+5056], ebx
	jmp	SHORT $LN16@map_access
$LL1425@map_access:
	mov	ebp, DWORD PTR _map$GSCopy$1$[esp+5056]
$LN16@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1881 :         if (_Umax - _Umin == _Uty(-1)) {

	cmp	ebx, -1
	jne	SHORT $LN881@map_access
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3304 :             _Ret |= _Get_bits();

	lea	ecx, DWORD PTR __Rng$8[esp+5056]
	call	?_Get_bits@?$_Rng_from_urng@IV?$mersenne_twister_engine@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$0PPPPPPPP@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@$0GMAHIJGF@@std@@@std@@AAEIXZ ; std::_Rng_from_urng<unsigned int,std::mersenne_twister_engine<unsigned int,32,624,397,31,2567483615,11,4294967295,7,2636928640,15,4022730752,18,1812433253> >::_Get_bits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1882 :             _Uret = static_cast<_Uty>(_Rng._Get_all_bits());

	mov	edx, eax

; 1883 :         } else {

	jmp	SHORT $LN912@map_access
$LN881@map_access:

; 1884 :             _Uret = static_cast<_Uty>(_Rng(static_cast<_Uty>(_Umax - _Umin + 1)));

	lea	ebp, DWORD PTR [ebx+1]
	npad	3
$LL911@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3279 :             _Udiff _Ret  = 0; // random bits

	xor	esi, esi

; 3280 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

	xor	eax, eax

; 3281 : 
; 3282 :             while (_Mask < _Udiff(_Index - 1)) { // need more random bits

	test	ebx, ebx
	je	SHORT $LN915@map_access

; 3316 :             _Udiff _Val = _Ref() - (_Urng::min)();

	lea	ecx, DWORD PTR _real$[esp+5056]
	call	??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QAEIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
	mov	esi, eax

; 3288 :                 _Mask |= _Bmask;

	or	eax, -1
$LN915@map_access:

; 3289 :             }
; 3290 : 
; 3291 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3292 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1)) {

	xor	edx, edx
	div	ebp
	mov	ecx, eax
	mov	edi, edx
	xor	edx, edx
	mov	eax, esi
	div	ebp
	cmp	eax, ecx
	jb	SHORT $LN1365@map_access
	cmp	edi, ebx
	jne	SHORT $LL911@map_access
$LN1365@map_access:

; 3293 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, esi
	xor	edx, edx
	div	ebp
	mov	ebp, DWORD PTR _map$GSCopy$1$[esp+5056]
$LN912@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1582 :         _Nodeptr _Wherenode = _Get_data()._Myhead; // end() if search fails

	mov	ebp, DWORD PTR [ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\random

; 1887 :         return _Ty(_Adjust(static_cast<_Uty>(_Uret + _Umin)));

	lea	eax, DWORD PTR [edx-2147483648]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 43   : 		int key = distribution(real);

	cmp	eax, -2147483648			; 80000000H
	lea	edi, DWORD PTR [eax-2147483648]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1582 :         _Nodeptr _Wherenode = _Get_data()._Myhead; // end() if search fails

	mov	eax, ebp

; 1585 :         while (!_Pnode->_Isnil) {

	mov	esi, ebp
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 43   : 		int key = distribution(real);

	cmovae	edi, edx
	mov	DWORD PTR _key$7[esp+5056], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1583 :         _Nodeptr _Pnode     = _Wherenode->_Parent;

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, ecx

; 1585 :         while (!_Pnode->_Isnil) {

	mov	bl, BYTE PTR [edx+13]
	mov	BYTE PTR tv3788[esp+5056], bl
	test	bl, bl
	mov	ebx, DWORD PTR tv3793[esp+5056]
	jne	SHORT $LN1424@map_access
	npad	7
$LL948@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	cmp	DWORD PTR [edx+16], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1586 :             if (_Compare(_Key(_Pnode), _Keyval)) {

	jge	SHORT $LN950@map_access

; 1587 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	edx, DWORD PTR [edx+8]

; 1588 :             } else { // _Pnode not less than _Keyval, remember it

	jmp	SHORT $LN951@map_access
$LN950@map_access:

; 1589 :                 _Wherenode = _Pnode;

	mov	eax, edx

; 1590 :                 _Pnode     = _Pnode->_Left; // descend left subtree

	mov	edx, DWORD PTR [edx]
$LN951@map_access:

; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL948@map_access
	mov	edx, DWORD PTR _map$GSCopy$1$[esp+5056]
	mov	esi, DWORD PTR [edx]
	jmp	SHORT $LN949@map_access
$LN1424@map_access:
	mov	edx, DWORD PTR _map$GSCopy$1$[esp+5056]
$LN949@map_access:

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	eax, esi

; 1144 :         return _Where == end() || _DEBUG_LT_PRED(_Getcomp(), _Keyval, _Key(_Where._Ptr)) ? end() : _Where;

	je	SHORT $LN935@map_access
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	cmp	edi, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1144 :         return _Where == end() || _DEBUG_LT_PRED(_Getcomp(), _Keyval, _Key(_Where._Ptr)) ? end() : _Where;

	jge	SHORT $LN936@map_access
$LN935@map_access:
	mov	eax, ebp
	mov	esi, ebp
$LN936@map_access:

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	eax, esi
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 45   : 		if (search != map->end()) {

	je	$LN1423@map_access
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR tv3788[esp+5056], 0
	mov	esi, ebp
	mov	eax, ebp
	jne	SHORT $LN1074@map_access
$LL1073@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	cmp	DWORD PTR [ecx+16], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 1586 :             if (_Compare(_Key(_Pnode), _Keyval)) {

	jge	SHORT $LN1075@map_access

; 1587 :                 _Pnode = _Pnode->_Right; // descend right subtree

	mov	ecx, DWORD PTR [ecx+8]

; 1588 :             } else { // _Pnode not less than _Keyval, remember it

	jmp	SHORT $LN1076@map_access
$LN1075@map_access:

; 1589 :                 _Wherenode = _Pnode;

	mov	esi, ecx

; 1590 :                 _Pnode     = _Pnode->_Left; // descend left subtree

	mov	ecx, DWORD PTR [ecx]
$LN1076@map_access:

; 1585 :         while (!_Pnode->_Isnil) {

	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LL1073@map_access
	mov	eax, DWORD PTR [edx]
$LN1074@map_access:

; 231  :         return this->_Ptr == _Right._Ptr;

	cmp	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	je	SHORT $LN1060@map_access
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 124  :         return _Left < _Right;

	cmp	edi, DWORD PTR [esi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\map

; 190  :         if (_Where == _Mybase::end() || _DEBUG_LT_PRED(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr))) {

	jl	SHORT $LN1060@map_access

; 191  :             return _Pairib(
; 192  :                 _Mybase::emplace_hint(_Where, piecewise_construct, _STD forward_as_tuple(_STD forward<_Keyty>(_Keyval)),
; 193  :                     _STD forward_as_tuple(_STD forward<_Mappedty>(_Mapval)...)),
; 194  :                 true);
; 195  :         } else {
; 196  :             return _Pairib(_Where, false);

	mov	edi, DWORD PTR _map$GSCopy$1$[esp+5056]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 46   : 			(*map)[key] = 1;

	mov	DWORD PTR [esi+20], 1
	jmp	SHORT $LN14@map_access
$LN1060@map_access:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	ecx, DWORD PTR _key$7[esp+5060]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	mov	edi, DWORD PTR _map$GSCopy$1$[esp+5056]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 893  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	DWORD PTR [eax+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	mov	ecx, edi

; 364  :         _Alnode_traits::construct(_Al, _STD addressof(_Newnode._Ptr->_Myval), _STD forward<_Valty>(_Val)...);

	lea	edx, DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple

; 894  :       second(_STD get<_Indexes2>(_STD move(_Val2))...) { // construct from pair of tuples

	mov	DWORD PTR [edx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax], ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xtree

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	push	edx

; 369  :         _Newnode._Ptr->_Color = _Red;

	mov	WORD PTR [eax+12], 0

; 899  :         return _Insert_hint(_Where, _Newnode->_Myval, _Newnode);

	lea	eax, DWORD PTR $T10[esp+5064]
	push	esi
	push	eax
	call	??$_Insert_hint@AAU?$pair@$$CBHH@std@@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHH@std@@@std@@@std@@@1@AAU?$pair@$$CBHH@1@PAU?$_Tree_node@U?$pair@$$CBHH@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert_hint<std::pair<int const ,int> &,std::_Tree_node<std::pair<int const ,int>,void *> *>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 123  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

	mov	esi, DWORD PTR $T10[esp+5056]
; File C:\Users\Emily Jin\Documents\cpp-class-project-master\DataStructures\map\map.cpp

; 46   : 			(*map)[key] = 1;

	mov	DWORD PTR [esi+20], 1
	jmp	SHORT $LN14@map_access
$LN1423@map_access:

; 45   : 		if (search != map->end()) {

	mov	edi, DWORD PTR _map$GSCopy$1$[esp+5056]
$LN14@map_access:

; 42   : 	for (int i=0; i < 10; i++){

	sub	DWORD PTR tv3789[esp+5056], 1
	jne	$LL1425@map_access

; 47   : 		}
; 48   : 	}
; 49   : 
; 50   : 	std::cerr << map->size() << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6@
	push	DWORD PTR [edi+4]
	mov	ecx, OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 51   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+5064]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 5040				; 000013b0H
	ret	0
?map_access@@YAXABV?$vector@HV?$allocator@H@std@@@std@@PAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@2@@Z ENDP ; map_access
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000> >::count, COMDAT
; _this$ = ecx

; 88   :             return _MyRep;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 89   :         }

	ret	0
?count@?$duration@_JU?$ratio@$00$0DOI@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 77   :         }

	mov	eax, ecx
	ret	4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 188  :             return _MyDur;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 189  :         }

	ret	4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; _this$ = ecx

; 179  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

	mov	edx, DWORD PTR __Other$[esp-4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 180  :         }

	mov	eax, ecx
	ret	4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 88   :             return _MyRep;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 89   :         }

	ret	0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
tv203 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT

; 574  :         _NODISCARD static time_point now() noexcept { // get current time

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 575  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

	call	__Query_perf_frequency
	mov	edi, eax
	mov	esi, edx

; 576  :             const long long _Ctr  = _Query_perf_counter();

	call	__Query_perf_counter

; 577  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 578  :             const long long _Whole = (_Ctr / _Freq) * period::den;
; 579  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldvrm
	push	0
	push	1000000000				; 3b9aca00H
	push	ebx
	push	ecx
	mov	DWORD PTR tv203[esp+36], eax
	mov	ebp, edx
	call	__allmul
	push	esi
	push	edi
	push	edx
	push	eax
	call	__alldiv
	mov	esi, eax
	mov	ebx, 1000000000				; 3b9aca00H
	mov	edi, edx
	mov	eax, ebp
	mul	ebx
	mov	ecx, eax
	mov	eax, DWORD PTR tv203[esp+20]
	mul	ebx
	add	ecx, edx

; 580  :             return time_point(duration(_Whole + _Part));

	add	esi, eax

; 179  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]

; 580  :             return time_point(duration(_Whole + _Part));

	adc	edi, ecx

; 179  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

	mov	DWORD PTR [eax+4], edi

; 580  :             return time_point(duration(_Whole + _Part));

	pop	edi

; 179  :         constexpr explicit time_point(const _Duration& _Other) : _MyDur(_Other) { // construct from a duration

	mov	DWORD PTR [eax], esi

; 580  :             return time_point(duration(_Whole + _Part));

	pop	esi
	pop	ebp
	pop	ebx

; 581  :         }

	pop	ecx
	ret	0
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR [ecx+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 398  :     _NODISCARD locale __CLR_OR_THIS_CALL getloc() const { // get locale

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 272  :         _Ptr->_Incref();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 399  :         return *_Ploc;

	mov	eax, esi
	pop	esi

; 400  :     }

	ret	4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?width@ios_base@std@@QAE_J_J@Z
_TEXT	SEGMENT
__Newwidth$ = 8						; size = 8
?width@ios_base@std@@QAE_J_J@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 393  :         const streamsize _Oldwidth = _Wide;

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]
	push	esi

; 394  :         _Wide                      = _Newwidth;

	mov	esi, DWORD PTR __Newwidth$[esp]
	mov	DWORD PTR [ecx+32], esi
	mov	esi, DWORD PTR __Newwidth$[esp+4]
	mov	DWORD PTR [ecx+36], esi

; 395  :         return _Oldwidth;

	pop	esi

; 396  :     }

	ret	8
?width@ios_base@std@@QAE_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?width@ios_base@std@@QBE_JXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 389  :         return _Wide;

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]

; 390  :     }

	ret	0
?width@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?precision@ios_base@std@@QBE_JXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = ecx

; 379  :         return _Prec;

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+28]

; 380  :     }

	ret	0
?precision@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 352  :         return _Fmtfl;

	mov	eax, DWORD PTR [ecx+20]

; 353  :     }

	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 321  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [ecx+12], 0
	sete	al

; 322  :     }

	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 302  :         return _Mystate;

	mov	eax, DWORD PTR [ecx+12]

; 303  :     }

	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -20						; size = 20
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 270  :         _State &= _Statmask;

	mov	eax, DWORD PTR __State$[esp-4]
	sub	esp, 28					; 0000001cH
	and	eax, 23					; 00000017H

; 271  :         _Mystate             = _State;

	mov	DWORD PTR [ecx+12], eax

; 272  :         const auto _Filtered = _State & _Except;

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax

; 273  :         if (_Filtered) {

	je	SHORT $LN2@clear

; 274  :             if (_Reraise) {

	cmp	BYTE PTR __Reraise$[esp+24], 0
	je	SHORT $LN3@clear
	jmp	SHORT $LN11@clear
$LN2@clear:

; 288  :         }
; 289  :     }

	add	esp, 28					; 0000001cH
	ret	8
$LN11@clear:

; 275  :                 _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN3@clear:
	push	esi

; 276  :             }
; 277  : 
; 278  :             const char* _Msg;
; 279  :             if (_Filtered & ios_base::badbit) {

	test	cl, 4
	je	SHORT $LN4@clear

; 280  :                 _Msg = "ios_base::badbit set";

	mov	esi, OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
	jmp	SHORT $LN6@clear
$LN4@clear:

; 281  :             } else if (_Filtered & ios_base::failbit) {

	test	cl, 2
	mov	esi, OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
	mov	eax, OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
	cmove	esi, eax
$LN6@clear:

; 282  :                 _Msg = "ios_base::failbit set";
; 283  :             } else {
; 284  :                 _Msg = "ios_base::eofbit set";
; 285  :             }
; 286  : 
; 287  :             _THROW(failure(_Msg));

	lea	eax, DWORD PTR $T1[esp+32]
	push	1
	push	eax
	call	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
	add	esp, 8
	lea	ecx, DWORD PTR $T2[esp+32]
	push	eax
	push	esi
	call	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[esp+36]
	push	eax
	call	__CxxThrowException@8
	pop	esi
$LN12@clear:
$LN9@clear:
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN14@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN14@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 68   :     {

	push	esi

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	esi, DWORD PTR ___that$[esp]
	xorps	xmm0, xmm0

; 68   :     {

	push	edi
	mov	edi, ecx

; 67   :         : _Data()

	lea	eax, DWORD PTR [edi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	___std_exception_copy
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	add	esp, 8
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	mov	DWORD PTR [edi], OFFSET ??_7failure@ios_base@std@@6B@
	pop	edi
	pop	esi
	ret	4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 226  :         explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))

	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+28], eax
	mov	edx, DWORD PTR __Message$[esp+24]
	mov	eax, DWORD PTR __Errcode$[esp+24]
	push	ebx
	push	ebp
	push	esi

; 227  :             : system_error(_Errcode, _Message) { // construct with message

	mov	ebx, DWORD PTR [eax+4]
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR $T1[esp+56], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 226  :         explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))

	push	edi

; 227  :             : system_error(_Errcode, _Message) { // construct with message

	mov	edi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T1[esp+64], 15		; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR $T1[esp+44], 0

; 301  :         return __builtin_strlen(_First);

	lea	ebp, DWORD PTR [ecx+1]
	npad	5
$LL91@failure:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL91@failure
	sub	ecx, ebp

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T1[esp+52]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 367  :         : _Mybase(_Errcode, _Message) { // construct from error code and message string

	lea	eax, DWORD PTR $T1[esp+44]
	mov	ecx, esi
	push	eax
	push	ebx
	push	edi
	call	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T1[esp+64]
	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN77@failure
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T1[esp+44]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN76@failure

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN94@failure
$LN76@failure:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN77@failure:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 228  :         }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+44]
	mov	eax, esi
	pop	edi
	mov	DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 28					; 0000001cH
	ret	8
$LN94@failure:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN92@failure:
	int	3
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Lock$1 = -76						; size = 4
$T2 = -72						; size = 4
__Lock$3 = -72						; size = 4
$T4 = -68						; size = 16
$T5 = -52						; size = 52
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 434  : { // get facet reference from locale

	sub	esp, 76					; 0000004cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	xor	ebx, ebx

; 435  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	lea	ecx, DWORD PTR __Lock$3[esp+92]
	push	ebx
	mov	DWORD PTR $T2[esp+96], ebx
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	mov	edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id

; 436  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	ebp, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	test	edi, edi
	jne	SHORT $LN9@use_facet

; 100  :                 _BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$1[esp+96]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 101  :                 if (_Id == 0) {

	cmp	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, ebx ; std::ctype<char>::id
	jne	SHORT $LN10@use_facet

; 102  :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN10@use_facet:

; 103  :                 }
; 104  :                 _END_LOCK()

	lea	ecx, DWORD PTR __Lock$1[esp+92]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
$LN9@use_facet:

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	ecx, DWORD PTR __Loc$[esp+88]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN17@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	test	esi, esi
	jne	$LN88@use_facet
	jmp	SHORT $LN91@use_facet
$LN17@use_facet:

; 380  :     }
; 381  : 
; 382  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object
; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	esi, esi
$LN91@use_facet:

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [ecx+20], bl
	je	SHORT $LN15@use_facet

; 385  :             return _Facptr; // found facet or not transparent
; 386  :         } else { // look in current locale
; 387  :             locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 388  :             return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] // get from current locale

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN92@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 437  : 
; 438  :     const size_t _Id         = _Facet::id;
; 439  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 440  : 
; 441  :     if (_Pf == nullptr) {

	test	esi, esi
	jne	$LN88@use_facet
$LN92@use_facet:

; 442  :         if (_Psave != nullptr) {

	test	ebp, ebp
	je	SHORT $LN3@use_facet

; 462  :             _Pf                       = _Psave;
; 463  : 
; 464  :             (void) _Psave_guard.release();
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[esp+92]
	mov	esi, ebp
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

	add	esp, 76					; 0000004cH
	ret	0
$LN3@use_facet:

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN24@use_facet

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	eax, DWORD PTR __Loc$[esp+88]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN29@use_facet
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN34@use_facet
$LN29@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN34@use_facet
	lea	eax, DWORD PTR [ecx+28]
$LN34@use_facet:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	push	eax
	lea	ecx, DWORD PTR $T5[esp+96]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	lea	eax, DWORD PTR $T4[esp+92]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2187 :         : ctype_base(_Refs) { // construct from current locale

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	call	__Getctype
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	mov	ebx, 1

; 2217 :         _Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+8], xmm0

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	jmp	SHORT $LN25@use_facet
$LN24@use_facet:
	xor	esi, esi
$LN25@use_facet:
	test	bl, 1
	je	SHORT $LN26@use_facet
	lea	ecx, DWORD PTR $T5[esp+92]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN26@use_facet:

; 443  :             _Pf = _Psave; // lazy facet already allocated
; 444  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {
; 445  : #if _HAS_EXCEPTIONS
; 446  :             _THROW(bad_cast{}); // lazy disallowed
; 447  : #else // _HAS_EXCEPTIONS
; 448  :             abort(); // lazy disallowed
; 449  : #endif // _HAS_EXCEPTIONS
; 450  :         } else { // queue up lazy facet for destruction
; 451  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);
; 452  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));
; 453  : 
; 454  : #if defined(_M_CEE)
; 455  :             _Facet_Register_m(_Pfmod);
; 456  : #else // defined(_M_CEE)
; 457  :             _Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 458  : #endif // defined(_M_CEE)
; 459  : 
; 460  :             _Pfmod->_Incref();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [edx+4]

; 461  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
$LN88@use_facet:

; 462  :             _Pf                       = _Psave;
; 463  : 
; 464  :             (void) _Psave_guard.release();
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[esp+92]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

	add	esp, 76					; 0000004cH
	ret	0
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2212 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 2221 :         if (0 < _Ctype._Delfl) {

	mov	eax, DWORD PTR [esi+16]

; 2212 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept { // destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@

; 2221 :         if (0 < _Ctype._Delfl) {

	test	eax, eax
	jle	SHORT $LN18@scalar

; 2222 :             _CSTD free((void*) _Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free
	jmp	SHORT $LN19@scalar
$LN18@scalar:

; 2223 :         } else if (_Ctype._Delfl < 0) {

	jns	SHORT $LN9@scalar

; 2224 :             delete[] _Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]
$LN19@scalar:

; 2225 :         }
; 2226 : 
; 2227 :         _CSTD free(_Ctype._LocaleName);

	add	esp, 4
$LN9@scalar:
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN17@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN17@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2275 :         _Adl_verify_range(_First, _Last);
; 2276 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, edx
	push	ecx
	push	edx
	push	DWORD PTR __Dest$[esp+4]
	call	_memcpy

; 2277 :         return _Last;

	mov	eax, DWORD PTR __Last$[esp+8]
	add	esp, 12					; 0000000cH

; 2278 :     }

	ret	16					; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2270 :         return _Ch;

	mov	al, BYTE PTR __Ch$[esp-4]

; 2271 :     }

	ret	8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2264 :         _Adl_verify_range(_First, _Last);
; 2265 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, edx
	push	ecx
	push	edx
	push	DWORD PTR __Dest$[esp+4]
	call	_memcpy

; 2266 :         return _Last;

	mov	eax, DWORD PTR __Last$[esp+8]
	add	esp, 12					; 0000000cH

; 2267 :     }

	ret	12					; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2259 :         return _Byte;

	mov	al, BYTE PTR __Byte$[esp-4]

; 2260 :     }

	ret	4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2249 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

	push	ebx

; 2250 :         _Adl_verify_range((const _Elem*) _First, _Last);
; 2251 :         for (; _First != _Last; ++_First) {

	mov	ebx, DWORD PTR __Last$[esp]
	xor	edx, edx
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	ebx, esi
	push	edi
	xor	edi, edi
	cmp	esi, DWORD PTR __Last$[esp+8]
	cmova	ebx, edx
	test	ebx, ebx
	je	SHORT $LN12@do_toupper
	push	ebp
	lea	ebp, DWORD PTR [ecx+8]
$LL4@do_toupper:

; 2252 :             *_First = (_Elem) _Toupper((unsigned char) *_First, &_Ctype);

	movzx	eax, BYTE PTR [esi]
	push	ebp
	push	eax
	call	__Toupper
	mov	BYTE PTR [esi], al
	inc	edi
	add	esp, 8
	inc	esi
	cmp	edi, ebx
	jne	SHORT $LL4@do_toupper

; 2253 :         }
; 2254 : 
; 2255 :         return (const _Elem*) _First;

	pop	ebp
$LN12@do_toupper:
	pop	edi

; 2256 :     }

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2245 :         return (_Elem) _Toupper((unsigned char) _Ch, &_Ctype);

	lea	eax, DWORD PTR [ecx+8]
	push	eax
	movzx	eax, BYTE PTR __Ch$[esp]
	push	eax
	call	__Toupper
	add	esp, 8

; 2246 :     }

	ret	4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2235 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

	push	ebx

; 2236 :         _Adl_verify_range((const _Elem*) _First, _Last);
; 2237 :         for (; _First != _Last; ++_First) {

	mov	ebx, DWORD PTR __Last$[esp]
	xor	edx, edx
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	ebx, esi
	push	edi
	xor	edi, edi
	cmp	esi, DWORD PTR __Last$[esp+8]
	cmova	ebx, edx
	test	ebx, ebx
	je	SHORT $LN12@do_tolower
	push	ebp
	lea	ebp, DWORD PTR [ecx+8]
$LL4@do_tolower:

; 2238 :             *_First = (_Elem) _Tolower((unsigned char) *_First, &_Ctype);

	movzx	eax, BYTE PTR [esi]
	push	ebp
	push	eax
	call	__Tolower
	mov	BYTE PTR [esi], al
	inc	edi
	add	esp, 8
	inc	esi
	cmp	edi, ebx
	jne	SHORT $LL4@do_tolower

; 2239 :         }
; 2240 : 
; 2241 :         return (const _Elem*) _First;

	pop	ebp
$LN12@do_tolower:
	pop	edi

; 2242 :     }

	mov	eax, esi
	pop	esi
	pop	ebx
	ret	8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2231 :         return (_Elem) _Tolower((unsigned char) _Ch, &_Ctype);

	lea	eax, DWORD PTR [ecx+8]
	push	eax
	movzx	eax, BYTE PTR __Ch$[esp]
	push	eax
	call	__Tolower
	add	esp, 8

; 2232 :     }

	ret	4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2220 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // free any allocated storage

	push	esi
	mov	esi, ecx

; 2221 :         if (0 < _Ctype._Delfl) {

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	jle	SHORT $LN6@Tidy

; 2222 :             _CSTD free((void*) _Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free

; 2225 :         }
; 2226 : 
; 2227 :         _CSTD free(_Ctype._LocaleName);

	add	esp, 4
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
	pop	esi

; 2228 :     }

	ret	0
$LN6@Tidy:

; 2223 :         } else if (_Ctype._Delfl < 0) {

	jns	SHORT $LN4@Tidy

; 2224 :             delete[] _Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]

; 2225 :         }
; 2226 : 
; 2227 :         _CSTD free(_Ctype._LocaleName);

	add	esp, 4
$LN4@Tidy:
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
	pop	esi

; 2228 :     }

	ret	0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2216 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

	sub	esp, 16					; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	lea	eax, DWORD PTR $T1[esp+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2216 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

	push	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2216 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	call	__Getctype
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2217 :         _Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+8], xmm0
	pop	esi

; 2218 :     }

	add	esp, 16					; 00000010H
	ret	4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2212 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 2221 :         if (0 < _Ctype._Delfl) {

	mov	eax, DWORD PTR [esi+16]

; 2212 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept { // destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@

; 2221 :         if (0 < _Ctype._Delfl) {

	test	eax, eax
	jle	SHORT $LN14@ctype

; 2222 :             _CSTD free((void*) _Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free
	jmp	SHORT $LN15@ctype
$LN14@ctype:

; 2223 :         } else if (_Ctype._Delfl < 0) {

	jns	SHORT $LN6@ctype

; 2224 :             delete[] _Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]
$LN15@ctype:

; 2225 :         }
; 2226 : 
; 2227 :         _CSTD free(_Ctype._LocaleName);

	add	esp, 4
$LN6@ctype:
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2214 :     }

	ret	0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 16
$T3 = -52						; size = 52
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2192 :         const locale* _Ploc = nullptr) { // return locale category mask and construct standard facet

	sub	esp, 72					; 00000048H
	push	ebx
	push	edi

; 2193 :         if (_Ppf != nullptr && *_Ppf == nullptr) {

	mov	edi, DWORD PTR __Ppf$[esp+76]
	xor	ebx, ebx
	mov	DWORD PTR $T1[esp+80], ebx
	test	edi, edi
	je	SHORT $LN28@Getcat
	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN28@Getcat

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	push	esi
	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN4@Getcat

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	ecx, DWORD PTR __Ploc$[esp+80]
	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	jne	SHORT $LN9@Getcat
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@
	jmp	SHORT $LN14@Getcat
$LN9@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN14@Getcat
	lea	eax, DWORD PTR [ecx+28]
$LN14@Getcat:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	push	eax
	lea	ecx, DWORD PTR $T3[esp+88]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	lea	eax, DWORD PTR $T2[esp+84]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2187 :         : ctype_base(_Refs) { // construct from current locale

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	call	__Getctype
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	mov	ebx, 1

; 2217 :         _Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+8], xmm0

; 2194 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	esi, esi
$LN5@Getcat:
	mov	DWORD PTR [edi], esi
	pop	esi
	test	bl, 1
	je	SHORT $LN28@Getcat
	lea	ecx, DWORD PTR $T3[esp+80]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN28@Getcat:

; 2195 :         }
; 2196 : 
; 2197 :         return _X_CTYPE;
; 2198 :     }

	pop	edi
	mov	eax, 2
	pop	ebx
	add	esp, 72					; 00000048H
	ret	0
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T1 = -16						; size = 16
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	eax, DWORD PTR __Refs$[esp-4]

; 2186 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)

	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	DWORD PTR [esi+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	lea	eax, DWORD PTR $T1[esp+20]
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2187 :         : ctype_base(_Refs) { // construct from current locale

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 108  :         return ::_Getctype();

	call	__Getctype
	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 2217 :         _Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]

; 2188 :         _Init(_Lobj);
; 2189 :     }

	mov	eax, esi

; 2217 :         _Ctype = _Lobj._Getctype();

	movups	XMMWORD PTR [esi+8], xmm0

; 2188 :         _Init(_Lobj);
; 2189 :     }

	pop	esi
	add	esp, 16					; 00000010H
	ret	8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z PROC		; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2155 :         return do_widen(_First, _Last, _Dest);

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+28]
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2150 :         return do_widen(_Byte);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+32]
	jmp	eax
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN10@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 1853 :     }

	ret	0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	eax, DWORD PTR __Refs$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 1850 :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@
	ret	4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z PROC	; std::_Adl_verify_range<char const *,char const *>, COMDAT

; 217  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 218  :         _Verify_range(_First, _Last);
; 219  :     } else {
; 220  :         (void) _First; // TRANSITION, VSO#486357
; 221  :         (void) _Last; // TRANSITION, VSO#486357
; 222  :     }
; 223  : }

	ret	0
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ENDP	; std::_Adl_verify_range<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	edx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	cmovb	eax, edx

; 22   : }

	ret	0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR __Id$[esp]
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	eax, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	test	eax, eax
	jne	SHORT $LN3@Getfacet
	jmp	SHORT $LN10@Getfacet
$LN6@Getfacet:

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	eax, eax
$LN10@Getfacet:

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN3@Getfacet

; 385  :             return _Facptr; // found facet or not transparent
; 386  :         } else { // look in current locale
; 387  :             locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 388  :             return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] // get from current locale

	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN8@Getfacet
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 389  :                                             : nullptr; // no entry in current locale
; 390  :         }
; 391  :     }

	ret	4
$LN8@Getfacet:

; 388  :             return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] // get from current locale

	xor	eax, eax
$LN3@Getfacet:
	pop	esi

; 389  :                                             : nullptr; // no entry in current locale
; 390  :         }
; 391  :     }

	ret	4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = ecx

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@c_str
	mov	eax, OFFSET ??_C@_00CNPNBAHC@@

; 380  :     }

	ret	0
$LN3@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN7@c_str
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 379  :         return _Ptr == nullptr ? "" : _Ptr->_Name.c_str();

	mov	eax, ecx

; 380  :     }

	ret	0
$LN7@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	add	eax, 28					; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 380  :     }

	ret	0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 359  :         if (_Ptr != nullptr) {

	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN4@locale

; 360  :             delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN4@locale
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN4@locale:

; 361  :         }
; 362  :     }

	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 271  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) { // construct by copying

	mov	eax, DWORD PTR __Right$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 272  :         _Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]

; 273  :     }

	mov	eax, esi
	pop	esi
	ret	4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN8@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 156  :         }

	ret	0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 151  :             : _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs)) // non-atomic initialization

	mov	eax, DWORD PTR __Initrefs$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 153  :         }

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 139  :             if (_MT_DECR(_Myrefs) == 0) {

	or	eax, -1
	lock	 xadd	 DWORD PTR [ecx+4], eax
	mov	eax, 0
	cmove	eax, ecx

; 140  :                 return this;
; 141  :             }
; 142  : 
; 143  :             return nullptr;
; 144  :         }

	ret	0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 135  :             _MT_INCR(_Myrefs);

	lock	 inc	 DWORD PTR [ecx+4]

; 136  :         }

	ret	0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 98   :         __CLR_OR_THIS_CALL operator size_t() { // get stamp, with lazy allocation

	push	ecx
	push	esi
	mov	esi, ecx

; 99   :             if (_Id == 0) { // still zero, allocate stamp

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN5@operator

; 100  :                 _BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$1[esp+12]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 101  :                 if (_Id == 0) {

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN3@operator

; 102  :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR [esi], eax
$LN3@operator:

; 103  :                 }
; 104  :                 _END_LOCK()

	lea	ecx, DWORD PTR __Lock$1[esp+8]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN5@operator:

; 105  :             }
; 106  :             return _Id;
; 107  :         }

	mov	eax, DWORD PTR [esi]
	pop	esi
	pop	ecx
	ret	0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 95   :         __CLR_OR_THIS_CALL id(size_t _Val = 0) : _Id(_Val) { // construct with specified stamp value

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [ecx], eax

; 96   :         }

	mov	eax, ecx
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 3399 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // discard any string

	push	esi
	mov	esi, ecx

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN4@Tidy:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;
; 3409 :     }

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3378 :     __CLR_OR_THIS_CALL ~_Yarn() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Yarn

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN6@Yarn:

; 3379 :         _Tidy();
; 3380 :     }

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3333 :     __CLR_OR_THIS_CALL _Yarn() : _Myptr(nullptr), _Nul(0) { // default construct

	xor	eax, eax
	mov	DWORD PTR [ecx], 0
	mov	WORD PTR [ecx+4], ax

; 3334 :     }

	mov	eax, ecx
	ret	0
??0?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 3399 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // discard any string

	push	esi
	mov	esi, ecx

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN4@Tidy:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;
; 3409 :     }

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 3387 :         return _Myptr != nullptr ? _Myptr : &_Nul;

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN4@c_str
	lea	eax, DWORD PTR [ecx+4]
$LN4@c_str:

; 3388 :     }

	ret	0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 3378 :     __CLR_OR_THIS_CALL ~_Yarn() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Yarn

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN6@Yarn:

; 3379 :         _Tidy();
; 3380 :     }

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 3333 :     __CLR_OR_THIS_CALL _Yarn() : _Myptr(nullptr), _Nul(0) { // default construct

	mov	DWORD PTR [ecx], 0

; 3334 :     }

	mov	eax, ecx
	mov	BYTE PTR [ecx+4], 0
	ret	0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 154  :         return "true";

	mov	eax, OFFSET ??_C@_04LOAJBDKD@true@

; 155  :     }

	ret	0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 150  :         return "false";

	mov	eax, OFFSET ??_C@_05LAPONLG@false@

; 151  :     }

	ret	0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 116  :         return localeconv();

	jmp	_localeconv
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T1 = -44						; size = 44
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 111  :     _Cvtvec __CLR_OR_THIS_CALL _Getcvt() const { // return codecvt stuff

	sub	esp, 44					; 0000002cH

; 112  :         return ::_Getcvt();

	lea	eax, DWORD PTR $T1[esp+44]
	push	eax
	call	__Getcvt
	mov	edx, DWORD PTR ___$ReturnUdt$[esp+44]
	movups	xmm0, XMMWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+40]
	movups	XMMWORD PTR [edx], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [edx+16], xmm0
	movq	xmm0, QWORD PTR [eax+32]
	mov	eax, edx
	movq	QWORD PTR [edx+32], xmm0
	mov	DWORD PTR [edx+40], ecx

; 113  :     }

	add	esp, 48					; 00000030H
	ret	4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 107  :     _Ctypevec __CLR_OR_THIS_CALL _Getctype() const { // return ctype stuff

	sub	esp, 16					; 00000010H

; 108  :         return ::_Getctype();

	lea	eax, DWORD PTR $T1[esp+16]
	push	eax
	call	__Getctype
	movups	xmm0, XMMWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	movups	XMMWORD PTR [eax], xmm0

; 109  :     }

	add	esp, 20					; 00000014H
	ret	4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 87   :     __CLR_OR_THIS_CALL ~_Locinfo() noexcept { // destroy the object

	push	esi
	mov	esi, ecx

; 88   :         _Locinfo_dtor(this);

	push	esi
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+44]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 88   :         _Locinfo_dtor(this);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3400 :         if (_Myptr != nullptr) {

	test	eax, eax
	je	SHORT $LN6@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN6@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+44], 0

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN11@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN11@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+36], 0

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN16@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN16@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+28], 0

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN21@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN21@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+20], 0

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN26@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN26@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+12], 0

; 3400 :         if (_Myptr != nullptr) {

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN31@Locinfo

; 3401 : #ifdef _DEBUG
; 3402 :             _free_dbg(_Myptr, _CRT_BLOCK);
; 3403 : #else // _DEBUG
; 3404 :             _CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN31@Locinfo:

; 3405 : #endif // _DEBUG
; 3406 :         }
; 3407 : 
; 3408 :         _Myptr = nullptr;

	mov	DWORD PTR [esi+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 89   :     }

	mov	ecx, esi
	pop	esi
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 66   :     { // construct from NTBS

	push	esi
	push	0
	mov	esi, ecx
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3333 :     __CLR_OR_THIS_CALL _Yarn() : _Myptr(nullptr), _Nul(0) { // default construct

	xor	eax, eax
	mov	DWORD PTR [esi+4], 0
	mov	WORD PTR [esi+24], ax
	mov	DWORD PTR [esi+28], eax
	mov	WORD PTR [esi+32], ax
	mov	DWORD PTR [esi+36], eax
	mov	BYTE PTR [esi+40], al
	mov	DWORD PTR [esi+44], eax
	mov	BYTE PTR [esi+48], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 67   :         if (_Pch == nullptr) {

	mov	eax, DWORD PTR __Pch$[esp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3333 :     __CLR_OR_THIS_CALL _Yarn() : _Myptr(nullptr), _Nul(0) { // default construct

	mov	BYTE PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	BYTE PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocinfo

; 67   :         if (_Pch == nullptr) {

	test	eax, eax
	je	SHORT $LN18@Locinfo

; 69   :         }
; 70   : 
; 71   :         _Locinfo_ctor(this, _Pch);

	push	eax
	push	esi
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
	add	esp, 8

; 72   :     }

	mov	eax, esi
	pop	esi
	ret	4
$LN18@Locinfo:

; 68   :             _Xruntime_error("bad locale name");

	push	OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
	call	?_Xruntime_error@std@@YAXPBD@Z		; std::_Xruntime_error
$LN16@Locinfo:
	int	3
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN6@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT	SEGMENT
??0_Facet_base@std@@QAE@XZ PROC				; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
	mov	eax, ecx
	ret	0
??0_Facet_base@std@@QAE@XZ ENDP				; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 24   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept { // ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@

; 25   :     }

	ret	0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_typeinfo.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 131  :     {

	xorps	xmm0, xmm0

; 132  :     }

	mov	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 61   :         : _Data()

	movq	QWORD PTR [ecx+4], xmm0

; 62   :     {
; 63   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_typeinfo.h

; 131  :     {

	mov	DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@

; 132  :     }

	ret	0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ PROC ; std::_Immortalize<std::_Iostream_error_category>, COMDAT

; 502  :     static_assert(sizeof(void*) == sizeof(once_flag), "TRANSITION, VSO#406237");
; 503  :     static_assert(alignof(void*) == alignof(once_flag), "TRANSITION, VSO#406237");
; 504  :     static void* _Flag = nullptr;
; 505  :     static aligned_union_t<1, _Ty> _Storage;
; 506  :     if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage)
; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	push	OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	push	OFFSET ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
	push	OFFSET ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
	call	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z ; std::_Execute_once
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	_terminate

; 508  :         _STD terminate();
; 509  :     }
; 510  : 
; 511  :     return reinterpret_cast<_Ty&>(_Storage);

	mov	eax, OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage

; 512  : }

	ret	0
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ENDP ; std::_Immortalize<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	je	SHORT $LN10@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 429  :         if (_Errcode == (int) io_errc::stream) {

	mov	eax, DWORD PTR __Errcode$[esp-4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	cmp	eax, 1
	jne	SHORT $LN2@message
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	21					; 00000015H
	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error@
	mov	ecx, esi

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 434  :     }

	mov	eax, esi
	pop	esi
	ret	8
$LN2@message:
	push	edi

; 413  :         return _Syserror_map(_Errcode);

	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	mov	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 413  :         return _Syserror_map(_Errcode);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]
$LL67@message:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL67@message
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 432  :             return _Generic_error_category::message(_Errcode);

	pop	edi

; 434  :     }

	mov	eax, esi
	pop	esi
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 425  :         return "iostream";

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream@

; 426  :     }

	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 420  :     _Iostream_error_category() noexcept { // default constructor

	mov	DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@

; 421  :         _Addr = _Iostream_addr;
; 422  :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 5
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	je	SHORT $LN8@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 412  :     _NODISCARD virtual string message(int _Errcode) const override { // convert to name of error

	push	esi
	push	edi

; 413  :         return _Syserror_map(_Errcode);

	push	DWORD PTR __Errcode$[esp+4]
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 413  :         return _Syserror_map(_Errcode);

	mov	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 413  :         return _Syserror_map(_Errcode);

	add	esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	npad	6
$LL33@message:

; 301  :         return __builtin_strlen(_First);

	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL33@message
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 413  :         return _Syserror_map(_Errcode);

	pop	edi
	mov	eax, esi
	pop	esi

; 414  :     }

	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 409  :         return "generic";

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic@

; 410  :     }

	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 404  :     _Generic_error_category() noexcept { // default constructor

	mov	DWORD PTR [ecx], OFFSET ??_7_Generic_error_category@std@@6B@

; 405  :         _Addr = _Generic_addr;
; 406  :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 3
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN12@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx

; 68   :     {

	push	esi

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	esi, DWORD PTR ___that$[esp]
	xorps	xmm0, xmm0

; 68   :     {

	push	edi
	mov	edi, ecx

; 67   :         : _Data()

	lea	eax, DWORD PTR [edi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	___std_exception_copy
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	add	esp, 8
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	mov	DWORD PTR [edi], OFFSET ??_7system_error@std@@6B@
	pop	edi
	pop	esi
	ret	4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 366  :     system_error(error_code _Errcode, const char* _Message)

	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+28], eax
	mov	edx, DWORD PTR __Message$[esp+24]
	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR $T1[esp+48], 0

; 301  :         return __builtin_strlen(_First);

	mov	ecx, edx

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T1[esp+52], 15		; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 366  :     system_error(error_code _Errcode, const char* _Message)

	push	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 343  :         _Left = _Right;

	mov	BYTE PTR $T1[esp+36], 0

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [ecx+1]
$LL88@system_err:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL88@system_err
	sub	ecx, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T1[esp+44]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 367  :         : _Mybase(_Errcode, _Message) { // construct from error code and message string

	lea	eax, DWORD PTR $T1[esp+36]
	mov	ecx, esi
	push	eax
	push	DWORD PTR __Errcode$[esp+40]
	push	DWORD PTR __Errcode$[esp+40]
	call	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T1[esp+56]
	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN75@system_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T1[esp+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN74@system_err

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN91@system_err
$LN74@system_err:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN75@system_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 368  :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+36]
	mov	eax, esi
	pop	edi
	mov	DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
$LN91@system_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN89@system_err:
	int	3
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 68   :     {

	push	esi

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	esi, DWORD PTR ___that$[esp]
	xorps	xmm0, xmm0

; 68   :     {

	push	edi
	mov	edi, ecx

; 67   :         : _Data()

	lea	eax, DWORD PTR [edi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	___std_exception_copy
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	add	esp, 8
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	pop	edi
	pop	esi
	ret	4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = -84						; size = 24
__InitData$2 = -60					; size = 8
$T3 = -52						; size = 24
$T4 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 348  :           _Mycode(_Errcode) { // construct from error code and message string

	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+84], eax
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Message$[esp+96]
	mov	ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	ebp, DWORD PTR [edi+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN35@System_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edi, DWORD PTR [edi]
$LN35@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2443 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	ebp, 16					; 00000010H
	jae	SHORT $LN24@System_err

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	xmm0, XMMWORD PTR [edi]

; 2446 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR $T1[esp+120], 15		; 0000000fH

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	XMMWORD PTR $T1[esp+100], xmm0

; 2447 :             return;

	jmp	SHORT $LN337@System_err
$LN24@System_err:

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	esi, ebp

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR $T1[esp+100]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	eax, 2147483647				; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	or	esi, 15					; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	esi, eax
	cmova	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	ecx, eax

; 2453 :         _Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_array);
; 2454 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	eax, DWORD PTR [ebp+1]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	edi
	push	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR $T1[esp+112], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	call	_memcpy
	add	esp, 12					; 0000000cH

; 2456 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR $T1[esp+120], esi
$LN337@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 347  :         : runtime_error(_Makestr(_Errcode, _Message)),

	mov	edi, DWORD PTR __Errcode$[esp+96]
	mov	esi, DWORD PTR __Errcode$[esp+100]
	mov	DWORD PTR $T1[esp+116], ebp
	test	ebp, ebp

; 337  :         if (!_Message.empty()) {

	je	SHORT $LN78@System_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2627 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@
	lea	ecx, DWORD PTR $T1[esp+108]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN78@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 151  :         return category().message(value());

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T3[esp+100]
	push	edi
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR $T3[esp+120], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T3[esp+100]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	push	DWORD PTR $T3[esp+116]

; 2024 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR $T3[esp+104]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	lea	ecx, DWORD PTR $T1[esp+104]
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T3[esp+120]
	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN155@System_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T3[esp+100]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN154@System_err

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN339@System_err
$LN154@System_err:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN155@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm1, XMMWORD PTR $T1[esp+100]

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	ecx, DWORD PTR $T4[esp+100]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR $T1[esp+120], 16		; 00000010H

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movq	xmm0, QWORD PTR $T1[esp+116]

; 2024 :         if (_Large_string_engaged()) {

	movd	eax, xmm1

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movq	QWORD PTR $T4[esp+116], xmm0
	xorps	xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 55   :     {

	mov	DWORD PTR [ebx], OFFSET ??_7exception@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	cmovae	ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 54   :         : _Data()

	movq	QWORD PTR [ebx+4], xmm0
	lea	eax, DWORD PTR [ebx+4]

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$2[esp+100], ecx

; 57   :         __std_exception_copy(&_InitData, &_Data);

	push	eax
	lea	eax, DWORD PTR __InitData$2[esp+104]
	mov	BYTE PTR __InitData$2[esp+108], 1
	push	eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	XMMWORD PTR $T4[esp+108], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 57   :         __std_exception_copy(&_InitData, &_Data);

	call	___std_exception_copy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T4[esp+128]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 57   :         __std_exception_copy(&_InitData, &_Data);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

	mov	DWORD PTR [ebx], OFFSET ??_7runtime_error@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN324@System_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T4[esp+100]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN323@System_err

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN340@System_err
$LN323@System_err:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN324@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 348  :           _Mycode(_Errcode) { // construct from error code and message string

	mov	ecx, DWORD PTR __Errcode$[esp+96]

; 349  :     }

	mov	eax, ebx
	pop	edi
	mov	DWORD PTR [ebx+12], ecx
	mov	ecx, DWORD PTR __Errcode$[esp+96]
	pop	esi
	mov	DWORD PTR [ebx+16], ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+92]
	pop	ebp
	mov	DWORD PTR [ebx], OFFSET ??_7_System_error@std@@6B@
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 84					; 00000054H
	ret	12					; 0000000cH
$LN339@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN340@System_err:
	call	__invalid_parameter_noinfo_noreturn
$LN336@System_err:
	int	3
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 24
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 336  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+28], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3321 :         return size() == 0;

	cmp	DWORD PTR __Message$[esp+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 336  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+28]

; 337  :         if (!_Message.empty()) {

	je	SHORT $LN2@Makestr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2627 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02LMMGGCAJ@?3?5@
	lea	ecx, DWORD PTR __Message$[esp+36]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Makestr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 151  :         return category().message(value());

	mov	ecx, DWORD PTR __Errcode$[esp+32]
	lea	edx, DWORD PTR $T1[esp+32]
	push	DWORD PTR __Errcode$[esp+28]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR $T1[esp+52], 16		; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	eax, DWORD PTR $T1[esp+32]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	push	DWORD PTR $T1[esp+48]

; 2024 :         if (_Large_string_engaged()) {

	cmovae	eax, DWORD PTR $T1[esp+36]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	lea	ecx, DWORD PTR __Message$[esp+32]
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	edx, DWORD PTR $T1[esp+52]
	cmp	edx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN79@Makestr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T1[esp+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN78@Makestr

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN190@Makestr
$LN78@Makestr:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN79@Makestr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR __Message$[esp+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 343  :     }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+32]
	mov	eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR __Message$[esp+44]
	movq	QWORD PTR [esi+16], xmm0
	pop	esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 343  :     }

	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 28					; 0000001cH
	ret	0
$LN190@Makestr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN188@Makestr:
	int	3
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??8std@@YA_NABVerror_condition@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8std@@YA_NABVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 83   :         return _Addr == _Right._Addr;

	mov	edx, DWORD PTR __Left$[esp-4]

; 233  :     const error_condition& _Left, const error_condition& _Right) noexcept { // test errors for equality

	push	esi

; 83   :         return _Addr == _Right._Addr;

	mov	esi, DWORD PTR __Right$[esp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [ecx+4]

; 234  :     return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN3@operator
	mov	al, 1
	pop	esi

; 235  : }

	ret	0
$LN3@operator:

; 234  :     return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	xor	al, al
	pop	esi

; 235  : }

	ret	0
??8std@@YA_NABVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 200  :         return *_Mycat;

	mov	eax, DWORD PTR [ecx+4]

; 201  :     }

	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 196  :         return _Myval;

	mov	eax, DWORD PTR [ecx]

; 197  :     }

	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 170  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Cat$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 171  :     }

	mov	eax, ecx
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 145  :         return *_Mycat;

	mov	eax, DWORD PTR [ecx+4]

; 151  :         return category().message(value());

	push	DWORD PTR [ecx]
	mov	ecx, eax
	push	DWORD PTR ___$ReturnUdt$[esp]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 152  :     }

	ret	4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 145  :         return *_Mycat;

	mov	eax, DWORD PTR [ecx+4]

; 146  :     }

	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 141  :         return _Myval;

	mov	eax, DWORD PTR [ecx]

; 142  :     }

	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 115  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Cat$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 116  :     }

	mov	eax, ecx
	ret	8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 83   :         return _Addr == _Right._Addr;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	sete	al

; 84   :     }

	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 83   :         return _Addr == _Right._Addr;

	mov	eax, DWORD PTR [ecx+4]

; 282  :     noexcept { // test if conditions same for this category

	push	esi

; 83   :         return _Addr == _Right._Addr;

	mov	esi, DWORD PTR __Code$[esp]
	mov	edx, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [edx+4]

; 283  :     return *this == _Code.category() && _Code.value() == _Errval;

	jne	SHORT $LN3@equivalent
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR __Errval$[esp]
	jne	SHORT $LN3@equivalent
	mov	al, 1
	pop	esi

; 284  : }

	ret	8
$LN3@equivalent:

; 283  :     return *this == _Code.category() && _Code.value() == _Errval;

	xor	al, al
	pop	esi

; 284  : }

	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 278  :     return default_error_condition(_Errval) == _Cond;

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T1[esp]
	sub	esp, 8
	push	esi
	push	DWORD PTR __Errval$[esp+8]
	push	edx
	call	DWORD PTR [eax+12]

; 83   :         return _Addr == _Right._Addr;

	mov	esi, DWORD PTR __Cond$[esp+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx+4]

; 234  :     return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	jne	SHORT $LN5@equivalent
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN5@equivalent
	mov	al, 1
	pop	esi

; 279  : }

	add	esp, 8
	ret	8
$LN5@equivalent:

; 234  :     return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	xor	al, al
	pop	esi

; 279  : }

	add	esp, 8
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 170  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Errval$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 273  :     return error_condition(_Errval, *this);
; 274  : }

	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 70   :     virtual ~error_category() noexcept {}

	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 66   :         // default constructor
; 67   :         _Addr = reinterpret_cast<uintptr_t>(this);

	mov	DWORD PTR [ecx+4], ecx

; 68   :     }

	mov	eax, ecx
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?iostream_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAABVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	push	OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	push	OFFSET ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
	push	OFFSET ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
	call	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z ; std::_Execute_once
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	_terminate

; 520  :     return _Immortalize<_Iostream_error_category>();
; 521  : }

	mov	eax, OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	ret	0
?iostream_category@std@@YAABVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	push	OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	push	OFFSET ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
	push	OFFSET ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
	call	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z ; std::_Execute_once
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	_terminate

; 115  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Errno$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage

; 298  :     return error_code((int) _Errno, iostream_category());
; 299  : }

	ret	0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 68   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 67   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[esp+4]
	add	eax, 4
	push	eax
	call	___std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2023 :         const value_type* _Result = _Bx._Buf;

	mov	edx, DWORD PTR __Message$[esp-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

	sub	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edx+20], 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

	push	esi
	mov	esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@runtime_er
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edx, DWORD PTR [edx]
$LN10@runtime_er:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 54   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 55   :     {

	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$1[esp+12], edx

; 57   :         __std_exception_copy(&_InitData, &_Data);

	push	eax
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR __InitData$1[esp+16]
	push	eax
	mov	BYTE PTR __InitData$1[esp+24], 1
	call	___std_exception_copy
	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 127  :     }

	mov	eax, esi
	pop	esi
	add	esp, 8
	ret	4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1549 :         return _Myval2;

	mov	eax, ecx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 1545 :         return _Myval2;

	mov	eax, ecx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1541 :         return *this;

	mov	eax, ecx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1537 :         return *this;

	mov	eax, ecx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data, COMDAT
; _this$ = ecx

; 3912 :         return _Mypair._Get_second();

	mov	eax, ecx

; 3913 :     }

	ret	0
?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data, COMDAT
; _this$ = ecx

; 3908 :         return _Mypair._Get_second();

	mov	eax, ecx

; 3909 :     }

	ret	0
?_Get_data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3904 :         return _Mypair._Get_first();

	mov	eax, ecx

; 3905 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3900 :         return _Mypair._Get_first();

	mov	eax, ecx

; 3901 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Orphan_all@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Orphan_all, COMDAT
; _this$ = ecx

; 3891 :         _Get_data()._Orphan_all();
; 3892 :     }

	ret	0
?_Orphan_all@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 3886 :         _Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3868 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	esi
	mov	esi, ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3869 :         _Orphan_all();
; 3870 :         auto& _My_data = _Get_data();
; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN41@Tidy_deall
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN40@Tidy_deall

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN37@Tidy_deall

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN40@Tidy_deall:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN41@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi

; 3883 :     }

	ret	0
$LN37@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN46@Tidy_deall:
	int	3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3860 :         auto& _My_data   = _Get_data();
; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ecx], 0

; 3863 :         // the _Traits::assign is last so the codegen doesn't think the char
; 3864 :         // write can alias this
; 3865 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3866 :     }

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	mov	eax, DWORD PTR __Newsize$[esp-4]
	mov	DWORD PTR [ecx+16], eax
	jb	SHORT $LN16@Eos
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 343  :         _Left = _Right;

	mov	BYTE PTR [edx+eax], 0

; 3855 :         auto& _My_data = _Get_data();
; 3856 :         _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());
; 3857 :     }

	ret	4
$LN16@Eos:

; 343  :         _Left = _Right;

	mov	BYTE PTR [ecx+eax], 0

; 3855 :         auto& _My_data = _Get_data();
; 3856 :         _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());
; 3857 :     }

	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 3766 :         const size_type _Max    = max_size();
; 3767 :         auto& _My_data          = _Get_data();
; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edx, DWORD PTR __Requested$[esp-4]
	or	edx, 15					; 0000000fH
	push	esi
	cmp	edx, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN25@Calculate_

; 3770 :             return _Max;
; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;

	mov	esi, DWORD PTR [ecx+20]

; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, 2147483647				; 7fffffffH
	mov	ecx, esi
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	ja	SHORT $LN25@Calculate_

; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	edx, eax
	pop	esi
	cmovb	edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	mov	eax, edx

; 3779 :     }

	ret	4
$LN25@Calculate_:

; 3775 :             return _Max;

	mov	eax, 2147483647				; 7fffffffH
	pop	esi

; 3779 :     }

	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 3321 :         return size() == 0;

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 3322 :     }

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
tv665 = -12						; size = 4
tv657 = -12						; size = 4
tv658 = -8						; size = 4
__Old_size$1$ = -8					; size = 4
__Old$1$ = -4						; size = 4
__New_ptr$1$ = 8					; size = 4
__Newsize$ = 8						; size = 4
tv663 = 12						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 3276 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Elem _Ch = _Elem()) {

	sub	esp, 12					; 0000000cH
	push	ebp

; 3277 :         // determine new length, padding with _Ch elements as needed
; 3278 :         const size_type _Old_size = size();
; 3279 :         if (_Newsize <= _Old_size) {

	mov	ebp, DWORD PTR __Newsize$[esp+12]
	push	esi
	mov	esi, ecx

; 3264 :         return _Get_data()._Mysize;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR __Old_size$1$[esp+20], ecx

; 3276 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Elem _Ch = _Elem()) {

	push	edi

; 3264 :         return _Get_data()._Mysize;

	mov	edx, DWORD PTR [esi+20]
	lea	edi, DWORD PTR [esi+16]
	mov	DWORD PTR tv665[esp+24], edi
	mov	DWORD PTR __Old$1$[esp+24], edx

; 3277 :         // determine new length, padding with _Ch elements as needed
; 3278 :         const size_type _Old_size = size();
; 3279 :         if (_Newsize <= _Old_size) {

	cmp	ebp, ecx
	ja	SHORT $LN2@resize

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN18@resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	esi, DWORD PTR [esi]
$LN18@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3856 :         _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi], ebp
	pop	edi

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebp], 0

; 3284 :     }

	pop	esi
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
$LN2@resize:
	push	ebx

; 3280 :             _Eos(_Newsize);
; 3281 :         } else {
; 3282 :             append(_Newsize - _Old_size, _Ch);

	mov	ebx, ebp

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	eax, edx

; 3280 :             _Eos(_Newsize);
; 3281 :         } else {
; 3282 :             append(_Newsize - _Old_size, _Ch);

	sub	ebx, ecx

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN27@resize

; 2634 :             _My_data._Mysize      = _Old_size + _Count;

	mov	DWORD PTR [edi], ebp

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN34@resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	esi, DWORD PTR [esi]
$LN34@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+24]

; 2636 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	add	esi, ecx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
	pop	ebx
	pop	edi

; 3284 :     }

	pop	esi
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
$LN27@resize:

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	eax, 2147483647				; 7fffffffH
	sub	eax, ecx
	cmp	eax, ebx
	jb	$LN149@resize

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	edi, ebp
	or	edi, 15					; 0000000fH
	cmp	edi, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN68@resize

; 3770 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN67@resize
$LN68@resize:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, edx
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN69@resize

; 3775 :             return _Max;

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN67@resize
$LN69@resize:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+edx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	edi, eax
	cmovb	edi, eax
$LN67@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;

	mov	ecx, DWORD PTR tv665[esp+28]

; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR [esi+20], edi
	mov	DWORD PTR __New_ptr$1$[esp+24], eax
	mov	DWORD PTR [ecx], ebp

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	movsx	ecx, BYTE PTR __Ch$[esp+24]

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	ebp, DWORD PTR __Old$1$[esp+28]
	mov	DWORD PTR tv663[esp+24], ecx
	mov	ecx, DWORD PTR __Old_size$1$[esp+28]
	push	ecx
	lea	edi, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv658[esp+32], edi
	lea	edx, DWORD PTR [edi+ebx]
	mov	DWORD PTR tv657[esp+32], edx
	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN46@resize

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [esi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	DWORD PTR tv663[esp+40]
	push	DWORD PTR tv658[esp+48]
	call	_memset

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv657[esp+52]

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	inc	ebp

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebp, 4096				; 00001000H
	jb	SHORT $LN123@resize

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [edi-4]
	add	ebp, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN120@resize

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	edi, ecx
$LN123@resize:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ebp
	push	edi
	call	??3@YAXPAXI@Z				; operator delete

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR __New_ptr$1$[esp+32]

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [esi], eax
	pop	ebx
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3284 :     }

	pop	esi
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
$LN46@resize:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	DWORD PTR tv663[esp+40]
	push	edi
	call	_memset
	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi+ebx], 0
	lea	eax, DWORD PTR [edi+ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	eax, DWORD PTR __New_ptr$1$[esp+24]
	mov	DWORD PTR [esi], eax
	pop	ebx
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3284 :     }

	pop	esi
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	8
$LN149@resize:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN150@resize:
$LN120@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN151@resize:
$LN146@resize:
	int	3
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3268 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3269 :         const size_type _Storage_max = // can always store small string
; 3270 :             _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3271 :         return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, 2147483647				; 7fffffffH

; 3272 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3273 :         );
; 3274 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3264 :         return _Get_data()._Mysize;

	mov	eax, DWORD PTR [ecx+16]

; 3265 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN14@c_str

; 3246 :         return _Get_data()._Myptr();

	mov	eax, DWORD PTR [ecx]

; 3247 :     }

	ret	0
$LN14@c_str:

; 3246 :         return _Get_data()._Myptr();

	mov	eax, ecx

; 3247 :     }

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2024 :         if (_Large_string_engaged()) {

	mov	eax, DWORD PTR __Off$[esp-4]
	jb	SHORT $LN14@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	ecx, DWORD PTR [ecx]
$LN14@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3190 :     }

	add	eax, ecx
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	mov	eax, DWORD PTR __Off$[esp-4]
	jb	SHORT $LN14@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	ecx, DWORD PTR [ecx]
$LN14@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3182 :     }

	add	eax, ecx
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
__Old$1$ = -16						; size = 4
tv595 = -12						; size = 4
tv593 = -8						; size = 4
__New_ptr$1$ = -4					; size = 4
__Off$ = 8						; size = 4
tv594 = 12						; size = 4
__Count$ = 12						; size = 4
tv603 = 16						; size = 4
__Ch$ = 16						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2801 :     basic_string& insert(const size_type _Off, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi
	mov	edi, ecx

; 2036 :         if (_Mysize < _Off) {

	mov	ecx, DWORD PTR __Off$[esp+20]
	mov	ebx, DWORD PTR [edi+16]
	cmp	ebx, ecx
	jb	$LN127@insert

; 2802 :         // insert _Count * _Ch at _Off
; 2803 :         auto& _My_data = _Get_data();
; 2804 :         _My_data._Check_offset(_Off);
; 2805 :         const size_type _Old_size = _My_data._Mysize;
; 2806 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	edx, DWORD PTR [edi+20]
	mov	eax, edx
	push	ebp
	mov	ebp, DWORD PTR __Count$[esp+24]
	sub	eax, ebx
	mov	DWORD PTR __Old$1$[esp+28], edx
	push	esi
	cmp	ebp, eax
	ja	SHORT $LN2@insert

; 2807 :             _My_data._Mysize        = _Old_size + _Count;

	lea	eax, DWORD PTR [ebx+ebp]
	mov	DWORD PTR [edi+16], eax

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	eax, edi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	edx, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN13@insert
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	eax, DWORD PTR [edi]
$LN13@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	sub	ebx, ecx

; 2808 :             _Elem* const _Old_ptr   = _My_data._Myptr();
; 2809 :             _Elem* const _Insert_at = _Old_ptr + _Off;

	lea	esi, DWORD PTR [eax+ecx]

; 2810 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	ebx
	lea	eax, DWORD PTR [esi+ebp]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	ebx
	push	esi
	push	eax
	call	_memmove

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+40]
	push	ebp
	push	eax
	push	esi
	call	_memset
	add	esp, 24					; 00000018H

; 2823 :     }

	mov	eax, edi
	pop	esi
	pop	ebp
	pop	edi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN2@insert:

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	sub	eax, ebx
	cmp	eax, ebp
	jb	$LN128@insert

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	esi, DWORD PTR [ebx+ebp]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, ecx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN47@insert

; 3770 :             return _Max;

	mov	esi, ecx
	jmp	SHORT $LN46@insert
$LN47@insert:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, edx
	shr	eax, 1
	sub	ecx, eax
	cmp	edx, ecx
	jbe	SHORT $LN48@insert

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN46@insert
$LN48@insert:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN46@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	mov	ecx, edi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	ecx, eax

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;

	mov	DWORD PTR [edi+20], esi
	lea	eax, DWORD PTR [ebx+ebp]
	mov	DWORD PTR __New_ptr$1$[esp+32], ecx
	mov	DWORD PTR [edi+16], eax

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	movsx	eax, BYTE PTR __Ch$[esp+28]
	mov	DWORD PTR tv603[esp+28], eax
	mov	eax, DWORD PTR __Off$[esp+28]
	sub	ebx, eax

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	push	eax
	lea	edx, DWORD PTR [ebx+1]
	mov	ebx, DWORD PTR __Old$1$[esp+36]
	mov	DWORD PTR tv594[esp+32], edx
	lea	esi, DWORD PTR [ecx+eax]
	mov	DWORD PTR tv595[esp+36], esi
	lea	edx, DWORD PTR [esi+ebp]
	mov	DWORD PTR tv593[esp+36], edx
	cmp	ebx, 16					; 00000010H
	jb	SHORT $LN25@insert

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR [edi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ecx
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebp
	push	DWORD PTR tv603[esp+44]
	push	DWORD PTR tv595[esp+52]
	call	_memset

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv594[esp+52]

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	eax, DWORD PTR __Off$[esp+56]
	add	eax, esi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	mov	eax, DWORD PTR tv593[esp+64]
	push	eax
	call	_memcpy

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	inc	ebx

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 36					; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebx, 4096				; 00001000H
	jb	SHORT $LN102@insert

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [esi-4]
	add	ebx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN99@insert

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, ecx
$LN102@insert:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ebx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2815 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2815 :         return _Reallocate_grow_by(_Count,

	mov	DWORD PTR [edi], eax

; 2823 :     }

	mov	eax, edi
	pop	esi
	pop	ebp
	pop	edi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN25@insert:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ecx
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebp
	push	DWORD PTR tv603[esp+44]
	push	esi
	call	_memset

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR tv594[esp+52]

; 2820 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	eax, DWORD PTR __Off$[esp+56]
	add	eax, edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	lea	eax, DWORD PTR [esi+ebp]
	push	eax
	call	_memcpy

; 2815 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+68]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 36					; 00000024H

; 2815 :         return _Reallocate_grow_by(_Count,

	mov	DWORD PTR [edi], eax

; 2823 :     }

	mov	eax, edi
	pop	esi
	pop	ebp
	pop	edi
	pop	ebx
	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
$LN127@insert:

; 2037 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN128@insert:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN129@insert:
$LN99@insert:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN130@insert:
$LN124@insert:
	int	3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__New_ptr$1$ = 8					; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2707 :     basic_string& assign(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // assign _Count * _Ch

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 2708 :         auto& _My_data = _Get_data();
; 2709 :         if (_Count <= _My_data._Myres) {

	mov	edi, DWORD PTR __Count$[esp+12]
	mov	ebp, DWORD PTR [esi+20]
	cmp	edi, ebp
	ja	SHORT $LN2@assign

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	ebx, esi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	ebp, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	ebx, DWORD PTR [esi]
$LN9@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+12]
	push	edi
	push	eax
	push	ebx

; 2710 :             _Elem* const _Old_ptr = _My_data._Myptr();
; 2711 :             _My_data._Mysize      = _Count;

	mov	DWORD PTR [esi+16], edi

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ebx+edi], 0

; 2718 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
; 2719 :                 _Traits::assign(_New_ptr, _Count, _Ch);
; 2720 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2721 :             },
; 2722 :             _Ch);
; 2723 :     }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN2@assign:

; 3785 :         if (_New_size > max_size()) {

	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN110@assign

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	ebx, edi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN43@assign

; 3770 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN43@assign:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, ebp
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	ebp, eax
	jbe	SHORT $LN44@assign

; 3775 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN44@assign:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	ebx, eax
	cmovb	ebx, eax
$LN42@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Ch$[esp+12]
	push	edi
	push	ecx
	push	eax

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	DWORD PTR __New_ptr$1$[esp+24], eax

; 3794 :         _My_data._Orphan_all();
; 3795 :         _My_data._Mysize = _New_size;

	mov	DWORD PTR [esi+16], edi

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR [esi+20], ebx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	call	_memset

; 343  :         _Left = _Right;

	mov	ebx, DWORD PTR __New_ptr$1$[esp+24]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ebx+edi], 0

; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN21@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebp, 4096				; 00001000H
	jb	SHORT $LN94@assign

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	ebp, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN91@assign

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN94@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ebp
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN21@assign:
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2717 :         return _Reallocate_for(_Count,

	mov	DWORD PTR [esi], ebx

; 2718 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
; 2719 :                 _Traits::assign(_New_ptr, _Count, _Ch);
; 2720 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2721 :             },
; 2722 :             _Ch);
; 2723 :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN91@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN110@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN107@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 301  :         return __builtin_strlen(_First);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	mov	eax, edx

; 2703 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) { // assign [_Ptr, <null>)

	push	esi
	push	edi
	mov	esi, ecx

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [eax+1]
	npad	3
$LL7@assign:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL7@assign
	sub	eax, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 2705 :     }

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__New_ptr$1$ = 12					; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2684 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 2685 :         // assign [_Ptr, _Ptr + _Count)
; 2686 :         auto& _My_data = _Get_data();
; 2687 :         if (_Count <= _My_data._Myres) {

	mov	edi, DWORD PTR __Count$[esp+12]
	mov	ebp, DWORD PTR [esi+20]
	cmp	edi, ebp
	ja	SHORT $LN2@assign

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	ebx, esi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	ebp, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	ebx, DWORD PTR [esi]
$LN9@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	edi
	push	DWORD PTR __Ptr$[esp+16]

; 2688 :             _Elem* const _Old_ptr = _My_data._Myptr();
; 2689 :             _My_data._Mysize      = _Count;

	mov	DWORD PTR [esi+16], edi

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ebx+edi], 0

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2697 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2698 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2699 :             },
; 2700 :             _Ptr);
; 2701 :     }

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN2@assign:

; 3785 :         if (_New_size > max_size()) {

	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN110@assign

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	ebx, edi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN43@assign

; 3770 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN43@assign:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	ecx, ebp
	mov	eax, 2147483647				; 7fffffffH
	shr	ecx, 1
	sub	eax, ecx
	cmp	ebp, eax
	jbe	SHORT $LN44@assign

; 3775 :             return _Max;

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN44@assign:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	eax, DWORD PTR [ecx+ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	ebx, eax
	cmovb	ebx, eax
$LN42@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, esi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	DWORD PTR __Ptr$[esp+16]

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	DWORD PTR __New_ptr$1$[esp+20], eax

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	eax

; 3795 :         _My_data._Mysize = _New_size;

	mov	DWORD PTR [esi+16], edi

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR [esi+20], ebx

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	call	_memcpy

; 343  :         _Left = _Right;

	mov	ebx, DWORD PTR __New_ptr$1$[esp+24]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ebx+edi], 0

; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	ebp, 16					; 00000010H
	jb	SHORT $LN21@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	inc	ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ebp, 4096				; 00001000H
	jb	SHORT $LN94@assign

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR [eax-4]
	add	ebp, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, ecx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN91@assign

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, ecx
$LN94@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ebp
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN21@assign:
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2695 :         return _Reallocate_for(_Count,

	mov	DWORD PTR [esi], ebx

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2697 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2698 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2699 :             },
; 2700 :             _Ptr);
; 2701 :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	ret	8
$LN91@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN110@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN107@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Old$1$ = -12						; size = 4
tv579 = -8						; size = 4
__New_ptr$1$ = -4					; size = 4
tv580 = 8						; size = 4
__Count$ = 8						; size = 4
tv589 = 12						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2630 :     basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // append _Count * _Ch

	sub	esp, 12					; 0000000cH
	push	ebx

; 2631 :         auto& _My_data            = _Get_data();
; 2632 :         const size_type _Old_size = _My_data._Mysize;
; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	ebx, DWORD PTR __Count$[esp+12]
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+20]
	mov	eax, ecx
	mov	ebp, DWORD PTR [edi+16]
	sub	eax, ebp
	mov	DWORD PTR __Old$1$[esp+28], ecx
	cmp	ebx, eax
	ja	SHORT $LN2@append

; 2634 :             _My_data._Mysize      = _Old_size + _Count;

	lea	eax, DWORD PTR [ebx+ebp]
	mov	DWORD PTR [edi+16], eax

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	eax, edi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	eax, DWORD PTR [edi]
$LN9@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2636 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	esi, DWORD PTR [eax+ebp]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+24]
	push	ebx
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0

; 2649 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN2@append:

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, 2147483647				; 7fffffffH
	mov	eax, edx
	sub	eax, ebp
	cmp	eax, ebx
	jb	$LN122@append

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	esi, DWORD PTR [ebx+ebp]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, edx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN43@append

; 3770 :             return _Max;

	mov	esi, edx
	jmp	SHORT $LN42@append
$LN43@append:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, ecx
	shr	eax, 1
	sub	edx, eax
	cmp	ecx, edx
	jbe	SHORT $LN44@append

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@append
$LN44@append:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN42@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	mov	ecx, edi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;
; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[esp+28], 16		; 00000010H
	lea	ecx, DWORD PTR [ebx+ebp]
	mov	DWORD PTR [edi+16], ecx
	movsx	ecx, BYTE PTR __Ch$[esp+24]
	mov	DWORD PTR [edi+20], esi
	lea	esi, DWORD PTR [eax+ebp]
	mov	DWORD PTR tv589[esp+24], ecx
	lea	ecx, DWORD PTR [esi+ebx]
	mov	DWORD PTR __New_ptr$1$[esp+28], eax
	mov	DWORD PTR tv580[esp+24], esi
	mov	DWORD PTR tv579[esp+28], ecx
	push	ebp
	jb	SHORT $LN21@append

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR [edi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	DWORD PTR tv589[esp+40]
	push	DWORD PTR tv580[esp+44]
	call	_memset

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv579[esp+52]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 24					; 00000018H

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[esp+28]
	inc	ecx

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN98@append

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN95@append

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN98@append:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2641 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2641 :         return _Reallocate_grow_by(_Count,

	mov	DWORD PTR [edi], eax

; 2649 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN21@append:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	eax
	call	_memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	DWORD PTR tv589[esp+40]
	push	esi
	call	_memset

; 343  :         _Left = _Right;

	lea	eax, DWORD PTR [esi+ebx]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 2641 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+28]
	mov	DWORD PTR [edi], eax

; 2649 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN122@append:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN95@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN119@append:
	int	3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 301  :         return __builtin_strlen(_First);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	mov	eax, edx

; 2626 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

	push	esi
	push	edi
	mov	esi, ecx

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [eax+1]
	npad	3
$LL7@append:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL7@append
	sub	eax, edi

; 2627 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	edi
	pop	esi

; 2628 :     }

	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -12						; size = 4
tv540 = -8						; size = 4
__New_ptr$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
tv541 = 12						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2604 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

	sub	esp, 12					; 0000000cH
	push	ebx

; 2605 :         // append [_Ptr, _Ptr + _Count)
; 2606 :         auto& _My_data            = _Get_data();
; 2607 :         const size_type _Old_size = _My_data._Mysize;
; 2608 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	ebx, DWORD PTR __Count$[esp+12]
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+20]
	mov	eax, ecx
	mov	ebp, DWORD PTR [edi+16]
	sub	eax, ebp
	mov	DWORD PTR __Old$1$[esp+28], ecx
	cmp	ebx, eax
	ja	SHORT $LN2@append

; 2609 :             _My_data._Mysize      = _Old_size + _Count;

	lea	eax, DWORD PTR [ebx+ebp]
	mov	DWORD PTR [edi+16], eax

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	eax, edi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	ecx, 16					; 00000010H

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	eax, DWORD PTR [edi]
$LN9@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	ebx
	push	DWORD PTR __Ptr$[esp+28]

; 2610 :             _Elem* const _Old_ptr = _My_data._Myptr();
; 2611 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	esi, DWORD PTR [eax+ebp]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0

; 2624 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN2@append:

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	edx, 2147483647				; 7fffffffH
	mov	eax, edx
	sub	eax, ebp
	cmp	eax, ebx
	jb	$LN122@append

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	esi, DWORD PTR [ebx+ebp]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, edx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN43@append

; 3770 :             return _Max;

	mov	esi, edx
	jmp	SHORT $LN42@append
$LN43@append:

; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, ecx
	shr	eax, 1
	sub	edx, eax
	cmp	ecx, edx
	jbe	SHORT $LN44@append

; 3775 :             return _Max;

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@append
$LN44@append:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	add	eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	esi, eax
	cmovb	esi, eax
$LN42@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	mov	ecx, edi
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 3823 :         _My_data._Orphan_all();
; 3824 :         _My_data._Mysize      = _New_size;
; 3825 :         _My_data._Myres       = _New_capacity;
; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	DWORD PTR __Old$1$[esp+28], 16		; 00000010H
	lea	ecx, DWORD PTR [ebx+ebp]
	mov	DWORD PTR [edi+20], esi
	mov	DWORD PTR [edi+16], ecx
	lea	esi, DWORD PTR [eax+ebp]
	mov	DWORD PTR __New_ptr$1$[esp+28], eax
	lea	ecx, DWORD PTR [esi+ebx]
	mov	DWORD PTR tv541[esp+24], esi
	mov	DWORD PTR tv540[esp+28], ecx
	push	ebp
	jb	SHORT $LN21@append

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR [edi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	eax
	call	_memcpy
	push	ebx
	push	DWORD PTR __Ptr$[esp+40]
	push	DWORD PTR tv541[esp+44]
	call	_memcpy

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR tv540[esp+52]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H

; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[esp+28]
	inc	ecx

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN98@append

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN95@append

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	esi, edx
$LN98@append:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2616 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+36]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	add	esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2616 :         return _Reallocate_grow_by(_Count,

	mov	DWORD PTR [edi], eax

; 2624 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN21@append:

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	eax
	call	_memcpy
	push	ebx
	push	DWORD PTR __Ptr$[esp+40]
	push	esi
	call	_memcpy

; 343  :         _Left = _Right;

	lea	eax, DWORD PTR [esi+ebx]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	add	esp, 24					; 00000018H

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 2616 :         return _Reallocate_grow_by(_Count,

	mov	eax, DWORD PTR __New_ptr$1$[esp+28]
	mov	DWORD PTR [edi], eax

; 2624 :     }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN122@append:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN95@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN119@append:
	int	3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	mov	eax, DWORD PTR __Right$[esp-4]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	mov	edx, DWORD PTR [eax+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	eax, DWORD PTR [eax]
$LN8@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	push	edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2579 :     }

	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2497 :     ~basic_string() noexcept { // destroy the string

	push	esi
	mov	esi, ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN43@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN42@basic_stri

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN39@basic_stri

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN42@basic_stri:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN43@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi

; 2503 :     }

	ret	0
$LN39@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN55@basic_stri:
	int	3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2434 :     void _Construct_lv_contents(const basic_string& _Right) {

	push	ebx
	push	ebp
	push	edi

; 2435 :         // assign by copying data stored in _Right
; 2436 :         // pre: this != &_Right
; 2437 :         // pre: *this owns no memory, iterators orphaned (note:
; 2438 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2439 :         auto& _My_data                = _Get_data();
; 2440 :         auto& _Right_data             = _Right._Get_data();
; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	edi, DWORD PTR __Right$[esp+8]
	mov	ebx, ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2435 :         // assign by copying data stored in _Right
; 2436 :         // pre: this != &_Right
; 2437 :         // pre: *this owns no memory, iterators orphaned (note:
; 2438 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2439 :         auto& _My_data                = _Get_data();
; 2440 :         auto& _Right_data             = _Right._Get_data();
; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	ebp, DWORD PTR [edi+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN13@Construct_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edi, DWORD PTR [edi]
$LN13@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2443 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	ebp, 16					; 00000010H
	jae	SHORT $LN2@Construct_

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	xmm0, XMMWORD PTR [edi]
	pop	edi
	movups	XMMWORD PTR [ebx], xmm0

; 2455 :         _My_data._Mysize = _Right_size;
; 2456 :         _My_data._Myres  = _New_capacity;
; 2457 :     }

	mov	DWORD PTR [ebx+16], ebp
	pop	ebp
	mov	DWORD PTR [ebx+20], 15			; 0000000fH
	pop	ebx
	ret	4
$LN2@Construct_:
	push	esi

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	esi, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	eax, 2147483647				; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	or	esi, 15					; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	esi, eax
	cmova	esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [esi+1]
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 2453 :         _Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_array);
; 2454 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	ecx, DWORD PTR [ebp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [ebx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ecx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2455 :         _My_data._Mysize = _Right_size;
; 2456 :         _My_data._Myres  = _New_capacity;
; 2457 :     }

	mov	DWORD PTR [ebx+16], ebp
	mov	DWORD PTR [ebx+20], esi
	pop	esi
	pop	edi
	pop	ebp
	pop	ebx
	ret	4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 2390 :         // assign by stealing _Right's buffer, memcpy optimization
; 2391 :         // pre: this != &_Right
; 2392 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is
; 2393 :         // complete pre: *this owns no memory, iterators orphaned (note:
; 2394 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2395 :         auto& _Right_data = _Right._Get_data();
; 2396 : 
; 2397 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2398 :         if (_Right_data._Large_string_engaged()) { // take ownership of _Right's iterators along with its buffer
; 2399 :             _Swap_proxy_and_iterators(_Right);
; 2400 :         } else {
; 2401 :             _Right._Orphan_all();
; 2402 :         }
; 2403 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2404 : 
; 2405 :         const auto _My_data_mem = reinterpret_cast<unsigned char*>(_STD addressof(_Get_data())) + _Memcpy_move_offset;
; 2406 :         const auto _Right_data_mem =
; 2407 :             reinterpret_cast<unsigned char*>(_STD addressof(_Right_data)) + _Memcpy_move_offset;
; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[esp-4]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 2409 :         _Right._Tidy_init();
; 2410 :     }

	ret	8
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2384 :         _NOEXCEPT_COND(noexcept(*this = _STD move(_Right))) { // assign by moving _Right

	push	esi
	push	edi

; 2376 :         if (this != _STD addressof(_Right)) {

	mov	edi, DWORD PTR __Right$[esp+4]

; 2384 :         _NOEXCEPT_COND(noexcept(*this = _STD move(_Right))) { // assign by moving _Right

	mov	esi, ecx

; 2376 :         if (this != _STD addressof(_Right)) {

	cmp	esi, edi
	je	SHORT $LN57@assign

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN52@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN51@assign

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN48@assign

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN51@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN52@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edi+16]
	movq	QWORD PTR [esi+16], xmm0

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi], 0
$LN57@assign:
	pop	edi

; 2385 :         *this = _STD move(_Right);
; 2386 :         return *this;

	mov	eax, esi

; 2387 :     }

	pop	esi
	ret	4
$LN48@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN94@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2375 :         _NOEXCEPT_COND(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {

	push	esi
	push	edi

; 2376 :         if (this != _STD addressof(_Right)) {

	mov	edi, DWORD PTR __Right$[esp+4]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN53@operator

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN48@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN47@operator

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN44@operator

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN47@operator:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN48@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edi+16]
	movq	QWORD PTR [esi+16], xmm0

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi], 0
$LN53@operator:
	pop	edi

; 2377 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});
; 2378 :         }
; 2379 : 
; 2380 :         return *this;

	mov	eax, esi

; 2381 :     }

	pop	esi
	ret	4
$LN44@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN89@operator:
	int	3
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign, COMDAT
; _this$ = ecx

; 2345 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {

	push	esi
	mov	esi, ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN43@Move_assig
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN42@Move_assig

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN39@Move_assig

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN42@Move_assig:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN43@Move_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[esp]

; 3878 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [esi+16], xmm0

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0
	pop	esi

; 2349 :     }

	ret	8
$LN39@Move_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN83@Move_assig:
	int	3
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[esp-4]

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [eax], 0

; 2297 :         : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) { // construct by moving _Right
; 2298 :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2299 :         _Take_contents(_Right, _Use_memcpy_move{});
; 2300 :     }

	mov	eax, ecx
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2231 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)

	push	ebx

; 2709 :         if (_Count <= _My_data._Myres) {

	mov	ebx, DWORD PTR __Count$[esp]

; 2231 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)

	push	edi
	mov	edi, ecx

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [edi], 0

; 2709 :         if (_Count <= _My_data._Myres) {

	cmp	ebx, 15					; 0000000fH
	ja	SHORT $LN24@basic_stri

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[esp+4]
	push	ebx
	push	eax
	push	edi

; 2711 :             _My_data._Mysize      = _Count;

	mov	DWORD PTR [edi+16], ebx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ebx+edi], 0

; 2238 :     }

	mov	eax, edi
	pop	edi
	pop	ebx
	ret	8
$LN24@basic_stri:

; 3785 :         if (_New_size > max_size()) {

	cmp	ebx, 2147483647				; 7fffffffH
	ja	SHORT $LN134@basic_stri
	push	ebp

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	ebp, ebx
	or	ebp, 15					; 0000000fH
	push	esi
	cmp	ebp, 2147483647				; 7fffffffH

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN65@basic_stri

; 3770 :             return _Max;

	mov	ebp, 2147483647				; 7fffffffH
	jmp	SHORT $LN64@basic_stri
$LN65@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	eax, 22					; 00000016H
	cmp	ebp, eax
	cmovb	ebp, eax
$LN64@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ebp+1]
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	movsx	ecx, BYTE PTR __Ch$[esp+12]

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	esi, eax

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	ebx
	push	ecx
	push	esi

; 3795 :         _My_data._Mysize = _New_size;

	mov	DWORD PTR [edi+16], ebx

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	DWORD PTR [edi+20], ebp

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	call	_memset
	add	esp, 12					; 0000000cH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [edi], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2238 :     }

	mov	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	pop	esi
	pop	ebp
	pop	edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2238 :     }

	pop	ebx
	ret	8
$LN134@basic_stri:

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN132@basic_stri:
	int	3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 301  :         return __builtin_strlen(_First);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	mov	eax, edx

; 2210 :     basic_string(_In_z_ const _Elem* const _Ptr)

	push	esi
	mov	esi, ecx
	push	edi

; 301  :         return __builtin_strlen(_First);

	lea	edi, DWORD PTR [eax+1]

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [esi], 0
	npad	2
$LL31@basic_stri:

; 301  :         return __builtin_strlen(_First);

	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL31@basic_stri
	sub	eax, edi

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2211 :         : _Mypair(_Zero_then_variadic_args_t()) { // construct from [_Ptr, <null>)
; 2212 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2213 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 2214 :         _Tidy_init();
; 2215 :         assign(_Ptr);
; 2216 :         _Proxy._Release();
; 2217 :     }

	pop	edi
	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3861 :         _My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 2161 :         : _Mypair(_Zero_then_variadic_args_t()) { // construct empty string
; 2162 :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2163 :         _Tidy_init();
; 2164 :     }

	mov	eax, ecx

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 343  :         _Left = _Right;

	mov	BYTE PTR [ecx], 0

; 2161 :         : _Mypair(_Zero_then_variadic_args_t()) { // construct empty string
; 2162 :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2163 :         _Tidy_init();
; 2164 :     }

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2145 :               _Alty_traits::select_on_container_copy_construction(_Right._Getal())) { // construct by copying _Right

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	edi, DWORD PTR __Right$[esp+12]

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	ebp, DWORD PTR [edi+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN33@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	edi, DWORD PTR [edi]
$LN33@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2443 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	ebp, 16					; 00000010H
	jae	SHORT $LN22@basic_stri

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	xmm0, XMMWORD PTR [edi]

; 2446 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	ebx, 15					; 0000000fH

; 2146 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2147 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 2148 :         _Construct_lv_contents(_Right);
; 2149 :         _Proxy._Release();
; 2150 :     }

	mov	eax, esi
	pop	edi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	XMMWORD PTR [esi], xmm0

; 2146 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2147 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 2148 :         _Construct_lv_contents(_Right);
; 2149 :         _Proxy._Release();
; 2150 :     }

	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebx
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
$LN22@basic_stri:

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	ebx, ebp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	eax, 2147483647				; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	or	ebx, 15					; 0000000fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	ebx, eax
	cmova	ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	eax, DWORD PTR [ebx+1]
	push	eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 2453 :         _Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_array);
; 2454 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	ecx, DWORD PTR [ebp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	DWORD PTR [esi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	push	ecx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2146 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2147 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 2148 :         _Construct_lv_contents(_Right);
; 2149 :         _Proxy._Release();
; 2150 :     }

	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebx
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2061 :         }

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2058 :         }

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2048 :         _Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN3@Xran:
	int	3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2036 :         if (_Mysize < _Off) {

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[esp-4]
	jb	SHORT $LN6@Check_offs

; 2038 :         }
; 2039 :     }

	ret	4
$LN6@Check_offs:

; 2037 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN4@Check_offs:
	int	3
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	setae	al

; 2033 :     }

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2023 :         const value_type* _Result = _Bx._Buf;
; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Myptr

; 2025 :             _Result = _Unfancy(_Bx._Ptr);
; 2026 :         }
; 2027 : 
; 2028 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2029 :     }

	ret	0
$LN8@Myptr:

; 2025 :             _Result = _Unfancy(_Bx._Ptr);
; 2026 :         }
; 2027 : 
; 2028 :         return _Result;

	mov	eax, ecx

; 2029 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2014 :         value_type* _Result = _Bx._Buf;
; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Myptr

; 2016 :             _Result = _Unfancy(_Bx._Ptr);
; 2017 :         }
; 2018 : 
; 2019 :         return _Result;

	mov	eax, DWORD PTR [ecx]

; 2020 :     }

	ret	0
$LN8@Myptr:

; 2016 :             _Result = _Unfancy(_Bx._Ptr);
; 2017 :         }
; 2018 : 
; 2019 :         return _Result;

	mov	eax, ecx

; 2020 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	DWORD PTR [ecx+16], 0

; 2003 :     }

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 832  :         return _Al;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 833  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 828  :         return static_cast<size_t>(-1) / sizeof(value_type);

	or	eax, -1

; 829  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	mov	ecx, DWORD PTR __Count$[esp-4]
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 49   :         return ::operator new(_Bytes);

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 93   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 49   :         return ::operator new(_Bytes);

	add	esp, 4

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN15@allocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN6@allocate:

; 178  :     if (_Bytes != 0) {

	test	ecx, ecx
	je	SHORT $LN7@allocate

; 49   :         return ::operator new(_Bytes);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN7@allocate:

; 182  :     return nullptr;

	xor	eax, eax

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	ret	4
$LN15@allocate:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	__invalid_parameter_noinfo_noreturn
$LN26@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 924  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	eax, DWORD PTR __Ptr$[esp-4]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN12@deallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, edx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 926  :     }

	ret	8
$LN12@deallocate:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	__invalid_parameter_noinfo_noreturn
$LN18@deallocate:
	int	3
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 916  :     }

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 374  :         return EOF;

	or	eax, -1

; 375  :     }

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 366  :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 367  :     }

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 361  :         return static_cast<unsigned char>(_Ch);

	mov	eax, DWORD PTR __Ch$[esp-4]
	movzx	eax, BYTE PTR [eax]

; 362  :     }

	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 343  :         _Left = _Right;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[esp-4]
	mov	BYTE PTR [eax], cl

; 344  :     }

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$char_traits@D@std@@SAPADQADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADQADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 338  :         // assign _Count * _Ch to [_First, ...)
; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR __Count$[esp-4]
	movsx	eax, BYTE PTR __Ch$[esp]
	push	eax
	push	DWORD PTR __First$[esp+4]
	call	_memset
	add	esp, 12					; 0000000cH

; 340  :     }

	ret	0
?assign@?$char_traits@D@std@@SAPADQADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 332  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	jmp	_memmove
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 309  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	jmp	_memcpy
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 299  :         // find length of null-terminated string
; 300  : #if _HAS_CXX17
; 301  :         return __builtin_strlen(_First);

	mov	eax, DWORD PTR __First$[esp-4]
	lea	edx, DWORD PTR [eax+1]
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 302  : #else // _HAS_CXX17
; 303  :         return _CSTD strlen(_First);
; 304  : #endif // _HAS_CXX17
; 305  :     }

	ret	0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$tuple@$$V@std@@QAE@ABV01@@Z PROC			; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 211  :         // copy construct
; 212  :     }

	mov	eax, ecx
	ret	4
??0?$tuple@$$V@std@@QAE@ABV01@@Z ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QAE@XZ
_TEXT	SEGMENT
??0?$tuple@$$V@std@@QAE@XZ PROC				; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 208  :     }

	mov	eax, ecx
	ret	0
??0?$tuple@$$V@std@@QAE@XZ ENDP				; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ
_TEXT	SEGMENT
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ PROC		; std::_Fake_proxy_ptr_impl::_Release, COMDAT
; _this$ = ecx

; 1451 :     void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ENDP		; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT
; _this$ = ecx

; 1448 :     _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	eax, ecx
	ret	8
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 1248 :     }

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1240 :     }

	ret	4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 1234 :     }

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 1136 :     return _Len;

	mov	eax, DWORD PTR __Len$[esp-4]

; 1137 : }

	ret	0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 107  :     _Bytes += _Non_user_size;

	mov	eax, DWORD PTR __Bytes$[esp-4]

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	add	DWORD PTR [eax], 35			; 00000023H
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax-4]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN7@Adjust_man

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	DWORD PTR [ecx], edx

; 126  : }

	ret	0
$LN7@Adjust_man:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	jmp	__invalid_parameter_noinfo_noreturn
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 49   :         return ::operator new(_Bytes);

	jmp	??2@YAPAXI@Z				; operator new
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 37   :     return _Count;

	mov	eax, DWORD PTR __Count$[esp-4]

; 38   : }

	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 508  :         return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH

; 509  :     }

	ret	0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 91   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
	test	ecx, ecx
	cmovne	eax, ecx

; 92   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx

; 87   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 68   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR __Other$[esp+4]
	add	eax, 4
	push	eax
	call	___std_exception_copy
	add	esp, 8

; 70   :     }

	mov	eax, esi
	pop	esi
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 63   :         _Data._What = _Message;

	mov	eax, DWORD PTR __Message$[esp-4]
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [ecx+4], xmm0
	mov	DWORD PTR [ecx+4], eax

; 64   :     }

	mov	eax, ecx
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -8					; size = 8
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 55   :     {

	sub	esp, 8

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[esp+4]
	xorps	xmm0, xmm0
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __InitData$[esp+12], eax
	lea	edx, DWORD PTR [esi+4]
	mov	BYTE PTR __InitData$[esp+16], 1

; 57   :         __std_exception_copy(&_InitData, &_Data);

	push	edx
	lea	eax, DWORD PTR __InitData$[esp+16]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	call	___std_exception_copy
	add	esp, 8

; 58   :     }

	mov	eax, esi
	pop	esi
	add	esp, 8
	ret	4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1498 :         int const _Result = __stdio_common_vsprintf_s(

	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	0
	push	DWORD PTR __Format$[esp+4]
	push	DWORD PTR __BufferCount$[esp+8]
	push	DWORD PTR __Buffer$[esp+12]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	___stdio_common_vsprintf_s

; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1842 :             int _Result;
; 1843 :             va_list _ArgList;
; 1844 :             __crt_va_start(_ArgList, _Format);
; 1845 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1846 :             __crt_va_end(_ArgList);
; 1847 :             return _Result;
; 1848 :         }

	ret	0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1498 :         int const _Result = __stdio_common_vsprintf_s(

	push	DWORD PTR __ArgList$[esp-4]
	push	DWORD PTR __Locale$[esp]
	push	DWORD PTR __Format$[esp+4]
	push	DWORD PTR __BufferCount$[esp+8]
	push	DWORD PTR __Buffer$[esp+12]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	___stdio_common_vsprintf_s

; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1503 :     }

	ret	0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _frexpl
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 4
_frexpl	PROC						; COMDAT

; 864  :         return frexp((double)_X, _Y);

	push	DWORD PTR __Y$[esp-4]
	movsd	xmm0, QWORD PTR __X$[esp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_frexp
	add	esp, 12					; 0000000cH

; 865  :     }

	ret	0
_frexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT _fabsl
_TEXT	SEGMENT
tv68 = -8						; size = 8
__X$ = 8						; size = 8
_fabsl	PROC						; COMDAT

; 842  :     {

	sub	esp, 8

; 843  :         return fabs((double)_X);

	movsd	xmm0, QWORD PTR __X$[esp+4]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movsd	QWORD PTR tv68[esp+8], xmm0
	fld	QWORD PTR tv68[esp+8]

; 844  :     }

	add	esp, 8
	ret	0
_fabsl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 169  :         (void)_Size;
; 170  :         return _Where;

	mov	eax, DWORD PTR __Where$[esp-4]

; 171  :     }

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
